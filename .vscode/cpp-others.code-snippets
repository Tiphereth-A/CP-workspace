{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "init-cpp-simple": {
        "scope": "cpp",
        "prefix": ["iis", "init_simple"],
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using i64 = int64_t;",
            "using u64 = uint64_t;",
            "\nconst int N = 1e5 + 5;",
            "\nint main() {",
            "\t$0",
            "\treturn 0;",
            "}"
        ]
    },
    "init-default": {
        "scope": "cpp",
        "prefix": ["ii", "init"],
        "body": [
            "#ifndef DISABLE_PRAGMA",
            "#pragma GCC optimize (\"Ofast,no-stack-protector,unroll-loops,fast-math\")",
            "#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\")",
            "#endif",
            "#ifdef __GNUG__",
            "#include <bits/extc++.h>",
            "#else",
            "#include <bits/stdc++.h>",
            "#endif",
            "using namespace std;",
            "using i64 = std::int64_t;",
            "using u64 = std::uint64_t;",
            "using i128 = __int128_t;",
            "using u128 = __uint128_t;",
            "using vi = std::vector<int>;",
            "using vi64 = std::vector<i64>;",
            "using pii = std::pair<int, int>;",
            "using pii64 = std::pair<i64, i64>;",
            "\n#define for_(i, l, r, vars...) for (decltype(l + r) i = (l), i##end = (r), ##vars; i <= i##end; ++i)",
            "#define rfor_(i, r, l, vars...) for (make_signed_t<decltype(r - l)> i = (r), i##end = (l), ##vars; i >= i##end; --i)",
            "#define foreach_val_(i, container) for (auto i : container)",
            "#define foreach_ref_(i, container) for (auto &i : container)",
            "#define foreach_cref_(i, container) for (const auto &i : container)",
            "#define foreach_rref_(i, container) for (auto &&i : container)",
            "#define foreach_binding_(container, vars...) for (auto &&[##vars] : container)",
            "#define foreach_iter_(it, container) for (auto it = (container).begin(); it != (container).end(); ++it)",
            "#define foreach_iter_range_(it, container, l, r) for (auto it = (container).begin() + l; it != (container).begin() + r; ++it)",
            "#define foreach_riter_(it, container) for (auto it = (container).rbegin(); it != (container).rend(); ++it)",
            "#define foreach_riter_range_(it, container, l, r) for (auto it = (container).rbegin() + l; it != (container).rbegin() + r; ++it)",
            "#define ins_(a) std::inserter((a), (a).begin())",
            "#define all_(a) (a).begin(), (a).end()",
            "#define set_nul_(a) memset(a, 0, sizeof(a))",
            "#define set_inf_(a) memset(a, 0x3f, sizeof(a))",
            "#define set_nul_n_(a, n) memset(a, 0, sizeof(*(a)) * (n))",
            "#define set_inf_n_(a, n) memset(a, 0x3f, sizeof(*(a)) * (n))",
            "#define run_exec_(expressions, after_process) \\",
            "\t{                                         \\",
            "\t\texpressions;                          \\",
            "\t\tafter_process;                        \\",
            "\t}",
            "#define run_exit_(expressions) run_exec_(expressions, exit(0))",
            "#define run_return_(expressions, val) run_exec_(expressions, return val)",
            "#define run_return_void_(expressions) run_exec_(expressions, return )",
            "#define run_break_(expressions) run_exec_(expressions, break)",
            "#define run_continue_(expressions) run_exec_(expressions, continue)",
            "#define mid_(l, r) ((l) + (((r) - (l)) >> 1))",
            "#define len_(l, r) ((r) - (l) + 1)",
            "#define lowbit_(x) (1 << __builtin_ctz(x))",
            "#define lowbit_64_(x) (1 << __builtin_ctzll(x))",
            "#define debug_line_ (std::cerr << __LINE__ << ' ' << __FUNCTION__ << std::endl)",
            "inline void debug() {",
            "#ifdef LOCAL_",
            "\tstd::cerr << std::endl;",
            "#endif",
            "}",
            "template <typename Tp, typename... Args>",
            "inline void debug(Tp x, Args... args) {",
            "#ifdef LOCAL_",
            "\tstd::cerr << x << ' ';",
            "\tdebug(args...);",
            "#endif",
            "}",
            "template <class T>",
            "bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }",
            "template <class T>",
            "bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }",
            "\nconst uint32_t OFFSET = 5;",
            "const uint32_t N = 1e5 + OFFSET;",
            "const uint32_t M = 2e5 + OFFSET;",
            "const uint32_t K = 21;",
            "const uint32_t MOD = 1e9 + 7;",
            "const double EPS = 1e-6;",
            "const int INF = 0x3f3f3f3f;",
            "const i64 INF64 = 0x3f3f3f3f3f3f3f3f;",
            "const double PI = acos(-1.0);",
            "const pii DIR4[4] = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};",
            "const pii DIR8[8] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};",
            "const int EXP10[10] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};",
            "const int FACT[11] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800};",
            "const auto STATIC__ = []() { return 0.0; }();",
            "\n#define MULTI_CASES",
            "inline auto solve(int t_) -> void {",
            "\t$0",
            "}",
            "\nint main() {",
            "#ifdef LOCAL_",
            "\tauto CLOCK_ST_ = std::chrono::high_resolution_clock::now();",
            "#endif",
            "\tint i_ = 0;",
            "\n#ifdef MULTI_CASES",
            "\tint t_;",
            "\tstd::cin >> t_;",
            "\tfor (i_ = 1; i_ <= t_; ++i_)",
            "#endif",
            "\t\tsolve(i_);",
            "#ifdef LOCAL_",
            "\tauto CLOCK_ED_ = std::chrono::high_resolution_clock::now();",
            "\tstd::clog << \"\\n---\\n\"",
            "            << \"Time used: \" << std::chrono::duration_cast<std::chrono::nanoseconds>(CLOCK_ED_ - CLOCK_ST_).count() * 1e-6l << \" ms\" << std::endl;",
            "#endif",
            "\treturn 0;",
            "}"
        ]
    },
    "init-cpp-with-fastIO": {
        "scope": "cpp",
        "prefix": ["iifio", "init-fast-io"],
        "body": [
            "#ifndef DISABLE_PRAGMA",
            "#pragma GCC optimize (\"Ofast,no-stack-protector,unroll-loops,fast-math\")",
            "#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\")",
            "#endif",
            "#ifdef __GNUG__",
            "#include <bits/extc++.h>",
            "#else",
            "#include <bits/stdc++.h>",
            "#endif",
            "\nnamespace fast_io {",
            "namespace type_traits {",
            "template <class Tp>",
            "using is_int = typename std::conditional<(std::is_integral<Tp>::value && std::is_signed<Tp>::value) || std::is_same<Tp, __int128_t>::value, std::true_type, std::false_type>::type;",
            "\ntemplate <class Tp>",
            "using is_uint = typename std::conditional<(std::is_integral<Tp>::value && std::is_unsigned<Tp>::value) || std::is_same<Tp, __uint128_t>::value, std::true_type, std::false_type>::type;",
            "\ntemplate <class Tp>",
            "using make_uint = typename std::conditional<std::is_same<Tp, __int128_t>::value, __uint128_t, typename std::conditional<std::is_signed<Tp>::value, std::make_unsigned<Tp>, std::common_type<Tp>>::type>::type;",
            "}  // namespace type_traits",
            "\ntemplate <size_t BUFFER_SIZE>",
            "class FastIn {",
            "\tusing self = FastIn<BUFFER_SIZE>;",
            "\nprotected:",
            "\tchar buffer_[BUFFER_SIZE], *now_ = buffer_, *end_ = buffer_;",
            "\tFILE *file_;",
            "\npublic:",
            "\texplicit FastIn(FILE *file = stdin) noexcept: file_(file) {}",
            "\n\tinline char fetch() noexcept { return this->now_ == this->end_ && (this->end_ = (this->now_ = this->buffer_) + fread(this->buffer_, 1, BUFFER_SIZE, this->file_), this->now_ == this->end_) ? EOF : *(this->now_)++; }",
            "\tinline char visit() noexcept { return this->now_ == this->end_ && (this->end_ = (this->now_ = this->buffer_) + fread(this->buffer_, 1, BUFFER_SIZE, this->file_), this->now_ == this->end_) ? EOF : *(this->now_); }",
            "\tinline void set_file(FILE *file) noexcept {",
            "\t\tthis->file_ = file;",
            "\t\tnow_ = end_ = buffer_;",
            "\t}",
            "\n\ttemplate <typename Tp, typename std::enable_if<type_traits::is_int<Tp>::value>::type * = nullptr>",
            "\tinline self &read(Tp &n) noexcept {",
            "\t\tbool is_neg = false;",
            "\t\tchar ch = this->fetch();",
            "\t\twhile (!isdigit(ch)) {",
            "\t\t\tis_neg |= ch == '-';",
            "\t\t\tch = this->fetch();",
            "\t\t}",
            "\t\tn = 0;",
            "\t\twhile (isdigit(ch)) {",
            "\t\t\t(n *= 10) += ch & 0x0f;",
            "\t\t\tch = this->fetch();",
            "\t\t}",
            "\t\tif (is_neg) n = -n;",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename Tp, typename std::enable_if<type_traits::is_uint<Tp>::value>::type * = nullptr>",
            "\tinline self &read(Tp &n) noexcept {",
            "\t\tchar ch = this->fetch();",
            "\t\twhile (!isdigit(ch)) ch = this->fetch();",
            "\t\tn = 0;",
            "\t\twhile (isdigit(ch)) {",
            "\t\t\t(n *= 10) += ch & 0x0f;",
            "\t\t\tch = this->fetch();",
            "\t\t}",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &read(char &n) noexcept {",
            "\t\tn = this->fetch();",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &read(char *n) noexcept {",
            "\t\tchar *n_ = n;",
            "\t\twhile (!isgraph(*n_ = this->fetch()));",
            "\t\twhile (isgraph(*(++n_) = this->fetch()));",
            "\t\t*n_ = '\\0';",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &read(std::string &n) noexcept {",
            "\t\tn.clear();",
            "\t\tchar n_;",
            "\t\twhile (!isgraph(n_ = this->fetch()));",
            "\t\tn.push_back(n_);",
            "\t\twhile (isgraph(n_ = this->fetch())) n.push_back(n_);",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &getline(char *n) noexcept {",
            "\t\tchar *n_ = n;",
            "\t\twhile (!isprint(*n_ = this->fetch()));",
            "\t\twhile (isprint(*(++n_) = this->fetch()));",
            "\t\t*n_ = '\\0';",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &getline(std::string &n) noexcept {",
            "\t\tchar n_;",
            "\t\twhile (!isprint(n_ = this->fetch()));",
            "\t\tn.push_back(n_);",
            "\t\twhile (isprint(n_ = this->fetch())) n.push_back(n_);",
            "\t\treturn *this;",
            "\t}",
            "};",
            "\ntemplate <size_t BUFFER_SIZE, size_t INT_BUFFER_SIZE>",
            "class FastOut {",
            "\tusing self = FastOut<BUFFER_SIZE, INT_BUFFER_SIZE>;",
            "\nprivate:",
            "\tchar int_buffer_[INT_BUFFER_SIZE], *now_ib_;",
            "\nprotected:",
            "\tchar buffer_[BUFFER_SIZE], *now_ = buffer_;",
            "\tconst char * const end_ = buffer_ + BUFFER_SIZE;",
            "\tFILE *file_;",
            "\npublic:",
            "\texplicit FastOut(FILE *file = stdout) noexcept: file_(file) {}",
            "\t~FastOut() noexcept { this->flush(); }",
            "\n\tinline void flush() noexcept {",
            "\t\tfwrite(this->buffer_, 1, this->now_ - this->buffer_, this->file_);",
            "\t\tthis->now_ = this->buffer_;",
            "\t}",
            "\t\tinline void set_file(FILE *file) noexcept {",
            "\t\tthis->file_ = file;",
            "\t}",
            "\n\tinline self &linebreak() noexcept {",
            "\t\tthis->write('\\n');",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &space() noexcept {",
            "\t\tthis->write(' ');",
            "\t\treturn *this;",
            "\t}",
            "\n\tinline self &write(const char &n) noexcept {",
            "\t\tif (this->now_ == this->end_) this->flush();",
            "\t\t*(this->now_++) = n;",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &write(const char *n) noexcept {",
            "\t\tsize_t len = strlen(n), l_;",
            "\t\tconst char *n_ = n;",
            "\t\twhile (this->now_ + len >= this->end_) {",
            "\t\t\tl_ = this->end_ - this->now_;",
            "\t\t\tmemcpy(this->now_, n_, l_);",
            "\t\t\tthis->now_ += l_;",
            "\t\t\tn_ += l_;",
            "\t\t\tlen -= l_;",
            "\t\t\tthis->flush();",
            "\t\t}",
            "\t\tmemcpy(this->now_, n_, len);",
            "\t\tthis->now_ += len;",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <class Tp, typename std::enable_if<type_traits::is_int<Tp>::value>::type * = nullptr>",
            "\tinline self &write(Tp n) noexcept {",
            "\t\tif (n < 0) {",
            "\t\t\tthis->write('-');",
            "\t\t\tn = -n;",
            "\t\t}",
            "\t\treturn this->write(static_cast<typename type_traits::make_uint<Tp>::type>(n));",
            "\t}",
            "\ttemplate <class Tp, typename std::enable_if<type_traits::is_uint<Tp>::value>::type * = nullptr>",
            "\tinline self &write(Tp n) noexcept {",
            "\t\tthis->now_ib_ = this->int_buffer_ + INT_BUFFER_SIZE - 1;",
            "\t\tdo { *(--(this->now_ib_)) = char(n % 10) | '0'; } while (n /= 10);",
            "\t\tthis->write(this->now_ib_);",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &write(const std::string &str) noexcept {",
            "\t\tthis->write(str.c_str());",
            "\t\treturn *this;",
            "\t}",
            "};",
            "\nconst std::size_t BUFFER_SIZE = 1 << 21;",
            "FastIn<BUFFER_SIZE> fast_in;",
            "FastOut<BUFFER_SIZE, 21> fast_out;",
            "}  // namespace fast_io",
            "using fast_io::fast_in;",
            "using fast_io::fast_out;",
            "\nusing namespace std;",
            "using i64 = std::int64_t;",
            "using u64 = std::uint64_t;",
            "using i128 = __int128_t;",
            "using u128 = __uint128_t;",
            "using vi = std::vector<int>;",
            "using vi64 = std::vector<i64>;",
            "using pii = std::pair<int, int>;",
            "using pii64 = std::pair<i64, i64>;",
            "\n#define for_(i, l, r, vars...) for (decltype(l + r) i = (l), i##end = (r), ##vars; i <= i##end; ++i)",
            "#define rfor_(i, r, l, vars...) for (make_signed_t<decltype(r - l)> i = (r), i##end = (l), ##vars; i >= i##end; --i)",
            "#define foreach_val_(i, container) for (auto i : container)",
            "#define foreach_ref_(i, container) for (auto &i : container)",
            "#define foreach_cref_(i, container) for (const auto &i : container)",
            "#define foreach_rref_(i, container) for (auto &&i : container)",
            "#define foreach_binding_(container, vars...) for (auto &&[##vars] : container)",
            "#define foreach_iter_(it, container) for (auto it = (container).begin(); it != (container).end(); ++it)",
            "#define foreach_iter_range_(it, container, l, r) for (auto it = (container).begin() + l; it != (container).begin() + r; ++it)",
            "#define foreach_riter_(it, container) for (auto it = (container).rbegin(); it != (container).rend(); ++it)",
            "#define foreach_riter_range_(it, container, l, r) for (auto it = (container).rbegin() + l; it != (container).rbegin() + r; ++it)",
            "#define ins_(a) std::inserter((a), (a).begin())",
            "#define all_(a) (a).begin(), (a).end()",
            "#define set_nul_(a) memset(a, 0, sizeof(a))",
            "#define set_inf_(a) memset(a, 0x3f, sizeof(a))",
            "#define set_nul_n_(a, n) memset(a, 0, sizeof(*(a)) * (n))",
            "#define set_inf_n_(a, n) memset(a, 0x3f, sizeof(*(a)) * (n))",
            "#define run_exec_(expressions, after_process) \\",
            "\t{                                         \\",
            "\t\texpressions;                          \\",
            "\t\tafter_process;                        \\",
            "\t}",
            "#define run_exit_(expressions) run_exec_(expressions, exit(0))",
            "#define run_return_(expressions, val) run_exec_(expressions, return val)",
            "#define run_return_void_(expressions) run_exec_(expressions, return )",
            "#define run_break_(expressions) run_exec_(expressions, break)",
            "#define run_continue_(expressions) run_exec_(expressions, continue)",
            "#define mid_(l, r) ((l) + (((r) - (l)) >> 1))",
            "#define len_(l, r) ((r) - (l) + 1)",
            "#define lowbit_(x) (1 << __builtin_ctz(x))",
            "#define lowbit_64_(x) (1 << __builtin_ctzll(x))",
            "#define debug_line_ (std::cerr << __LINE__ << ' ' << __FUNCTION__ << std::endl)",
            "inline void debug() {",
            "#ifdef LOCAL_",
            "\tstd::cerr << std::endl;",
            "#endif",
            "}",
            "template <typename Tp, typename... Args>",
            "inline void debug(Tp x, Args... args) {",
            "#ifdef LOCAL_",
            "\tstd::cerr << x << ' ';",
            "\tdebug(args...);",
            "#endif",
            "}",
            "template <class T>",
            "bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }",
            "template <class T>",
            "bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }",
            "\nconst uint32_t OFFSET = 5;",
            "const uint32_t N = 1e5 + OFFSET;",
            "const uint32_t M = 2e5 + OFFSET;",
            "const uint32_t K = 21;",
            "const uint32_t MOD = 1e9 + 7;",
            "const double EPS = 1e-6;",
            "const int INF = 0x3f3f3f3f;",
            "const i64 INF64 = 0x3f3f3f3f3f3f3f3f;",
            "const double PI = acos(-1.0);",
            "const pii DIR4[4] = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};",
            "const pii DIR8[8] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};",
            "const int EXP10[10] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};",
            "const int FACT[11] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800};",
            "const auto STATIC__ = []() { return 0.0; }();",
            "\n#define MULTI_CASES",
            "inline auto solve(int t_) -> void {",
            "\t$0",
            "}",
            "\nint main() {",
            "#ifdef LOCAL_",
            "\tauto CLOCK_ST_ = std::chrono::high_resolution_clock::now();",
            "#endif",
            "\tint i_ = 0;",
            "\n#ifdef MULTI_CASES",
            "\tint t_;",
            "\tfast_in.read(t_);",
            "\tfor (i_ = 1; i_ <= t_; ++i_)",
            "#endif",
            "\t\tsolve(i_);",
            "#ifdef LOCAL_",
            "\tauto CLOCK_ED_ = std::chrono::high_resolution_clock::now();",
            "\tstd::clog << \"\\n---\\n\"",
            "            << \"Time used: \" << std::chrono::duration_cast<std::chrono::nanoseconds>(CLOCK_ED_ - CLOCK_ST_).count() * 1e-6l << \" ms\" << std::endl;",
            "#endif",
            "\treturn 0;",
            "}"
        ]
    },
    "foreach": {
        "scope": "cpp",
        "prefix": ["fors", "foreach"],
        "body": [
            "#define for_(i, l, r, vars...) for (decltype(l + r) i = (l), i##end = (r), ##vars; i <= i##end; ++i)",
            "#define rfor_(i, r, l, vars...) for (make_signed_t<decltype(r - l)> i = (r), i##end = (l), ##vars; i >= i##end; --i)",
            "#define foreach_val_(i, container) for (auto i : container)",
            "#define foreach_ref_(i, container) for (auto &i : container)",
            "#define foreach_cref_(i, container) for (const auto &i : container)",
            "#define foreach_rref_(i, container) for (auto &&i : container)",
            "#define foreach_binding_(container, vars...) for (auto &&[##vars] : container)",
            "#define foreach_iter_(it, container) for (auto it = (container).begin(); it != (container).end(); ++it)",
            "#define foreach_iter_range_(it, container, l, r) for (auto it = (container).begin() + l; it != (container).begin() + r; ++it)",
            "#define foreach_riter_(it, container) for (auto it = (container).rbegin(); it != (container).rend(); ++it)",
            "#define foreach_riter_range_(it, container, l, r) for (auto it = (container).rbegin() + l; it != (container).rbegin() + r; ++it)"
        ]
    },
    "constants": {
        "scope": "cpp",
        "prefix": ["consts", "constants"],
        "body": [
            "const uint32_t OFFSET = 5;",
            "const uint32_t N = 1e5 + OFFSET;",
            "const uint32_t M = 2e5 + OFFSET;",
            "const uint32_t K = 21;",
            "const uint32_t MOD = 1e9 + 7;",
            "const double EPS = 1e-6;",
            "const int INF = 0x3f3f3f3f;",
            "const i64 INF64 = 0x3f3f3f3f3f3f3f3f;",
            "const double PI = acos(-1.0);",
            "const pii DIR4[4] = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};",
            "const pii DIR8[8] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};",
            "const int EXP10[10] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};",
            "const int FACT[11] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800};",
            "const auto STATIC__ = []() { return 0.0; }();"
        ]
    },
    "typedefs": {
        "scope": "cpp",
        "prefix": "typedefs",
        "body": [
            "using i64 = std::int64_t;",
            "using u64 = std::uint64_t;",
            "using i128 = __int128_t;",
            "using u128 = __uint128_t;",
            "using vi = std::vector<int>;",
            "using vi64 = std::vector<i64>;",
            "using pii = std::pair<int, int>;",
            "using pii64 = std::pair<i64, i64>;"
        ]
    },
    "ostream-int128": {
        "scope": "cpp",
        "prefix": ["os128", "out128", "cout128"],
        "body": [
            "ostream& operator<<(ostream& os, i128 n) {",
            "\tif (n < 0) {",
            "\t\tos << '-';",
            "\t\tn = -n;",
            "\t}",
            "\tif (n > 9) os << (i128)(n / 10);",
            "\tos << (uint_fast16_t)(n % 10);",
            "\treturn os;",
            "}",
            "ostream& operator<<(ostream& os, u128 n) {",
            "\tif (n > 9) os << (u128)(n / 10);",
            "\tos << (uint_fast16_t)(n % 10);",
            "\treturn os;",
            "}"
        ]
    }
}

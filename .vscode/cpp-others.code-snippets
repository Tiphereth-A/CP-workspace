{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "chtholly": {
        "scope": "cpp",
        "prefix": [
            "chtholly-tree",
            "old-driver-tree"
        ],
        "body": [
            "template <class Tp = int>",
            "class Chtholly {",
            "public:",
            "//! [l, r]",
            "struct Node {",
            "size_t l, r;",
            "mutable Tp v;",
            "//! [l, r]",
            "Node(size_t const &l, size_t const &r, Tp const &v): l(l), r(r), v(v) {}",
            "bool operator<(Node const &o) const { return l < o.l; }",
            "};",
            "protected:",
            "std::set<Node> data;",
            "public:",
            "Chtholly(): data() {}",
            "explicit Chtholly(std::vector<Tp> const &c): Chtholly() {",
            "size_t cnt = 0;",
            "for (auto &&i : c) {",
            "data.emplace(cnt, cnt, i);",
            "++cnt;",
            "}",
            "}",
            "void clear() { data.clear(); }",
            "//! [l, r]",
            "void insert(size_t l, size_t r, Tp const &v) { data.emplace(l, r, v); }",
            "auto find(size_t x) const { return std::prev(data.upper_bound(Node{x, 0, 0})); }",
            "auto split(size_t x) {",
            "auto it = find(x);",
            "if (it->l == x) return it;",
            "auto [l, r, v] = *it;",
            "data.erase(it);",
            "data.emplace(l, x - 1, v);",
            "return data.emplace(x, r, v).first;",
            "}",
            "//! [l, r]",
            "void assign(size_t l, size_t r, Tp const &v) {",
            "auto itr = split(r + 1), itl = split(l);",
            "data.erase(itl, itr);",
            "data.emplace(l, r, v);",
            "}",
            "//! [l, r]",
            "// merge adjacent nodes with same value",
            "void assign_and_merge(size_t l, size_t r, Tp const &v) {",
            "auto itl = find(l), itr = find(r);",
            "if (itr != data.end()) {",
            "if (itr != std::prev(data.end()) && itr->r == r && (++itr)->v == v)",
            "r = (itr++)->r;",
            "else if (itr->v != v) {",
            "itr = split(r + 1);",
            "itl = find(l);",
            "} else",
            "r = (itr++)->r;",
            "}",
            "if (itl != data.begin() && itr->l == l && std::prev(itl)->v == v)",
            "l = (--itl)->l;",
            "else if (itl->v != v)",
            "itl = split(l);",
            "else",
            "l = itl->l;",
            "data.erase(itl, itr);",
            "data.emplace(l, r, v);",
            "}",
            "//! [l, r]",
            "// @param func: (iter) -> void",
            "template <class Func>",
            "void run(size_t l, size_t r, Func func) {",
            "for (auto itr = split(r + 1), itl = split(l); itl != itr; ++itl) func(itl);",
            "}",
            "//! [l, r]",
            "// @param func: (iter_l, iter_r) -> auto",
            "template <class Func>",
            "auto run_no_split(size_t l, size_t r, Func func) const { return func(find(l), find(r)); }",
            "};"
        ]
    },
    "enumerate-cpp17": {
        "scope": "cpp",
        "prefix": [
            "enumerate-cpp17"
        ],
        "body": [
            "namespace Enumerate {",
            "template <typename T, std::enable_if_t<is_iterable<T>::value> * = nullptr>",
            "class enumerate_impl_ {",
            "public:",
            "using iter_t = typename remove_cvref_t<T>::iterator;",
            "private:",
            "const T &container_;",
            "size_t sz_;",
            "iter_t now_;",
            "public:",
            "enumerate_impl_(T x): container_(x), sz_(0), now_(x.begin()) {}",
            "const enumerate_impl_ &begin() const { return *this; }",
            "const enumerate_impl_ &end() const { return *this; }",
            "bool operator!=(const enumerate_impl_ &) const { return now_ != container_.end(); }",
            "void operator++() {",
            "++now_;",
            "++sz_;",
            "}",
            "std::pair<std::size_t, iter_t> operator*() const { return {sz_, now_}; }",
            "};",
            "//! Usage: for(auto [index, iter] : enumerate(container)) {...}",
            "template <typename T>",
            "enumerate_impl_<T> enumerate(T &&container) { return {std::forward<T>(container)}; }",
            "}  // namespace Enumerate",
            "using Enumerate::enumerate;"
        ]
    },
    "foreach": {
        "scope": "cpp",
        "prefix": [
            "fors",
            "foreach"
        ],
        "body": [
            "#define for_(i, l, r, vars...) for (std::make_signed_t<decltype(l + r)> i = (l), i##end = (r), ##vars; i <= i##end; ++i)",
            "#define for_step_(i, l, r, s, vars...) for (std::make_signed_t<decltype(l + r)> i = (l), i##end = (r), ##vars; i <= i##end; i += s)",
            "#define rfor_(i, r, l, vars...) for (std::make_signed_t<decltype(r - l)> i = (r), i##end = (l), ##vars; i >= i##end; --i)",
            "#define rfor_step_(i, r, l, s, vars...) for (std::make_signed_t<decltype(r - l)> i = (r), i##end = (l), ##vars; i >= i##end; i -= s)",
            "#define foreach_val_(i, container) for (auto i : container)",
            "#define foreach_ref_(i, container) for (auto &i : container)",
            "#define foreach_cref_(i, container) for (const auto &i : container)",
            "#define foreach_rref_(i, container) for (auto &&i : container)",
            "#define foreach_binding_(container, vars...) for (auto &&[vars] : container)",
            "#define foreach_iter_(it, container) for (auto it = (container).begin(); it != (container).end(); ++it)",
            "#define foreach_iter_range_(it, container, l, r) for (auto it = (container).begin() + l; it != (container).begin() + r; ++it)",
            "#define foreach_riter_(it, container) for (auto it = (container).rbegin(); it != (container).rend(); ++it)",
            "#define foreach_riter_range_(it, container, l, r) for (auto it = (container).rbegin() + l; it != (container).rbegin() + r; ++it)"
        ]
    },
    "hoverline": {
        "scope": "cpp",
        "prefix": [
            "hoverline"
        ],
        "body": [
            "// @return {leftmost, rightmost}",
            "template <class Tp>",
            "std::pair<std::vector<ptrdiff_t>, std::vector<ptrdiff_t>> hoverline(std::vector<Tp> const &a) {",
            "std::vector<ptrdiff_t> l(a.size()), r(a.size());",
            "std::iota(l.begin(), l.end(), 0);",
            "std::iota(r.begin(), r.end(), 0);",
            "for (size_t i = 1; i < a.size(); ++i)",
            "while (l[i] && a[l[i] - 1] >= a[i]) l[i] = l[l[i] - 1];",
            "for (ptrdiff_t i = (ptrdiff_t)a.size() - 2; i >= 0; --i)",
            "while (r[i] < (ptrdiff_t)a.size() - 1 && a[r[i] + 1] >= a[i]) r[i] = r[r[i] + 1];",
            "return {l, r};",
            "}"
        ]
    },
    "gcc-temp-ignore-warning": {
        "scope": "cpp",
        "prefix": [
            "gcc-ignore-warning",
            "ignore-warning"
        ],
        "body": [
            "#pragma GCC diagnostic push",
            "#pragma GCC diagnostic ignored \"${1:-Wconversion}\"",
            "$2",
            "#pragma GCC diagnostic pop"
        ]
    },
    "init-cpp-simple": {
        "scope": "cpp",
        "prefix": [
            "iis",
            "init-simple"
        ],
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using i64 = int64_t;",
            "using u64 = uint64_t;",
            "\n// #define MULTI_CASES",
            "auto solve([[maybe_unused]] int t_ = 0) -> void {",
            "$0",
            "}",
            "\nint main() {",
            "#ifdef LOCAL_",
            "auto CLOCK_ST_ = std::chrono::high_resolution_clock::now();",
            "std::cerr << std::boolalpha << std::fixed << std::setprecision(6);",
            "#endif",
            "std::ios::sync_with_stdio(false);",
            "std::cin.tie(nullptr);",
            "int i_ = 0;",
            "#ifdef MULTI_CASES",
            "int t_ = 0;",
            "std::cin >> t_;",
            "for (i_ = 0; i_ < t_; ++i_)",
            "#endif",
            "solve(i_);",
            "#ifdef LOCAL_",
            "auto CLOCK_ED_ = std::chrono::high_resolution_clock::now();",
            "std::clog << \"\\n---\\nTime used: \" << std::chrono::duration_cast<std::chrono::nanoseconds>(CLOCK_ED_ - CLOCK_ST_).count() * 1e-6l << \" ms\" << std::endl;",
            "#endif",
            "return 0;",
            "}",
        ]
    },
    "stdc++11": {
        "scope": "cpp",
        "prefix": [
            "stdc++11"
        ],
        "body": [
            "#ifndef _GLIBCXX_NO_ASSERT",
            "#include <cassert>",
            "#endif",
            "#include <cctype>",
            "#include <cerrno>",
            "#include <cfloat>",
            "#include <ciso646>",
            "#include <climits>",
            "#include <clocale>",
            "#include <cmath>",
            "#include <csetjmp>",
            "#include <csignal>",
            "#include <cstdarg>",
            "#include <cstddef>",
            "#include <cstdio>",
            "#include <cstdlib>",
            "#include <cstring>",
            "#include <ctime>",
            "#include <cwchar>",
            "#include <cwctype>",
            "#include <algorithm>",
            "#include <bitset>",
            "#include <complex>",
            "#include <deque>",
            "#include <exception>",
            "#include <fstream>",
            "#include <functional>",
            "#include <iomanip>",
            "#include <ios>",
            "#include <iosfwd>",
            "#include <iostream>",
            "#include <istream>",
            "#include <iterator>",
            "#include <limits>",
            "#include <list>",
            "#include <locale>",
            "#include <map>",
            "#include <memory>",
            "#include <new>",
            "#include <numeric>",
            "#include <ostream>",
            "#include <queue>",
            "#include <set>",
            "#include <sstream>",
            "#include <stack>",
            "#include <stdexcept>",
            "#include <streambuf>",
            "#include <string>",
            "#include <typeinfo>",
            "#include <utility>",
            "#include <valarray>",
            "#include <vector>",
            "#include <ccomplex>",
            "#include <cfenv>",
            "#include <cinttypes>",
            "#include <cstdalign>",
            "#include <cstdbool>",
            "#include <cstdint>",
            "#include <ctgmath>",
            "#include <cuchar>",
            "#include <array>",
            "#include <atomic>",
            "#include <chrono>",
            "#include <codecvt>",
            "#include <condition_variable>",
            "#include <forward_list>",
            "#include <future>",
            "#include <initializer_list>",
            "#include <mutex>",
            "#include <random>",
            "#include <ratio>",
            "#include <regex>",
            "#include <scoped_allocator>",
            "#include <system_error>",
            "#include <thread>",
            "#include <tuple>",
            "#include <typeindex>",
            "#include <type_traits>",
            "#include <unordered_map>",
            "#include <unordered_set>"
        ]
    },
    "stdc++98": {
        "scope": "cpp",
        "prefix": [
            "stdc++98"
        ],
        "body": [
            "#ifndef _GLIBCXX_NO_ASSERT",
            "#include <cassert>",
            "#endif",
            "#include <cctype>",
            "#include <cerrno>",
            "#include <cfloat>",
            "#include <ciso646>",
            "#include <climits>",
            "#include <clocale>",
            "#include <cmath>",
            "#include <csetjmp>",
            "#include <csignal>",
            "#include <cstdarg>",
            "#include <cstddef>",
            "#include <cstdio>",
            "#include <cstdlib>",
            "#include <cstring>",
            "#include <ctime>",
            "#include <cwchar>",
            "#include <cwctype>",
            "#include <algorithm>",
            "#include <bitset>",
            "#include <complex>",
            "#include <deque>",
            "#include <exception>",
            "#include <fstream>",
            "#include <functional>",
            "#include <iomanip>",
            "#include <ios>",
            "#include <iosfwd>",
            "#include <iostream>",
            "#include <istream>",
            "#include <iterator>",
            "#include <limits>",
            "#include <list>",
            "#include <locale>",
            "#include <map>",
            "#include <memory>",
            "#include <new>",
            "#include <numeric>",
            "#include <ostream>",
            "#include <queue>",
            "#include <set>",
            "#include <sstream>",
            "#include <stack>",
            "#include <stdexcept>",
            "#include <streambuf>",
            "#include <string>",
            "#include <typeinfo>",
            "#include <utility>",
            "#include <valarray>",
            "#include <vector>"
        ]
    }
}
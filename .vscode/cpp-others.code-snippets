{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "binary-search": {
        "scope": "cpp",
        "prefix": [
            "binary-search"
        ],
        "body": [
            "template <class Tp, class Pred>",
            "Tp binary_search(Pred check, Tp ok, Tp ng) {",
            "REif_(!check(ok));",
            "while (std::abs(ok - ng) > 1) {",
            "Tp x = (ng + ok) / 2;",
            "(check(x) ? ok : ng) = x;",
            "}",
            "return ok;",
            "}",
            "template <class Tp, class Pred, std::enable_if_t<std::is_floating_point_v<Tp>> * = nullptr>",
            "Tp binary_search_real(Pred check, Tp ok, Tp ng, Tp eps) {",
            "REif_(!check(ok));",
            "while (std::abs(ok - ng) > eps) {",
            "Tp x = (ng + ok) / 2;",
            "(check(x) ? ok : ng) = x;",
            "}",
            "return (ng + ok) / 2;",
            "}"
        ]
    },
    "cantor-expansion": {
        "scope": "cpp",
        "prefix": [
            "cantor",
            "cantor-exp"
        ],
        "body": [
            "namespace Cantor_expansion {",
            "const uint64_t N = 1e6 + 5;",
            "const uint64_t MOD = ULLONG_MAX;",
            "uint64_t n, p[N];",
            "BIT<N, int64_t> tr;",
            "uint64_t frac[N] = {1};",
            "void init(uint64_t n) { tr.clear(); for (uint64_t i = 1; i <= n; ++i) frac[i] = i * frac[i - 1] % MOD; }",
            "uint64_t main(uint64_t n, const uint64_t a[]) {",
            "init(n);",
            "uint64_t ret = 1;",
            "for (uint64_t i = n; i; --i) { p[i] = tr.query(a[i]); tr.modify(a[i]); }",
            "for (uint64_t i = 1; i <= n; ++i) ret = (ret + p[i] * frac[n - i] % MOD) % MOD;",
            "return ret;",
            "}",
            "}"
        ]
    },
    "chtholly": {
        "scope": "cpp",
        "prefix": [
            "chtholly-tree",
            "old-driver-tree"
        ],
        "body": [
            "template <class Tp = int>",
            "class Chtholly {",
            "public:",
            "//! [l, r]",
            "struct Node {",
            "size_t l, r;",
            "mutable Tp v;",
            "//! [l, r]",
            "Node(size_t const &l, size_t const &r, Tp const &v): l(l), r(r), v(v) {}",
            "bool operator<(Node const &o) const { return l < o.l; }",
            "};",
            "protected:",
            "std::set<Node> data;",
            "public:",
            "Chtholly(): data() {}",
            "explicit Chtholly(std::vector<Tp> const &c): Chtholly() {",
            "size_t cnt = 0;",
            "for (auto &&i : c) {",
            "data.emplace(cnt, cnt, i);",
            "++cnt;",
            "}",
            "}",
            "void clear() { data.clear(); }",
            "//! [l, r]",
            "void insert(size_t l, size_t r, Tp const &v) { data.emplace(l, r, v); }",
            "auto find(size_t x) const { return std::prev(data.upper_bound(Node{x, 0, 0})); }",
            "auto split(size_t x) {",
            "auto it = find(x);",
            "if (it->l == x) return it;",
            "auto [l, r, v] = *it;",
            "data.erase(it);",
            "data.emplace(l, x - 1, v);",
            "return data.emplace(x, r, v).first;",
            "}",
            "//! [l, r]",
            "void assign(size_t l, size_t r, Tp const &v) {",
            "auto itr = split(r + 1), itl = split(l);",
            "data.erase(itl, itr);",
            "data.emplace(l, r, v);",
            "}",
            "//! [l, r]",
            "// merge adjacent nodes with same value",
            "void assign_and_merge(size_t l, size_t r, Tp const &v) {",
            "auto itl = find(l), itr = find(r);",
            "if (itr != data.end()) {",
            "if (itr != std::prev(data.end()) && itr->r == r && (++itr)->v == v)",
            "r = (itr++)->r;",
            "else if (itr->v != v) {",
            "itr = split(r + 1);",
            "itl = find(l);",
            "} else",
            "r = (itr++)->r;",
            "}",
            "if (itl != data.begin() && itr->l == l && std::prev(itl)->v == v)",
            "l = (--itl)->l;",
            "else if (itl->v != v)",
            "itl = split(l);",
            "else",
            "l = itl->l;",
            "data.erase(itl, itr);",
            "data.emplace(l, r, v);",
            "}",
            "//! [l, r]",
            "// @param func: (iter) -> void",
            "template <class Func>",
            "void run(size_t l, size_t r, Func func) {",
            "for (auto itr = split(r + 1), itl = split(l); itl != itr; ++itl) func(itl);",
            "}",
            "//! [l, r]",
            "// @param func: (iter_l, iter_r) -> auto",
            "template <class Func>",
            "auto run_no_split(size_t l, size_t r, Func func) const { return func(find(l), find(r)); }",
            "};"
        ]
    },
    "discretization": {
        "scope": "cpp",
        "prefix": [
            "discretization"
        ],
        "body": [
            "template <class Tp = std::vector<int>>",
            "auto discretization(Tp &var) -> Tp {",
            "Tp d__(var);",
            "std::sort(d__.begin(), d__.end());",
            "d__.erase(std::unique(d__.begin(), d__.end()), d__.end());",
            "for (auto &i : var) i = std::distance(d__.begin(), std::lower_bound(d__.begin(), d__.end(), i));",
            "return d__;",
            "}"
        ]
    },
    "enumerate-cpp17": {
        "scope": "cpp",
        "prefix": [
            "enumerate-cpp17"
        ],
        "body": [
            "namespace Enumerate {",
            "template <typename T, std::enable_if_t<is_iterable<T>::value> * = nullptr>",
            "class enumerate_impl_ {",
            "public:",
            "using iter_t = typename remove_cvref_t<T>::iterator;",
            "private:",
            "const T &container_;",
            "size_t sz_;",
            "iter_t now_;",
            "public:",
            "enumerate_impl_(T x): container_(x), sz_(0), now_(x.begin()) {}",
            "const enumerate_impl_ &begin() const { return *this; }",
            "const enumerate_impl_ &end() const { return *this; }",
            "bool operator!=(const enumerate_impl_ &) const { return now_ != container_.end(); }",
            "void operator++() {",
            "++now_;",
            "++sz_;",
            "}",
            "std::pair<std::size_t, iter_t> operator*() const { return {sz_, now_}; }",
            "};",
            "//! Usage: for(auto [index, iter] : enumerate(container)) {...}",
            "template <typename T>",
            "enumerate_impl_<T> enumerate(T &&container) { return {std::forward<T>(container)}; }",
            "}  // namespace Enumerate",
            "using Enumerate::enumerate;"
        ]
    },
    "foreach": {
        "scope": "cpp",
        "prefix": [
            "fors",
            "foreach"
        ],
        "body": [
            "#define for_(i, l, r, vars...) for (std::make_signed_t<decltype(l + r)> i = (l), i##end = (r), ##vars; i <= i##end; ++i)",
            "#define for_step_(i, l, r, s, vars...) for (std::make_signed_t<decltype(l + r)> i = (l), i##end = (r), ##vars; i <= i##end; i += s)",
            "#define rfor_(i, r, l, vars...) for (std::make_signed_t<decltype(r - l)> i = (r), i##end = (l), ##vars; i >= i##end; --i)",
            "#define rfor_step_(i, r, l, s, vars...) for (std::make_signed_t<decltype(r - l)> i = (r), i##end = (l), ##vars; i >= i##end; i -= s)",
            "#define foreach_val_(i, container) for (auto i : container)",
            "#define foreach_ref_(i, container) for (auto &i : container)",
            "#define foreach_cref_(i, container) for (const auto &i : container)",
            "#define foreach_rref_(i, container) for (auto &&i : container)",
            "#define foreach_binding_(container, vars...) for (auto &&[vars] : container)",
            "#define foreach_iter_(it, container) for (auto it = (container).begin(); it != (container).end(); ++it)",
            "#define foreach_iter_range_(it, container, l, r) for (auto it = (container).begin() + l; it != (container).begin() + r; ++it)",
            "#define foreach_riter_(it, container) for (auto it = (container).rbegin(); it != (container).rend(); ++it)",
            "#define foreach_riter_range_(it, container, l, r) for (auto it = (container).rbegin() + l; it != (container).rbegin() + r; ++it)"
        ]
    },
    "hash-splitmix64": {
        "scope": "cpp",
        "prefix": [
            "custom-hash",
            "hash-splitmix64"
        ],
        "body": [
            "// <https://codeforces.com/blog/entry/62393>",
            "struct CustomHash {",
            "static constexpr uint64_t splitmix64(uint64_t x) {",
            "// <http://xorshift.di.unimi.it/splitmix64.c>",
            "x += 0x9e3779b97f4a7c15;",
            "x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "return x ^ (x >> 31);",
            "}",
            "static constexpr size_t append(size_t x, size_t y) { return x ^ (y >> 1) ^ ((y & 1) << (sizeof(size_t) * 8 - 1)); }",
            "size_t operator()(uint64_t x) const {",
            "static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
            "return splitmix64(x + FIXED_RANDOM);",
            "}",
            "template <class Tp, class Up>",
            "size_t operator()(std::pair<Tp, Up> const &p) const { return append((*this)(p.first), (*this)(p.second)); }",
            "template <typename... Ts>",
            "size_t operator()(std::tuple<Ts...> const &tp) const {",
            "size_t ret = 0;",
            "std::apply([&](Ts const &...targs) { ((ret = append(ret, (*this)(targs))), ...); }, tp);",
            "return ret;",
            "}",
            "template <class Tp, std::enable_if_t<std::is_same_v<decltype(std::declval<Tp>().begin()), typename Tp::iterator> && std::is_same_v<decltype(std::declval<Tp>().end()), typename Tp::iterator>> * = nullptr>",
            "size_t operator()(Tp const &tp) const {",
            "size_t ret = 0;",
            "for (auto &&i : tp) ret = append(ret, (*this)(i));",
            "return ret;",
            "}",
            "};",
            "template <class Tp, class Hash = CustomHash>",
            "using hset = std::unordered_set<Tp, Hash>;",
            "template <class Key, class Tp, class Hash = CustomHash>",
            "using hmap = std::unordered_map<Key, Tp, Hash>;"
        ]
    },
    "hoverline": {
        "scope": "cpp",
        "prefix": [
            "hoverline"
        ],
        "body": [
            "// @return {leftmost, rightmost}",
            "template <class Tp>",
            "std::pair<std::vector<ptrdiff_t>, std::vector<ptrdiff_t>> hoverline(std::vector<Tp> const &a) {",
            "std::vector<ptrdiff_t> l(a.size()), r(a.size());",
            "std::iota(l.begin(), l.end(), 0);",
            "std::iota(r.begin(), r.end(), 0);",
            "for (size_t i = 1; i < a.size(); ++i)",
            "while (l[i] && a[l[i] - 1] >= a[i]) l[i] = l[l[i] - 1];",
            "for (ptrdiff_t i = (ptrdiff_t)a.size() - 2; i >= 0; --i)",
            "while (r[i] < (ptrdiff_t)a.size() - 1 && a[r[i] + 1] >= a[i]) r[i] = r[r[i] + 1];",
            "return {l, r};",
            "}"
        ]
    },
    "gcc-temp-ignore-warning": {
        "scope": "cpp",
        "prefix": [
            "gcc-ignore-warning",
            "ignore-warning"
        ],
        "body": [
            "#pragma GCC diagnostic push",
            "#pragma GCC diagnostic ignored \"${1:-Wconversion}\"",
            "$2",
            "#pragma GCC diagnostic pop"
        ]
    },
    "gray-code": {
        "scope": "cpp",
        "prefix": [
            "gray-code"
        ],
        "body": [
            "// k-th n-digit Gray code",
            "template <size_t N = 64, class = typename std::enable_if<0 < N && N <= 64>::type>",
            "std::bitset<N> gray_code(size_t n, uint64_t k) {",
            "assert(0 < n && n <= N && k < (1ull << n));",
            "std::bitset<N> res;",
            "k ^= k >> 1;",
            "while (~--n) res.set(n, k >> n & 1);",
            "return res;",
            "}"
        ]
    },
    "init-cpp-simple": {
        "scope": "cpp",
        "prefix": [
            "iis",
            "init-simple"
        ],
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using i64 = int64_t;",
            "using u64 = uint64_t;",
            "\n// #define MULTI_CASES",
            "auto solve([[maybe_unused]] int t_ = 0) -> void {",
            "$0",
            "}",
            "\nint main() {",
            "#ifdef LOCAL_",
            "auto CLOCK_ST_ = std::chrono::high_resolution_clock::now();",
            "std::cerr << std::boolalpha << std::fixed << std::setprecision(6);",
            "#endif",
            "std::ios::sync_with_stdio(false);",
            "std::cin.tie(nullptr);",
            "int i_ = 0;",
            "#ifdef MULTI_CASES",
            "int t_ = 0;",
            "std::cin >> t_;",
            "for (i_ = 0; i_ < t_; ++i_)",
            "#endif",
            "solve(i_);",
            "#ifdef LOCAL_",
            "auto CLOCK_ED_ = std::chrono::high_resolution_clock::now();",
            "std::clog << \"\\n---\\nTime used: \" << std::chrono::duration_cast<std::chrono::nanoseconds>(CLOCK_ED_ - CLOCK_ST_).count() * 1e-6l << \" ms\" << std::endl;",
            "#endif",
            "return 0;",
            "}",
        ]
    },
    "ndvector": {
        "scope": "cpp",
        "prefix": [
            "ndvector",
            "n-dim-vector"
        ],
        "body": [
            "namespace NdVector {",
            "template <size_t N, class Tp>",
            "struct ndvector: public std::vector<ndvector<N - 1, Tp>> {",
            "static_assert(N > 0, \"N should be positive\");",
            "using base_tp = ndvector<N - 1, Tp>;",
            "using base = std::vector<base_tp>;",
            "using self = ndvector<N, Tp>;",
            "template <class T, typename... Ts>",
            "ndvector(T &&n, Ts &&...args): base(n, base_tp(args...)) {}",
            "constexpr size_t dim() const { return N; }",
            "template <class T>",
            "void fill(T &&x) {",
            "for (auto &i : *this) i.fill(x);",
            "}",
            "};",
            "template <class Tp>",
            "struct ndvector<1, Tp>: public std::vector<Tp> {",
            "using base = std::vector<Tp>;",
            "using self = ndvector<1, Tp>;",
            "template <class T>",
            "ndvector(T &&n): base(n) {}",
            "constexpr size_t dim() const { return 1; }",
            "template <class T>",
            "void fill(T &&x) { std::fill(this->begin(), this->end(), x); }",
            "};",
            "}  // namespace NdVector",
            "template <size_t N, class Tp>",
            "using ndvc = NdVector::ndvector<N, Tp>;"
        ]
    },
    "ostream-int128": {
        "scope": "cpp",
        "prefix": [
            "os128",
            "out128",
            "cout128"
        ],
        "body": [
            "ostream& operator<<(ostream& os, i128 n) {",
            "if (n < 0) {",
            "os << '-';",
            "n = -n;",
            "}",
            "if (n > 9) os << (i128)(n / 10);",
            "os << (uint_fast32_t)(n % 10);",
            "return os;",
            "}",
            "ostream& operator<<(ostream& os, u128 n) {",
            "if (n > 9) os << (u128)(n / 10);",
            "os << (uint_fast32_t)(n % 10);",
            "return os;",
            "}"
        ]
    },
    "radix-sort-u32": {
        "scope": "cpp",
        "prefix": [
            "rsortu32",
            "radix-sort-u32",
        ],
        "body": [
            "namespace radix_sort_u32 {",
            "using data_t = uint32_t;",
            "using size_type = uint32_t;",
            "using pointer = data_t*;",
            "using bucket = size_type[256];",
            "bucket cnt0, cnt8, cnt16, cnt24;",
            "constexpr void main(pointer a, size_type n) {",
            "pointer b = (pointer)malloc(n * sizeof(data_t));",
            "for (pointer _ = a + n, i = a; i < _; ++i) {",
            "++cnt0[*i & 255];",
            "++cnt8[*i >> 8 & 255];",
            "++cnt16[*i >> 16 & 255];",
            "++cnt24[*i >> 24 & 255];",
            "}",
            "for (size_type i = 1; i < 256; ++i) {",
            "cnt0[i] += cnt0[i - 1];",
            "cnt8[i] += cnt8[i - 1];",
            "cnt16[i] += cnt16[i - 1];",
            "cnt24[i] += cnt24[i - 1];",
            "}",
            "for (pointer i = a + n; --i >= a;) b[--cnt0[*i & 255]] = *i;",
            "for (pointer i = b + n; --i >= b;) a[--cnt8[*i >> 8 & 255]] = *i;",
            "for (pointer i = a + n; --i >= a;) b[--cnt16[*i >> 16 & 255]] = *i;",
            "for (pointer i = b + n; --i >= b;) a[--cnt24[*i >> 24 & 255]] = *i;",
            "free(b);",
            "}",
            "}",
        ]
    },
    "reverse-cantor-expansion": {
        "scope": "cpp",
        "prefix": [
            "rcantor",
            "rcantor-exp"
        ],
        "body": [
            "namespace reverse_Cantor_expansion {",
            "const uint64_t N = 64;",
            "uint64_t n, p[N];",
            "BT_BIT<N> tr;",
            "uint64_t frac[N] = {1};",
            "void init(uint64_t n) { tr.clear(); for (uint64_t i = 1; i <= n; ++i) frac[i] = i * frac[i - 1]; }",
            "void main(uint64_t num, uint64_t a[], uint64_t n) {",
            "init(n); --num;",
            "for (uint64_t i = 1; i <= n; ++i) tr.insert(i);",
            "for (uint64_t i = 1; i <= n; ++i) { p[i] = num / frac[n - i]; num %= frac[n - i]; }",
            "for (uint64_t i = 1; i <= n; ++i) tr.remove(a[i] = tr.kth_num(p[i] + 1));",
            "}",
            "} ",
        ]
    },
    "stdc++11": {
        "scope": "cpp",
        "prefix": [
            "stdc++11"
        ],
        "body": [
            "#ifndef _GLIBCXX_NO_ASSERT",
            "#include <cassert>",
            "#endif",
            "#include <cctype>",
            "#include <cerrno>",
            "#include <cfloat>",
            "#include <ciso646>",
            "#include <climits>",
            "#include <clocale>",
            "#include <cmath>",
            "#include <csetjmp>",
            "#include <csignal>",
            "#include <cstdarg>",
            "#include <cstddef>",
            "#include <cstdio>",
            "#include <cstdlib>",
            "#include <cstring>",
            "#include <ctime>",
            "#include <cwchar>",
            "#include <cwctype>",
            "#include <algorithm>",
            "#include <bitset>",
            "#include <complex>",
            "#include <deque>",
            "#include <exception>",
            "#include <fstream>",
            "#include <functional>",
            "#include <iomanip>",
            "#include <ios>",
            "#include <iosfwd>",
            "#include <iostream>",
            "#include <istream>",
            "#include <iterator>",
            "#include <limits>",
            "#include <list>",
            "#include <locale>",
            "#include <map>",
            "#include <memory>",
            "#include <new>",
            "#include <numeric>",
            "#include <ostream>",
            "#include <queue>",
            "#include <set>",
            "#include <sstream>",
            "#include <stack>",
            "#include <stdexcept>",
            "#include <streambuf>",
            "#include <string>",
            "#include <typeinfo>",
            "#include <utility>",
            "#include <valarray>",
            "#include <vector>",
            "#include <ccomplex>",
            "#include <cfenv>",
            "#include <cinttypes>",
            "#include <cstdalign>",
            "#include <cstdbool>",
            "#include <cstdint>",
            "#include <ctgmath>",
            "#include <cuchar>",
            "#include <array>",
            "#include <atomic>",
            "#include <chrono>",
            "#include <codecvt>",
            "#include <condition_variable>",
            "#include <forward_list>",
            "#include <future>",
            "#include <initializer_list>",
            "#include <mutex>",
            "#include <random>",
            "#include <ratio>",
            "#include <regex>",
            "#include <scoped_allocator>",
            "#include <system_error>",
            "#include <thread>",
            "#include <tuple>",
            "#include <typeindex>",
            "#include <type_traits>",
            "#include <unordered_map>",
            "#include <unordered_set>"
        ]
    },
    "stdc++98": {
        "scope": "cpp",
        "prefix": [
            "stdc++98"
        ],
        "body": [
            "#ifndef _GLIBCXX_NO_ASSERT",
            "#include <cassert>",
            "#endif",
            "#include <cctype>",
            "#include <cerrno>",
            "#include <cfloat>",
            "#include <ciso646>",
            "#include <climits>",
            "#include <clocale>",
            "#include <cmath>",
            "#include <csetjmp>",
            "#include <csignal>",
            "#include <cstdarg>",
            "#include <cstddef>",
            "#include <cstdio>",
            "#include <cstdlib>",
            "#include <cstring>",
            "#include <ctime>",
            "#include <cwchar>",
            "#include <cwctype>",
            "#include <algorithm>",
            "#include <bitset>",
            "#include <complex>",
            "#include <deque>",
            "#include <exception>",
            "#include <fstream>",
            "#include <functional>",
            "#include <iomanip>",
            "#include <ios>",
            "#include <iosfwd>",
            "#include <iostream>",
            "#include <istream>",
            "#include <iterator>",
            "#include <limits>",
            "#include <list>",
            "#include <locale>",
            "#include <map>",
            "#include <memory>",
            "#include <new>",
            "#include <numeric>",
            "#include <ostream>",
            "#include <queue>",
            "#include <set>",
            "#include <sstream>",
            "#include <stack>",
            "#include <stdexcept>",
            "#include <streambuf>",
            "#include <string>",
            "#include <typeinfo>",
            "#include <utility>",
            "#include <valarray>",
            "#include <vector>"
        ]
    }
}
{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "simulated-annealing": {
        "scope": "cpp",
        "prefix": "simulated-annealing",
        "body": [
            "namespace Simulated_annealing {",
            "using data_t = int64_t;",
            "using fit_t = double;",
            "using index_t = size_t;",
            "using temperature_t = double;",
            "template <class Tp>",
            "using seq_t = std::vector<Tp>;",
            "using data_seq_t = seq_t<data_t>;",
            "using fit_seq_t = seq_t<fit_t>;",
            "std::default_random_engine g(time(nullptr));",
            "std::uniform_int_distribution<data_t> data_gen;",
            "std::uniform_int_distribution<index_t> idx_gen;",
            "std::uniform_real_distribution<temperature_t> p_gen(0, 1);",
            "const temperature_t delta_T = 1 - 1e-5;",
            "const temperature_t initial_T = 1e10;",
            "const temperature_t minimum_T = 1. / initial_T;",
            "//! DO NOT exit this if the sequence don't need to be checked",
            "constexpr bool is_valid_seq(data_seq_t const &seq) { return true; }",
            "//! --- Config end ---",
            "data_seq_t new_seq_shuffle(data_seq_t const &seq) {",
            "data_seq_t ret(seq);",
            "do { std::shuffle(ret.begin(), ret.end(), g); } while (!is_valid_seq(ret));",
            "return ret;",
            "}",
            "data_seq_t new_seq_generate(data_seq_t const &minimum, data_seq_t const &maximum) {",
            "data_seq_t ret;",
            "do {",
            "ret.clear();",
            "for (auto i = minimum.begin(), j = maximum.begin(); i != minimum.end() && j != maximum.end(); ++i, ++j) ret.push_back(data_gen(g) % (*j - *i) + *i);",
            "} while (!is_valid_seq(ret));",
            "return ret;",
            "}",
            "data_seq_t new_seq_generate_n(data_t &minimum, data_t &maximum, index_t &n) {",
            "data_seq_t ret;",
            "ret.resize(n);",
            "do {",
            "for (index_t i = 0; i < n; ++i) ret[i] = data_gen(g) % (maximum - minimum) + minimum;",
            "} while (!is_valid_seq(ret));",
            "return ret;",
            "}",
            "void swap_two_elements(data_seq_t &seq, const index_t &x, const index_t &y) { iter_swap(seq.begin() + x, seq.begin() + y); }",
            "std::pair<index_t, index_t> swap_two_elements_randomly(data_seq_t &seq) {",
            "index_t x, y;",
            "do {",
            "x = idx_gen(g) % seq.size();",
            "y = idx_gen(g) % seq.size();",
            "} while (x == y);",
            "swap_two_elements(seq, x, y);",
            "return {x, y};",
            "}",
            "//? Metropolis acceptance criteria",
            "bool accept(const fit_t &delta_fitness, const temperature_t &now_T) { return delta_fitness <= 0 || exp(-delta_fitness / now_T) > p_gen(g); }",
            "// Find minimum for fitness(sequence), which sequence is a permutation of initial_sequence",
            "template <typename fitness_func = std::function<fit_t(data_seq_t const &)>>",
            "fit_t main_seq(data_seq_t &ans_seq, fitness_func fitness) {",
            "// data_seq_t now_seq;",
            "fit_t ans = fitness(ans_seq), now_ans;",
            "index_t x, y;",
            "for (temperature_t T = initial_T; T > minimum_T; T *= delta_T) {",
            "std::tie(x, y) = swap_two_elements_randomly(ans_seq);",
            "now_ans = fitness(ans_seq);",
            "if (accept(now_ans - ans, T))",
            "ans = now_ans;",
            "else",
            "swap_two_elements(ans_seq, x, y);",
            "//? you can also use these below instead if you want the sequence changes more rapidly",
            "// now_seq = new_seq_shuffle(ans_seq);",
            "// now_ans = fitness(ans_seq);",
            "// if (accept(now_ans - ans, T)) {",
            "//     ans = now_ans;",
            "//     ans_seq = now_seq;",
            "// }",
            "}",
            "return ans;",
            "}",
            "// Find minimum for fitness(sequence), which sequence[i] in [minimum[i], maximum[i])",
            "template <typename fitness_func = std::function<fit_t(data_seq_t const &)>>",
            "fit_t main_range(data_seq_t const &minimum, data_seq_t const &maximum, fitness_func fitness) {",
            "data_seq_t ans_seq(new_seq_generate(minimum, maximum)), now_seq;",
            "fit_t ans = fitness(ans_seq), now_ans;",
            "for (temperature_t T = initial_T; T > minimum_T; T *= delta_T) {",
            "now_seq = new_seq_generate(minimum, maximum);",
            "now_ans = fitness(now_seq);",
            "if (accept(now_ans - ans, T)) {",
            "ans = now_ans;",
            "ans_seq = now_seq;",
            "}",
            "}",
            "return ans;",
            "}",
            "// Find minimum for fitness(sequence), which sequence[0..n-1] in [minimum, maximum)",
            "template <typename fitness_func = std::function<fit_t(data_seq_t const &)>>",
            "fit_t main_range_n(data_seq_t const &minimum, data_seq_t const &maximum, index_t const &n, fitness_func fitness) {",
            "data_seq_t ans_seq(new_seq_generate_n(minimum, maximum, n)), now_seq;",
            "fit_t ans = fitness(ans_seq), now_ans;",
            "for (temperature_t T = initial_T; T > minimum_T; T *= delta_T) {",
            "now_seq = new_seq_generate_n(minimum, maximum, n);",
            "now_ans = fitness(now_seq);",
            "if (accept(now_ans - ans, T)) {",
            "ans = now_ans;",
            "ans_seq = now_seq;",
            "}",
            "}",
            "return ans;",
            "}",
            "}  // namespace Simulated_annealing",
            "using Simulated_annealing::main_range, Simulated_annealing::main_range_n, Simulated_annealing::main_seq;",
        ]
    }
}
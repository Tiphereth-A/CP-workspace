{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "graph": {
        "scope": "cpp",
        "prefix": ["graph", "edges"],
        "body": [
            "struct Edge {",
            "\tint w, to, next;",
            "\tEdge(int _w = 0, int _to = 0, int _next = 0) : w(_w), to(_to), next(_next) {}",
            "} e[M];",
            "int head[N], cnt_edge;",
            "int in[N], out[N];",
            "void addEdge(int x, int y, int w = 1) {",
            "\te[++cnt_edge] = Edge(w, y, head[x]);",
            "\thead[x] = cnt_edge;",
            "\t++in[y];",
            "\t++out[x];",
            "}",
            "\n#define _for_graph(head, e, i, now) for (int i = head[now], to = e[i].to; i; to = e[i = e[i].next].to)"
        ]
    },
    "dijkstra": {
        "scope": "cpp",
        "prefix": ["dijkstra", "dijk"],
        "body": [
            "int  dis[N];",
            "void dijkstra(int s) {",
            "\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;",
            "\tmemset(dis, 0x3f, sizeof(dis));",
            "\tq.emplace(dis[s] = 0, s);",
            "\twhile (!q.empty()) {",
            "\t\tauto [dis_now, now] = q.top();",
            "\t\tq.pop();",
            "\t\tif (dis[now] < dis_now) continue;",
            "\t\tfor (int i = head[now], to; i; i = e[i].next)",
            "\t\t\tif (dis[to = e[i].to] > dis[now] + e[i].w) q.emplace(dis[to] = dis[now] + e[i].w, to);",
            "\t}",
            "}"
        ]
    },
    "kruakal": {
        "scope": "cpp",
        "prefix": "kruskal",
        "body": [
            "struct Edge {",
            "\tint  w, from, to;",
            "\tbool operator<(const Edge& other) const { return w < other.w; }",
            "} e[M];",
            "int  cnt_edge;",
            "void addEdge(int x, int y, int w = 1) { e[++cnt_edge] = {w, x, y}; }",
            "\nint  fa[N];",
            "int  find(int x) { return x == fa[x] ? fa[x] : fa[x] = find(fa[x]); }",
            "void merge(int x, int y) { fa[find(x)] = find(y); }",
            "\nlong long kruskal(int n, int k = 1) {",
            "\tsort(e + 1, e + cnt_edge + 1);",
            "\tfor (int i = 0; i <= n; ++i) fa[i] = i;",
            "\tint       cnt = 0;",
            "\tlong long ans = 0;",
            "\tfor (int i = 1, fx, fy; i <= cnt_edge; ++i) {",
            "\t\tfx = find(e[i].from);",
            "\t\tfy = find(e[i].to);",
            "\t\tif (fx == fy) continue;",
            "\t\tfa[fx] = fy;",
            "\t\t++cnt;",
            "\t\tans += e[i].w;",
            "\t\tif (cnt == n - k) break;",
            "\t}",
            "\tif (cnt != n - k) throw \"No Answer\";",
            "\treturn ans;",
            "}"
        ]
    },
    "johnson": {
        "scope": "cpp",
        "prefix": "johnson",
        "body": [
            "namespace Johnson_shortest_path {",
            "const int64_t INF = 0x3f3f3f3f3f3f3f3f;",
            "\nstruct Edge {",
            "\tint to, next;",
            "\tint64_t w;",
            "\tEdge(int64_t _w = 0, int _to = 0, int _next = -1):",
            "\t\tto(_to), next(_next), w(_w) {}",
            "} e[M];",
            "int head[N], cnt_edge;",
            "void addEdge(int x, int y, int w = 1) {",
            "\te[++cnt_edge] = Edge(w, y, head[x]);",
            "\thead[x] = cnt_edge;",
            "}",
            "\n#define _for_graph(head, e, i, now) for (int i = head[now], to = e[i].to; ~i; to = e[i = e[i].next].to)",
            "\nint n, m;",
            "int vis[N];",
            "int64_t h[N], dis[N];",
            "bool f[N];",
            "\nbool bellman_ford(int s) {",
            "\tqueue<int> q;",
            "\tmemset(h, 0x3f, sizeof(h[0]) * (n + 1));",
            "\th[s] = 0;",
            "\tf[s] = true;",
            "\tq.push(s);",
            "\twhile (!q.empty()) {",
            "\t\tint now = q.front();",
            "\t\tq.pop();",
            "\t\tf[now] = 0;",
            "\t\t_for_graph(head, e, i, now)",
            "\t\t\tif (h[to] > h[now] + e[i].w) {",
            "\t\t\t\th[to] = h[now] + e[i].w;",
            "\t\t\t\tif (f[to]) continue;",
            "\t\t\t\tif (++vis[to] > n) return false;",
            "\t\t\t\tf[to] = true;",
            "\t\t\t\tq.push(to);",
            "\t\t\t}",
            "\t}",
            "\treturn true;",
            "}",
            "\nvoid dijkstra(int s) {",
            "\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;",
            "\tmemset(dis, 0x3f, sizeof(dis[0]) * (n + 1));",
            "\tmemset(f, 0, sizeof(f[0]) * (n + 1));",
            "\tq.emplace(0, s);",
            "\tdis[s] = 0;",
            "\twhile (!q.empty()) {",
            "\t\tint now = q.top().second;",
            "\t\tq.pop();",
            "\t\tif (f[now]) continue;",
            "\t\tf[now] = 1;",
            "\t\t_for_graph(head, e, i, now)",
            "\t\t\tif (dis[to] > dis[now] + e[i].w) {",
            "\t\t\t\tdis[to] = dis[now] + e[i].w;",
            "\t\t\t\tif (!f[to]) q.emplace(dis[to], to);",
            "\t\t\t}",
            "\t}",
            "}",
            "\nint64_t ans[N][N];",
            "\n//! Must initialize only in once.",
            "// return true if no negetive cycle",
            "inline bool init(int vertex_num, int edge_num, const tuple<int, int, int> *arcs) {",
            "\tn = vertex_num;",
            "\tm = edge_num;",
            "\tmemset(head, 0xff, sizeof(head[0]) * (n + 1));",
            "\t_for(i, 1, m) addEdge(get<0>(arcs[i]), get<1>(arcs[i]), get<2>(arcs[i]));",
            "\t_for(i, 1, n) addEdge(0, i, 0);",
            "\tif (!bellman_ford(0)) return false;",
            "\t_for(u, 1, n)",
            "\t\t_for_graph(head, e, i, u) e[i].w += h[u] - h[to];",
            "\t_for(i, 1, n) {",
            "\t\tdijkstra(i);",
            "\t\t_for(j, 1, n) ans[i][j] = ((dis[j] == INF) ? INF : (dis[j] + h[j] - h[i]));",
            "\t}",
            "\treturn true;",
            "}",
            "inline bool is_disconnected(int x, int y) { return ans[x][y] == INF; }",
            "inline int64_t distance(int x, int y) { return ans[x][y]; }",
            "}"
        ]
    },
    "tarjan-scc": {
        "scope": "cpp",
        "prefix": ["scc", "tarjan-scc"],
        "body": [
            "int dfn[N], low[N], cnt_dfn;",
            "stack<int> stk;",
            "bool in_stk[N];",
            "int scc_id[N], scc_size[N], cnt_scc;",
            "void tarjan(int now) {",
            "\tin_stk[now] = 1;",
            "\tdfn[now] = low[now] = ++cnt_dfn;",
            "\tstk.push(now);",
            "\t_for_graph(head, e, i, now) if (!dfn[to]) {",
            "\t\ttarjan(to);",
            "\t\tchkmin(low[now], low[to]);",
            "\t}",
            "\telse if (in_stk[to]) chkmin(low[now], dfn[to]);",
            "\tif (dfn[now] == low[now]) {",
            "\t\t++cnt_scc;",
            "\t\twhile (stk.top() != now) {",
            "\t\t\t++scc_size[scc_id[stk.top()] = cnt_scc];",
            "\t\t\tin_stk[stk.top()] = 0;",
            "\t\t\tstk.pop();",
            "\t\t}",
            "\t\t++scc_size[scc_id[stk.top()] = cnt_scc];",
            "\t\tin_stk[stk.top()] = 0;",
            "\t\tstk.pop();",
            "\t}",
            "}"
        ]
    },
    "2-sat": {
        "scope": "cpp",
        "prefix": ["2_sat", "sat", "sat_2"],
        "body": [
            "namespace SAT_2 {",
            "struct Edge {",
            "\tint to, next;",
            "\tEdge(int _to = 0, int _next = 0):",
            "\t\tto(_to), next(_next) {}",
            "} e[M];",
            "int head[N], cnt_edge;",
            "void addEdge(int x, int y) {",
            "\te[++cnt_edge] = Edge(y, head[x]);",
            "\thead[x] = cnt_edge;",
            "}",
            "\n#define _for_graph(head, e, i, now) for (int i = head[now], to = e[i].to; i; to = e[i = e[i].next].to)",
            "\nint dfn[N], low[N], cnt_dfn;",
            "stack<int> stk;",
            "bool in_stk[N];",
            "int scc_id[N], cnt_scc;",
            "void tarjan(int now) {",
            "\tdfn[now] = low[now] = ++cnt_dfn;",
            "\tstk.push(now);",
            "\tin_stk[now] = 1;",
            "\t_for_graph(head, e, i, now)",
            "\t\tif (!dfn[to]) {",
            "\t\t\ttarjan(to);",
            "\t\t\tchkmin(low[now], low[to]);",
            "\t\t} else if (in_stk[to])",
            "\t\t\tchkmin(low[now], dfn[to]);",
            "\tif (dfn[now] == low[now]) {",
            "\t\t++cnt_scc;",
            "\t\twhile (stk.top() != now) {",
            "\t\t\tscc_id[stk.top()] = cnt_scc;",
            "\t\t\tin_stk[stk.top()] = 0;",
            "\t\t\tstk.pop();",
            "\t\t}",
            "\t\tscc_id[stk.top()] = cnt_scc;",
            "\t\tin_stk[stk.top()] = 0;",
            "\t\tstk.pop();",
            "\t}",
            "}",
            "\nint n;",
            "\n//! Must initialize only in once.",
            "// return true if the restricts is legel, otherwise illegel",
            "bool init(int _n, int m, const tuple<int, bool, int, bool> *restricts) {",
            "\tn = _n;",
            "\tfor (int i = 1; i <= m; ++i) {",
            "\t\tauto &[x, bit_x, y, bit_y] = restricts[i];",
            "\t\taddEdge(x + bit_x * n, y + !bit_y * n);",
            "\t\taddEdge(y + bit_y * n, x + !bit_x * n);",
            "\t}",
            "\tfor (int i = 1; i <= n * 2; ++i)",
            "\t\tif (!dfn[i]) tarjan(i);",
            "\tfor (int i = 1; i <= n; ++i)",
            "\t\tif (scc_id[i] == scc_id[i + n]) return false;",
            "\treturn true;",
            "}",
            "bool possible_value(int x) { return scc_id[x] < scc_id[x + n]; }",
            "}  // namespace SAT_2"
        ]
    },
    "euler-path-graph": {
        "scope": "cpp",
        "prefix": "euler_path_graph",
        "body": [
            "namespace Euler_path_graph {",
            "vector<int> graph[N];",
            "\nbool has_euler_cycle(int n, const int *deg) {",
            "\tfor (int i = 1; i <= n; ++i) if (deg[i] & 1) return false;",
            "\treturn true;",
            "}",
            "\nbool has_euler_path(int n, const int *deg) {",
            "\tint cnt = 0;",
            "\tfor (int i = 1; i <= n; ++i) {",
            "\t\tif (!(deg[i] & 1)) continue;",
            "\t\tif (++cnt > 2) return false;",
            "\t}",
            "\treturn cnt == 0 || cnt == 2;",
            "}",
            "\n// least on lexicographical order",
            "int epath[M];",
            "int epath_cnt;",
            "\nmap<pair<int, int>, int> cnt;",
            "void dfs(int now) {",
            "\tfor (int i = 0, to = graph[now][i]; i < graph[now].size(); to = graph[now][++i]) {",
            "\t\tif (!cnt[{now, to}]) continue;",
            "\t\t--cnt[{now, to}];",
            "\t\t--cnt[{to, now}];",
            "\t\tdfs(to);",
            "\t}",
            "\tepath[epath_cnt--] = now;",
            "}",
            "\n//! only for connected graph",
            "// return false if there is no Euler path",
            "bool euler_path(int n, int m, int start_default, pair<int, int> *edges, const int *deg) {",
            "\tif (!has_euler_path(n, deg)) return false;",
            "\tint start = start_default;",
            "\tfor (int i = 1; i <= n; ++i)",
            "\t\tif (deg[i] & 1) {",
            "\t\t\tstart = i;",
            "\t\t\tbreak;",
            "\t\t}",
            "\tfor (int i = 1; i <= n; ++i) graph[i].reserve(deg[i]);",
            "\tfor (int i = 1; i <= m; ++i) {",
            "\t\tgraph[edges[i].first].push_back(edges[i].second);",
            "\t\tgraph[edges[i].second].push_back(edges[i].first);",
            "\t\t++cnt[edges[i]];",
            "\t\t++cnt[{edges[i].second, edges[i].first}];",
            "\t}",
            "\tfor (int i = 1; i <= n; ++i) sort(graph[i].begin(), graph[i].end());",
            "\tepath_cnt = m + 1;",
            "\tdfs(start);",
            "\treturn true;",
            "}",
            "}  // namespace Euler_path_graph",
            "using Euler_path_graph::euler_path;"
        ]
    },
    "euler-path-digraph": {
        "scope": "cpp",
        "prefix": "euler_path_digraph",
        "body": [
            "namespace Euler_path_digraph {",
            "struct Edge {",
            "\tint to, next;",
            "\tEdge(int _to = 0, int _next = 0): to(_to), next(_next) {}",
            "} e[M];",
            "int head[N], cnt_edge;",
            "void addEdge(int x, int y) {",
            "\te[++cnt_edge] = Edge(y, head[x]);",
            "\thead[x] = cnt_edge;",
            "}",
            "\nbool has_euler_cycle(int n, const int *in_deg, const int *out_deg) {",
            "\tfor (int i = 1; i <= n; ++i) if (in_deg[i] != out_deg[i]) return false;",
            "\treturn true;",
            "}",
            "\nbool has_euler_path(int n, const int *in_deg, const int *out_deg) {",
            "\tbool _in = 0, _out = 0;",
            "\tfor (int i = 1; i <= n; ++i) {",
            "\t\tif (in_deg[i] == out_deg[i]) continue;",
            "\t\tif (_in && in_deg[i] > out_deg[i]) return false;",
            "\t\tif (_out && out_deg[i] > in_deg[i]) return false;",
            "\t\tif (in_deg[i] == out_deg[i] + 1)",
            "\t\t\t_in = true;",
            "\t\telse if (out_deg[i] == in_deg[i] + 1)",
            "\t\t\t_out = true;",
            "\t\telse",
            "\t\t\treturn false;",
            "\t}",
            "\treturn !(_in ^ _out);",
            "}",
            "\n// least on lexicographical order",
            "int epath[M];",
            "int epath_cnt;",
            "\nvoid dfs(int now) {",
            "\tfor (int i = head[now], to = e[i].to; i; to = e[i = head[now]].to) {",
            "\t\thead[now] = e[i].next;",
            "\t\tdfs(to);",
            "\t}",
            "\tepath[epath_cnt--] = now;",
            "}",
            "\n//! only for connected digraph",
            "// return false if there is no Euler path",
            "bool euler_path(int n, int m, int start_default, pair<int, int> *arcs, const int *in_deg, const int *out_deg) {",
            "\tif (!has_euler_path(n, in_deg, out_deg)) return false;",
            "\tint start = start_default;",
            "\tfor (int i = 1; i <= n; ++i)",
            "\t\tif (in_deg[i] + 1 == out_deg[i]) {",
            "\t\t\tstart = i;",
            "\t\t\tbreak;",
            "\t\t}",
            "\tsort(arcs + 1, arcs + m + 1, [](const pair<int, int> &lhs, const pair<int, int> &rhs) -> bool { return lhs.first == rhs.first ? lhs.second > rhs.second : lhs.first < rhs.first; });",
            "\tfor (int i = 1; i <= m; ++i) addEdge(arcs[i].first, arcs[i].second);",
            "\tepath_cnt = m + 1;",
            "\tdfs(start);",
            "\treturn true;",
            "}",
            "}  // namespace Euler_path_digraph",
            "using Euler_path_digraph::euler_path;"
        ]
    }
}

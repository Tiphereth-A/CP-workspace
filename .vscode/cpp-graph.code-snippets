{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "2-sat": {
        "scope": "cpp",
        "prefix": [
            "2-sat",
            "sat",
            "sat-2"
        ],
        "body": [
            "namespace SAT_2 {",
            "\nint n;",
            "\n//! Must initialize only in once.",
            "// return true if the restricts is legel, otherwise illegel",
            "bool init(int _n, int m, const tuple<int, bool, int, bool> *restricts) {",
            "n = _n;",
            "for (int i = 1; i <= m; ++i) {",
            "auto &[x, bit_x, y, bit_y] = restricts[i];",
            "addEdge(x + bit_x * n, y + !bit_y * n);",
            "addEdge(y + bit_y * n, x + !bit_x * n);",
            "}",
            "for (int i = 1; i <= n * 2; ++i)",
            "if (!dfn[i]) tarjan(i);",
            "for (int i = 1; i <= n; ++i)",
            "if (scc_id[i] == scc_id[i + n]) return false;",
            "return true;",
            "}",
            "bool possible_value(int x) { return scc_id[x] < scc_id[x + n]; }",
            "}  // namespace SAT_2"
        ]
    },
    "bellman-ford": {
        "scope": "cpp",
        "prefix": [
            "bellman-ford",
            "spfa",
            "bford"
        ],
        "body": [
            "int dis[N], dep[N];",
            "bool vis[N];",
            "bool bellman_ford(int n, int s) {",
            "memset(dis, 0x3f, sizeof(dis[0]) * (n + 1));",
            "dis[s] = 0;",
            "vis[s] = true;",
            "dep[s] = 1;",
            "queue<int> q;",
            "q.push(s);",
            "while (!q.empty()) {",
            "int now = q.front();",
            "q.pop();",
            "vis[now] = false;",
            "for_graph_(head, e, i, now) if (dis[to] > dis[now] + e[i].w) {",
            "dis[to] = dis[now] + e[i].w;",
            "if (vis[to]) continue;",
            "if (++dep[to] > n) return false;",
            "vis[to] = true;",
            "q.push(to);",
            "}",
            "}",
            "return true;",
            "}"
        ]
    },
    "bipartitle-graph-coloring": {
        "scope": "cpp",
        "prefix": [
            "bipartitle-graph-coloring"
        ],
        "body": [
            "namespace BipartiteGraphColoring {",
            "std::vector<int> c__;",
            "template <class Tp>",
            "bool dfs__(std::vector<std::vector<Tp>> const &g, size_t now, size_t fa, int nowc = 1) {",
            "c__[now] = nowc;",
            "for (auto &&to : g[now]) {",
            "if (to == fa) continue;",
            "if (c__[to] && !((c__[to] ^ nowc) & 1)) return false;",
            "if (!c__[to] && !dfs__(g, to, now, 3 - nowc)) return false;",
            "}",
            "return true;",
            "}",
            "// Bipartitle graph coloring",
            "// @return std::nullopt if graph has non-bipartite component, else a coloring method (0,2 -> even, 1 -> odd)",
            "template <class Tp>",
            "std::optional<std::vector<int>> bpgclr(std::vector<std::vector<Tp>> const &g) {",
            "c__.clear();",
            "c__.resize(g.size());",
            "for (size_t i = 0; i < g.size(); ++i)",
            "if (g[i].size() && !c__[i])",
            "if (!dfs__(g, i, g.size())) return std::nullopt;",
            "return c__;",
            "}",
            "}  // namespace BipartiteGraphColoring",
            "using BipartiteGraphColoring::bpgclr;"
        ]
    },
    "euler-path-graph": {
        "scope": "cpp",
        "prefix": "euler-path-graph",
        "body": [
            "namespace Euler_path_graph {",
            "vector<int> graph[N];",
            "\nbool has_euler_cycle(int n, const int *deg) {",
            "for (int i = 1; i <= n; ++i) if (deg[i] & 1) return false;",
            "return true;",
            "}",
            "\nbool has_euler_path(int n, const int *deg) {",
            "int cnt = 0;",
            "for (int i = 1; i <= n; ++i) {",
            "if (!(deg[i] & 1)) continue;",
            "if (++cnt > 2) return false;",
            "}",
            "return cnt == 0 || cnt == 2;",
            "}",
            "\n// least on lexicographical order",
            "int epath[M];",
            "int epath_cnt;",
            "\nmap<pair<int, int>, int> cnt;",
            "void dfs(int now) {",
            "for (int i = 0, to = graph[now][i]; i < graph[now].size(); to = graph[now][++i]) {",
            "if (!cnt[{now, to}]) continue;",
            "--cnt[{now, to}];",
            "--cnt[{to, now}];",
            "dfs(to);",
            "}",
            "epath[epath_cnt--] = now;",
            "}",
            "\n//! only for connected graph",
            "// return false if there is no Euler path",
            "bool euler_path(int n, int m, int start_default, pair<int, int> *edges, const int *deg) {",
            "if (!has_euler_path(n, deg)) return false;",
            "int start = start_default;",
            "for (int i = 1; i <= n; ++i)",
            "if (deg[i] & 1) {",
            "start = i;",
            "break;",
            "}",
            "for (int i = 1; i <= n; ++i) graph[i].reserve(deg[i]);",
            "for (int i = 1; i <= m; ++i) {",
            "graph[edges[i].first].push_back(edges[i].second);",
            "graph[edges[i].second].push_back(edges[i].first);",
            "++cnt[edges[i]];",
            "++cnt[{edges[i].second, edges[i].first}];",
            "}",
            "for (int i = 1; i <= n; ++i) sort(graph[i].begin(), graph[i].end());",
            "epath_cnt = m + 1;",
            "dfs(start);",
            "return true;",
            "}",
            "}  // namespace Euler_path_graph",
            "using Euler_path_graph::euler_path;"
        ]
    },
    "euler-path-digraph": {
        "scope": "cpp",
        "prefix": "euler-path-digraph",
        "body": [
            "namespace Euler_path_digraph {",
            "\nbool has_euler_cycle(int n, const int *in_deg, const int *out_deg) {",
            "for (int i = 1; i <= n; ++i) if (in_deg[i] != out_deg[i]) return false;",
            "return true;",
            "}",
            "\nbool has_euler_path(int n, const int *in_deg, const int *out_deg) {",
            "bool _in = 0, _out = 0;",
            "for (int i = 1; i <= n; ++i) {",
            "if (in_deg[i] == out_deg[i]) continue;",
            "if (_in && in_deg[i] > out_deg[i]) return false;",
            "if (_out && out_deg[i] > in_deg[i]) return false;",
            "if (in_deg[i] == out_deg[i] + 1)",
            "_in = true;",
            "else if (out_deg[i] == in_deg[i] + 1)",
            "_out = true;",
            "else",
            "return false;",
            "}",
            "return !(_in ^ _out);",
            "}",
            "\n// least on lexicographical order",
            "int epath[M];",
            "int epath_cnt;",
            "\nvoid dfs(int now) {",
            "for (int i = head[now], to = e[i].to; i; to = e[i = head[now]].to) {",
            "head[now] = e[i].next;",
            "dfs(to);",
            "}",
            "epath[epath_cnt--] = now;",
            "}",
            "\n//! only for connected digraph",
            "// return false if there is no Euler path",
            "bool euler_path(int n, int m, int start_default, pair<int, int> *arcs, const int *in_deg, const int *out_deg) {",
            "if (!has_euler_path(n, in_deg, out_deg)) return false;",
            "int start = start_default;",
            "for (int i = 1; i <= n; ++i)",
            "if (in_deg[i] + 1 == out_deg[i]) {",
            "start = i;",
            "break;",
            "}",
            "sort(arcs + 1, arcs + m + 1, [](const pair<int, int> &lhs, const pair<int, int> &rhs) -> bool { return lhs.first == rhs.first ? lhs.second > rhs.second : lhs.first < rhs.first; });",
            "for (int i = 1; i <= m; ++i) addEdge(arcs[i].first, arcs[i].second);",
            "epath_cnt = m + 1;",
            "dfs(start);",
            "return true;",
            "}",
            "}  // namespace Euler_path_digraph",
            "using Euler_path_digraph::euler_path;"
        ]
    },
    "floyd": {
        "scope": "cpp",
        "prefix": "floyd",
        "body": [
            "template <class Tp>",
            "class FloydSolver {",
            "protected:",
            "std::vector<std::vector<Tp>> spath;",
            "constexpr static Tp INF = std::numeric_limits<Tp>::max() / 4;",
            "public:",
            "using self = FloydSolver<Tp>;",
            "explicit FloydSolver(size_t _n): spath(_n, std::vector<Tp>(_n, INF)) {",
            "assert(_n > 0);",
            "for (size_t i = 0; i < _n; ++i) spath[i][i] = 0;",
            "}",
            "self &addedge(size_t from, size_t to, Tp const &w = Tp{1}) {",
            "spath[from][to] = w;",
            "return *this;",
            "}",
            "self &run(size_t bgn, size_t end) {",
            "assert(bgn < end && end <= spath.size());",
            "for (size_t k = bgn; k < end; ++k)",
            "for (size_t i = bgn; i < end; ++i)",
            "for (size_t j = bgn; j < end; ++j)",
            "if (spath[i][k] + spath[k][j] < spath[i][j]) spath[i][j] = spath[i][k] + spath[k][j];",
            "return *this;",
            "}",
            "Tp const &query(size_t from, size_t to) const { return spath[from][to]; }",
            "bool reachable(size_t from, size_t to) const { return query(from, to) != INF; }",
            "};",
        ]
    },
    "graph": {
        "scope": "cpp",
        "prefix": [
            "graph",
            "edges"
        ],
        "body": [
            "struct Edge {",
            "int w, to, next;",
            "Edge(int _w = 0, int _to = 0, int _next = 0) : w(_w), to(_to), next(_next) {}",
            "} e[M];",
            "int head[N], cnt_edge;",
            "int in[N], out[N];",
            "void addEdge(int x, int y, int w = 1) {",
            "e[++cnt_edge] = Edge(w, y, head[x]);",
            "head[x] = cnt_edge;",
            "++in[y];",
            "++out[x];",
            "}",
            "\n#define for_graph_(head, e, i, now) for (int i = head[now], to = e[i].to; i; to = e[i = e[i].next].to)"
        ]
    },
    "johnson": {
        "scope": "cpp",
        "prefix": "johnson",
        "body": [
            "namespace Johnson_shortest_path {",
            "const int64_t INF = 0x3f3f3f3f3f3f3f3f;",
            "\nstruct Edge {",
            "int to, next;",
            "int64_t w;",
            "Edge(int64_t _w = 0, int _to = 0, int _next = -1):",
            "to(_to), next(_next), w(_w) {}",
            "} e[M];",
            "int head[N], cnt_edge;",
            "void addEdge(int x, int y, int w = 1) {",
            "e[++cnt_edge] = Edge(w, y, head[x]);",
            "head[x] = cnt_edge;",
            "}",
            "\n#define for_graph_(head, e, i, now) for (int i = head[now], to = e[i].to; ~i; to = e[i = e[i].next].to)",
            "\nint n, m;",
            "int vis[N];",
            "int64_t h[N], dis[N];",
            "bool f[N];",
            "\nbool bellman_ford(int s) {",
            "queue<int> q;",
            "memset(h, 0x3f, sizeof(h[0]) * (n + 1));",
            "h[s] = 0;",
            "f[s] = true;",
            "q.push(s);",
            "while (!q.empty()) {",
            "int now = q.front();",
            "q.pop();",
            "f[now] = 0;",
            "for_graph_(head, e, i, now)",
            "if (h[to] > h[now] + e[i].w) {",
            "h[to] = h[now] + e[i].w;",
            "if (f[to]) continue;",
            "if (++vis[to] > n) return false;",
            "f[to] = true;",
            "q.push(to);",
            "}",
            "}",
            "return true;",
            "}",
            "\nvoid dijkstra(int s) {",
            "priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;",
            "memset(dis, 0x3f, sizeof(dis[0]) * (n + 1));",
            "memset(f, 0, sizeof(f[0]) * (n + 1));",
            "q.emplace(0, s);",
            "dis[s] = 0;",
            "while (!q.empty()) {",
            "int now = q.top().second;",
            "q.pop();",
            "if (f[now]) continue;",
            "f[now] = 1;",
            "for_graph_(head, e, i, now)",
            "if (dis[to] > dis[now] + e[i].w) {",
            "dis[to] = dis[now] + e[i].w;",
            "if (!f[to]) q.emplace(dis[to], to);",
            "}",
            "}",
            "}",
            "\nint64_t ans[N][N];",
            "\n//! Must initialize only in once.",
            "// return true if no negetive cycle",
            "bool init(int vertex_num, int edge_num, const tuple<int, int, int> *arcs) {",
            "n = vertex_num;",
            "m = edge_num;",
            "memset(head, 0xff, sizeof(head[0]) * (n + 1));",
            "for_(i, 1, m) addEdge(get<0>(arcs[i]), get<1>(arcs[i]), get<2>(arcs[i]));",
            "for_(i, 1, n) addEdge(0, i, 0);",
            "if (!bellman_ford(0)) return false;",
            "for_(u, 1, n)",
            "for_graph_(head, e, i, u) e[i].w += h[u] - h[to];",
            "for_(i, 1, n) {",
            "dijkstra(i);",
            "for_(j, 1, n) ans[i][j] = ((dis[j] == INF) ? INF : (dis[j] + h[j] - h[i]));",
            "}",
            "return true;",
            "}",
            "bool is_disconnected(int x, int y) { return ans[x][y] == INF; }",
            "int64_t distance(int x, int y) { return ans[x][y]; }",
            "}"
        ]
    },
    "kruakal": {
        "scope": "cpp",
        "prefix": "kruskal",
        "body": [
            "template <class WeightTp>",
            "class KruskalSolver {",
            "using Tp = WeightTp;",
            "using edge_t = std::tuple<Tp, size_t, size_t>;",
            "protected:",
            "std::vector<edge_t> edges;",
            "size_t vertex_size;",
            "public:",
            "using self = KruskalSolver<Tp>;",
            "explicit KruskalSolver(size_t _n): edges(), vertex_size(_n) { assert(_n > 0); }",
            "self &addedge(size_t from, size_t to, Tp const &w = Tp{1}) {",
            "edges.emplace_back(w, from, to);",
            "return *this;",
            "}",
            "std::vector<edge_t> &data() { return edges; }",
            "self &run() {",
            "std::sort(edges.begin(), edges.end());",
            "decltype(edges) mst_edges;",
            "DsuBasic dsu(vertex_size);",
            "for (auto &&[w, from, to] : edges)",
            "if (dsu.merge(from, to)) mst_edges.emplace_back(w, from, to);",
            "edges = mst_edges;",
            "return *this;",
            "}",
            "};"
        ]
    },
    "tarjan-scc": {
        "scope": "cpp",
        "prefix": [
            "scc",
            "tarjan-scc"
        ],
        "body": [
            "int dfn[N], low[N], cnt_dfn;",
            "stack<int> stk;",
            "bool in_stk[N];",
            "int scc_id[N], scc_size[N], cnt_scc;",
            "void tarjan(int now) {",
            "in_stk[now] = 1;",
            "dfn[now] = low[now] = ++cnt_dfn;",
            "stk.push(now);",
            "for_graph_(head, e, i, now) if (!dfn[to]) {",
            "tarjan(to);",
            "low[now] = min(low[now], low[to]);",
            "}",
            "else if (in_stk[to]) low[now] = min(low[now], dfn[to]);",
            "if (dfn[now] == low[now]) {",
            "++cnt_scc;",
            "while (stk.top() != now) {",
            "++scc_size[scc_id[stk.top()] = cnt_scc];",
            "in_stk[stk.top()] = 0;",
            "stk.pop();",
            "}",
            "++scc_size[scc_id[stk.top()] = cnt_scc];",
            "in_stk[stk.top()] = 0;",
            "stk.pop();",
            "}",
            "}"
        ]
    },
    "tree-centroid": {
        "scope": "cpp",
        "prefix": [
            "centroid",
            "tcent",
            "tree-centroid"
        ],
        "body": [
            "// @param g graph",
            "// @param size_ size_[i]: size of each subtree rooted in i",
            "// @param ans all the centroids, `ans.size() <= 2`, must give an empty vector when calling",
            "// @param now root",
            "// @param fa fathor of `now`, keep same to `now` when calling this",
            "//! vertex ID start from 0",
            "template <class Tp>",
            "void tree_centroid(std::vector<std::vector<Tp>> const &g, std::vector<size_t> &size_, std::vector<size_t> &ans, size_t now = 0, size_t fa = 0) {",
            "size_[now] = 1;",
            "size_t max_sz = 0;",
            "for (auto to : g[now])",
            "if (to != fa) {",
            "tree_centroid(g, size_, ans, to, now);",
            "size_[now] += size_[to];",
            "max_sz = max(max_sz, size_[to]);",
            "}",
            "if ((max_sz = max(max_sz, g.size() - size_[now])) <= g.size() / 2) ans.push_back(now);",
            "}"
        ]
    },
    "tree-hash-rooted": {
        "scope": "cpp",
        "prefix": [
            "rooted-tree-hash",
            "tree-hash-rooted"
        ],
        "body": [
            "// @param g graph",
            "// @param now root",
            "// @param fa fathor of `now`, keep same to `now` when calling this",
            "//! vertex ID start from 0",
            "template <class Tp>",
            "uint64_t rooted_tree_hash(std::vector<std::vector<Tp>> const &g, size_t now = 0, size_t fa = 0) {",
            "auto f = [](uint64_t x) {",
            "x += 0x9e3779b97f4a7c15;",
            "x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "return x ^ (x >> 31);",
            "};",
            "uint64_t ans = 1;",
            "for (auto to : g[now])",
            "if (to != fa) ans += f(rooted_tree_hash(g, to, now));",
            "return ans;",
            "}"
        ]
    },
    "tree-hash-unrooted": {
        "scope": "cpp",
        "prefix": [
            "unrooted-tree-hash",
            "tree-hash-unrooted"
        ],
        "body": [
            "// @param g graph",
            "//! vertex ID start from 0",
            "template <class Tp>",
            "uint64_t unrooted_tree_hash(std::vector<std::vector<Tp>> const &g) {",
            "std::vector<size_t> sz(g.size()), c;",
            "tree_centroid(g, sz, c);",
            "uint64_t ans = 0;",
            "for (auto root : c) ans += rooted_tree_hash(g, root, root);",
            "return ans;",
            "}"
        ]
    }
}
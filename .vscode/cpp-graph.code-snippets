{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "2-sat": {
        "scope": "cpp",
        "prefix": [
            "2-sat",
            "sat",
            "sat-2"
        ],
        "body": [
            "namespace SAT_2 {",
            "\nint n;",
            "\n//! Must initialize only in once.",
            "// return true if the restricts is legel, otherwise illegel",
            "bool init(int _n, int m, const tuple<int, bool, int, bool> *restricts) {",
            "n = _n;",
            "for (int i = 1; i <= m; ++i) {",
            "auto &[x, bit_x, y, bit_y] = restricts[i];",
            "addEdge(x + bit_x * n, y + !bit_y * n);",
            "addEdge(y + bit_y * n, x + !bit_x * n);",
            "}",
            "for (int i = 1; i <= n * 2; ++i)",
            "if (!dfn[i]) tarjan(i);",
            "for (int i = 1; i <= n; ++i)",
            "if (scc_id[i] == scc_id[i + n]) return false;",
            "return true;",
            "}",
            "bool possible_value(int x) { return scc_id[x] < scc_id[x + n]; }",
            "}  // namespace SAT_2"
        ]
    },
    "bipartitle-graph-coloring": {
        "scope": "cpp",
        "prefix": [
            "bipartitle-graph-coloring"
        ],
        "body": [
            "namespace BipartiteGraphColoring {",
            "std::vector<int> c__;",
            "template <class Tp>",
            "bool dfs__(std::vector<std::vector<Tp>> const &g, size_t now, size_t fa, int nowc = 1) {",
            "c__[now] = nowc;",
            "for (auto &&to : g[now]) {",
            "if (to == fa) continue;",
            "if (c__[to] && !((c__[to] ^ nowc) & 1)) return false;",
            "if (!c__[to] && !dfs__(g, to, now, 3 - nowc)) return false;",
            "}",
            "return true;",
            "}",
            "// Bipartitle graph coloring",
            "// @return std::nullopt if graph has non-bipartite component, else a coloring method (0,2 -> even, 1 -> odd)",
            "template <class Tp>",
            "std::optional<std::vector<int>> bpgclr(std::vector<std::vector<Tp>> const &g) {",
            "c__.clear();",
            "c__.resize(g.size());",
            "for (size_t i = 0; i < g.size(); ++i)",
            "if (g[i].size() && !c__[i])",
            "if (!dfs__(g, i, g.size())) return std::nullopt;",
            "return c__;",
            "}",
            "}  // namespace BipartiteGraphColoring",
            "using BipartiteGraphColoring::bpgclr;"
        ]
    },
    "johnson": {
        "scope": "cpp",
        "prefix": "johnson",
        "body": [
            "namespace Johnson_shortest_path {",
            "const int64_t INF = 0x3f3f3f3f3f3f3f3f;",
            "\nstruct Edge {",
            "int to, next;",
            "int64_t w;",
            "Edge(int64_t _w = 0, int _to = 0, int _next = -1):",
            "to(_to), next(_next), w(_w) {}",
            "} e[M];",
            "int head[N], cnt_edge;",
            "void addEdge(int x, int y, int w = 1) {",
            "e[++cnt_edge] = Edge(w, y, head[x]);",
            "head[x] = cnt_edge;",
            "}",
            "\n#define for_graph_(head, e, i, now) for (int i = head[now], to = e[i].to; ~i; to = e[i = e[i].next].to)",
            "\nint n, m;",
            "int vis[N];",
            "int64_t h[N], dis[N];",
            "bool f[N];",
            "\nbool bellman_ford(int s) {",
            "queue<int> q;",
            "memset(h, 0x3f, sizeof(h[0]) * (n + 1));",
            "h[s] = 0;",
            "f[s] = true;",
            "q.push(s);",
            "while (!q.empty()) {",
            "int now = q.front();",
            "q.pop();",
            "f[now] = 0;",
            "for_graph_(head, e, i, now)",
            "if (h[to] > h[now] + e[i].w) {",
            "h[to] = h[now] + e[i].w;",
            "if (f[to]) continue;",
            "if (++vis[to] > n) return false;",
            "f[to] = true;",
            "q.push(to);",
            "}",
            "}",
            "return true;",
            "}",
            "\nvoid dijkstra(int s) {",
            "priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;",
            "memset(dis, 0x3f, sizeof(dis[0]) * (n + 1));",
            "memset(f, 0, sizeof(f[0]) * (n + 1));",
            "q.emplace(0, s);",
            "dis[s] = 0;",
            "while (!q.empty()) {",
            "int now = q.top().second;",
            "q.pop();",
            "if (f[now]) continue;",
            "f[now] = 1;",
            "for_graph_(head, e, i, now)",
            "if (dis[to] > dis[now] + e[i].w) {",
            "dis[to] = dis[now] + e[i].w;",
            "if (!f[to]) q.emplace(dis[to], to);",
            "}",
            "}",
            "}",
            "\nint64_t ans[N][N];",
            "\n//! Must initialize only in once.",
            "// return true if no negetive cycle",
            "bool init(int vertex_num, int edge_num, const tuple<int, int, int> *arcs) {",
            "n = vertex_num;",
            "m = edge_num;",
            "memset(head, 0xff, sizeof(head[0]) * (n + 1));",
            "for_(i, 1, m) addEdge(get<0>(arcs[i]), get<1>(arcs[i]), get<2>(arcs[i]));",
            "for_(i, 1, n) addEdge(0, i, 0);",
            "if (!bellman_ford(0)) return false;",
            "for_(u, 1, n)",
            "for_graph_(head, e, i, u) e[i].w += h[u] - h[to];",
            "for_(i, 1, n) {",
            "dijkstra(i);",
            "for_(j, 1, n) ans[i][j] = ((dis[j] == INF) ? INF : (dis[j] + h[j] - h[i]));",
            "}",
            "return true;",
            "}",
            "bool is_disconnected(int x, int y) { return ans[x][y] == INF; }",
            "int64_t distance(int x, int y) { return ans[x][y]; }",
            "}"
        ]
    }
}
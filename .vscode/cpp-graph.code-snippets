{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "2-sat": {
        "scope": "cpp",
        "prefix": [
            "2-sat",
            "sat",
            "sat-2"
        ],
        "body": [
            "namespace SAT_2 {",
            "\nint n;",
            "\n//! Must initialize only in once.",
            "// return true if the restricts is legel, otherwise illegel",
            "bool init(int _n, int m, const tuple<int, bool, int, bool> *restricts) {",
            "n = _n;",
            "for (int i = 1; i <= m; ++i) {",
            "auto &[x, bit_x, y, bit_y] = restricts[i];",
            "addEdge(x + bit_x * n, y + !bit_y * n);",
            "addEdge(y + bit_y * n, x + !bit_x * n);",
            "}",
            "for (int i = 1; i <= n * 2; ++i)",
            "if (!dfn[i]) tarjan(i);",
            "for (int i = 1; i <= n; ++i)",
            "if (scc_id[i] == scc_id[i + n]) return false;",
            "return true;",
            "}",
            "bool possible_value(int x) { return scc_id[x] < scc_id[x + n]; }",
            "}  // namespace SAT_2"
        ]
    },
    "bipartitle-graph-coloring": {
        "scope": "cpp",
        "prefix": [
            "bipartitle-graph-coloring"
        ],
        "body": [
            "namespace BipartiteGraphColoring {",
            "std::vector<int> c__;",
            "template <class Tp>",
            "bool dfs__(std::vector<std::vector<Tp>> const &g, size_t now, size_t fa, int nowc = 1) {",
            "c__[now] = nowc;",
            "for (auto &&to : g[now]) {",
            "if (to == fa) continue;",
            "if (c__[to] && !((c__[to] ^ nowc) & 1)) return false;",
            "if (!c__[to] && !dfs__(g, to, now, 3 - nowc)) return false;",
            "}",
            "return true;",
            "}",
            "// Bipartitle graph coloring",
            "// @return std::nullopt if graph has non-bipartite component, else a coloring method (0,2 -> even, 1 -> odd)",
            "template <class Tp>",
            "std::optional<std::vector<int>> bpgclr(std::vector<std::vector<Tp>> const &g) {",
            "c__.clear();",
            "c__.resize(g.size());",
            "for (size_t i = 0; i < g.size(); ++i)",
            "if (g[i].size() && !c__[i])",
            "if (!dfs__(g, i, g.size())) return std::nullopt;",
            "return c__;",
            "}",
            "}  // namespace BipartiteGraphColoring",
            "using BipartiteGraphColoring::bpgclr;"
        ]
    }
}
{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "barrett": {
        "scope": "cpp",
        "prefix": "barrett",
        "body": [
            "// Reference: https://en.wikipedia.org/wiki/Barrett_reduction",
            "struct Barrett {",
            "uint32_t _m;",
            "uint64_t im;",
            "\n// @param m `1 <= m < 2^31`",
            "constexpr explicit Barrett(uint32_t m): _m(m), im((uint64_t)(-1) / m + 1) {}",
            "\n// @return m",
            "constexpr uint32_t umod() const { return _m; }",
            "\n// @param a `0 <= a < m`",
            "// @param b `0 <= b < m`",
            "// @return `a * b % m`",
            "constexpr uint32_t mul(uint32_t a, uint32_t b) const {",
            "uint64_t z = (uint64_t)(a) * b;",
            "uint32_t v = (uint32_t)(z - (uint64_t)(((u128)(z)*im) >> 64) * _m);",
            "return v + (_m <= v ? _m : 0);",
            "}",
            "};"
        ],
        "description": "Fast modular multiplication by barrett reduction"
    },
    "convolution-fft": {
        "scope": "cpp",
        "prefix": [
            "conv",
            "convolution",
            "convolution-fft",
            "fft-double"
        ],
        "body": [
            "namespace FFT {",
            "using CP = std::complex<double>;",
            "const double PI = acos(-1.0);",
            "size_t n = 0;",
            "std::vector<size_t> rev;",
            "void init(size_t m) {",
            "if (n > m) return;",
            "n = 1;",
            "int k = 0;",
            "while (n <= m) {",
            "n <<= 1;",
            "++k;",
            "}",
            "rev.resize(n);",
            "for (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (k - 1));",
            "}",
            "void dft(std::vector<CP> &a, int op) {",
            "for (int i = 0; i < n; ++i)",
            "if (rev[i] > i) std::swap(a[rev[i]], a[i]);",
            "for (int i = 1; i < n; i <<= 1) {",
            "CP now(std::cos(PI / i), op * std::sin(PI / i));",
            "for (int j = 0, p = (i << 1); j < n; j += p) {",
            "CP w(1, 0);",
            "for (int k = 0; k < i; ++k, w = w * now) {",
            "CP x = a[j + k], y = a[j + k + i] * w;",
            "a[j + k] = x + y;",
            "a[j + k + i] = x - y;",
            "}",
            "}",
            "}",
            "if (op == -1)",
            "for (int i = 0; i < n; ++i) a[i] = {a[i].real() / n, a[i].imag() / n};",
            "}",
            "std::vector<double> conv(std::vector<double> const &a, std::vector<double> const &b) {",
            "init(a.size() + b.size() - 1);",
            "std::vector<CP> a_(n), b_(n), c_(n);",
            "for (size_t i = 0; i < a.size(); ++i) a_[i] = a[i];",
            "for (size_t i = 0; i < b.size(); ++i) b_[i] = b[i];",
            "dft(a_, 1);",
            "dft(b_, 1);",
            "for (size_t i = 0; i < n; ++i) c_[i] = a_[i] * b_[i];",
            "dft(c_, -1);",
            "std::vector<double> c(a.size() + b.size() - 1);",
            "for (size_t i = 0; i < a.size() + b.size() - 1; ++i) c[i] = c_[i].real();",
            "return c;",
            "}",
            "}  // namespace FFT",
            "using FFT::conv;"
        ]
    },
    "exeuclid": {
        "scope": "cpp",
        "prefix": [
            "exeuclid"
        ],
        "body": [
            "namespace exEuclid {",
            "template <class Node>",
            "constexpr Node qpow_(Node a, int64_t b) {",
            "Node res;",
            "for (; b; b >>= 1, a = a + a)",
            "if (b & 1) res = res + a;",
            "return res;",
            "}",
            "template <class Node>",
            "Node solve_(int64_t p, int64_t q, int64_t r, int64_t l, Node a, Node b) {",
            "#pragma GCC diagnostic push",
            "#pragma GCC diagnostic ignored \"-Wfloat-conversion\"",
            "auto div = [](int64_t a, int64_t b, int64_t c, int64_t d) -> int64_t { return (1.l * a * b + c) / d; };",
            "#pragma GCC diagnostic pop",
            "if (!l) return Node();",
            "if (p >= q) return solve_(p % q, q, r, l, a, qpow_(a, p / q) + b);",
            "int64_t m = div(l, p, r, q);",
            "if (!m) return qpow_(b, l);",
            "int64_t cnt = l - div(q, m, -r - 1, p);",
            "return qpow_(b, (q - r - 1) / p) + a + solve_(q, p, (q - r - 1) % p, m - 1, b, a) + qpow_(b, cnt);",
            "}",
            "//! USE THIS",
            "// consider line s: y = (p * x + r) / q, 0 < x <= l",
            "// result will add a when s cross with horizontal line",
            "// result will add b when s cross with vertical line",
            "template <class Node>",
            "constexpr Node solve(int64_t p, int64_t q, int64_t r, int64_t l, Node const &a, Node const &b) { return qpow_(a, r / q) + solve_(p, q, r % q, l, a, b); }",
            "//! USE THIS",
            "// let f(x) = floor((p * x + r) / q)",
            "// @param u (DO NOT EDIT) count of horizontal lines have been crossed",
            "// @param r (DO NOT EDIT) count of vertical lines have been crossed",
            "// @param i sum_i i (needed by i_f)",
            "// @param f sum_i i f(i)",
            "// @param sqr_f sum_i f^2(i)",
            "// @param i_f sum_i i*f(i) (need i)",
            "template <class T = int64_t>",
            "struct Node final {",
            "T u, r;",
            "T i, f, sqr_f, i_f;",
            "Node(T const &u = 0, T const &r = 0, T const &i = 0, T const &f = 0, T const &sqr_f = 0, T const &i_f = 0): u(u), r(r), i(i), f(f), sqr_f(sqr_f), i_f(i_f) {}",
            "Node operator+(Node const &rhs) const {",
            "return Node{u + rhs.u,",
            "r + rhs.r,",
            "i + rhs.i + r * rhs.r,",
            "f + rhs.f + u * rhs.r,",
            "sqr_f + rhs.sqr_f + u * u * rhs.r + 2 * u * rhs.f,",
            "i_f + rhs.i_f + u * r * rhs.r + u * rhs.i + r * rhs.f};",
            "}",
            "};",
            "}  // namespace exEuclid"
        ]
    },
    "gauss-bitset": {
        "scope": "cpp",
        "prefix": "gauss-bitset",
        "body": [
            "template <size_t N>",
            "int64_t gauss_bitset(std::vector<std::bitset<N>> &mat, bool clear_all = true) {",
            "int64_t rk = 0;",
            "bool neg = false;",
            "for (size_t i = 0; i < std::min(mat.size(), N); ++i) {",
            "if (!mat[rk][i]) {",
            "for (size_t j = rk + 1; j < mat.size(); ++j)",
            "if (mat[j][i]) {",
            "std::swap(mat[j], mat[rk]);",
            "neg ^= true;",
            "break;",
            "}",
            "if (!mat[rk][i]) continue;",
            "}",
            "for (int64_t j = clear_all ? 0 : rk + 1; j < mat.size(); ++j) {",
            "if (j == rk || !mat[j][i]) continue;",
            "mat[j] ^= mat[rk];",
            "}",
            "++rk;",
            "}",
            "return neg ? -rk : rk;",
            "}"
        ]
    },
    "gauss-int": {
        "scope": "cpp",
        "prefix": "gauss-int",
        "body": [
            "// Z[sqrt(p)]",
            "//! NO overflow protect",
            "template <class Tp, int64_t K = -1>",
            "class GaussInt {",
            "using self = GaussInt<Tp, K>;",
            "private:",
            "Tp r_, i_;",
            "public:",
            "constexpr GaussInt(Tp const &real = Tp(), Tp const &imag = Tp())",
            ": r_(real), i_(imag) {}",
            "constexpr GaussInt(GaussInt const &) = default;",
            "constexpr GaussInt &operator=(Tp x) {",
            "r_ = x;",
            "i_ = Tp();",
            "return *this;",
            "}",
            "constexpr GaussInt &operator=(GaussInt const &) = default;",
            "constexpr Tp real() const { return r_; }",
            "constexpr Tp imag() const { return i_; }",
            "constexpr void real(Tp x) { r_ = x; }",
            "constexpr void imag(Tp x) { i_ = x; }",
            "constexpr self conj() const { return self{r_, -i_}; }",
            "constexpr Tp norm() const { return r_ * r_ + i_ * i_ * K; }",
            "constexpr self &operator+=(Tp const &x) {",
            "r_ += x;",
            "return *this;",
            "}",
            "constexpr self &operator-=(Tp const &x) {",
            "r_ -= x;",
            "return *this;",
            "}",
            "constexpr self &operator*=(Tp const &x) {",
            "r_ *= x;",
            "i_ *= x;",
            "return *this;",
            "}",
            "constexpr self &operator/=(Tp const &x) {",
            "r_ /= x;",
            "i_ /= x;",
            "return *this;",
            "}",
            "constexpr self &operator+=(self const &x) {",
            "r_ += x.real();",
            "i_ += x.imag();",
            "return *this;",
            "}",
            "constexpr self &operator-=(self const &x) {",
            "r_ -= x.real();",
            "i_ -= x.imag();",
            "return *this;",
            "}",
            "constexpr self &operator*=(self const &x) {",
            "const Tp _ = r_ * x.real() + i_ * x.imag() * K;",
            "i_ = r_ * x.imag() + i_ * x.real();",
            "r_ = _;",
            "return *this;",
            "}",
            "constexpr self &operator/=(self const &x) {",
            "const Tp _ = r_ * x.real() - i_ * x.imag() * K;",
            "const Tp n_ = x.norm();",
            "i_ = (i_ * x.real() - r_ * x.imag()) / n_;",
            "r_ = _ / n_;",
            "return *this;",
            "}",
            "constexpr friend self operator+(self x, Tp const &y) { return x += y; }",
            "constexpr friend self operator-(self x, Tp const &y) { return x -= y; }",
            "constexpr friend self operator*(self x, Tp const &y) { return x *= y; }",
            "constexpr friend self operator/(self x, Tp const &y) { return x /= y; }",
            "constexpr friend self operator+(self x, self const &y) { return x += y; }",
            "constexpr friend self operator-(self x, self const &y) { return x -= y; }",
            "constexpr friend self operator*(self x, self const &y) { return x *= y; }",
            "constexpr friend self operator/(self x, self const &y) { return x /= y; }",
            "};",
        ]
    },
    "gcd-lambda": {
        "scope": "cpp",
        "prefix": "gcd-lambda",
        "body": [
            "template <typename T>",
            "auto gcd = [](T n, T m) -> T {",
            "while (m ^= n ^= m ^= n %= m)\n;",
            "return n;",
            "};"
        ]
    },
    "gcd-O1": {
        "scope": "cpp",
        "prefix": "gcd-O1",
        "body": [
            "namespace Qgcd {",
            "using data_t = uint32_t;",
            "using idx_t = uint32_t;",
            "const idx_t OFFSET = 5;",
            "const idx_t N = 1e6, SQRT_N = 1e3;",
            "const idx_t P = (N <= 55 ? 16 : (int)(N / (logl(N) - 4))) + OFFSET;",
            "struct Factor3 { data_t a, b, c; Factor3(const data_t &_a = 0, const data_t &_b = 0, const data_t &_c = 0): a(_a), b(_b), c(_c) {} };",
            "bool vis[N + OFFSET];",
            "data_t prime[P];",
            "idx_t cnt_prime;",
            "Factor3 factors[N + OFFSET];",
            "data_t _gcd[SQRT_N + OFFSET][SQRT_N + OFFSET];",
            "void init() {",
            "factors[1] = {1, 1, 1};",
            "for (idx_t i = 2; i <= N; ++i) {",
            "if (!vis[i]) factors[i] = {1, 1, prime[++cnt_prime] = i};",
            "for (idx_t j = 1, ipj, apj; j <= cnt_prime && i * prime[j] <= N; ++j) {",
            "vis[ipj = i * prime[j]] = 1;",
            "apj = factors[i].a * prime[j];",
            "factors[ipj] = {apj, factors[i].b, factors[i].c};",
            "if (factors[ipj].a > factors[ipj].b) { std::swap(factors[ipj].a, factors[ipj].b); if (factors[ipj].b > factors[ipj].c) std::swap(factors[ipj].b, factors[ipj].c); }",
            "if (i % prime[j] == 0) break;",
            "}",
            "}",
            "for (idx_t i = 1; i <= SQRT_N; ++i) { _gcd[i][0] = _gcd[0][i] = _gcd[i][i] = i; for (idx_t j = 1; j < i; ++j) _gcd[i][j] = _gcd[j][i] = _gcd[j][i % j]; }",
            "}",
            "const auto STATIC__ = []() { init(); return 0; }();",
            "data_t main(data_t x, data_t y) {",
            "if (x <= SQRT_N && y <= SQRT_N) return _gcd[x][y];",
            "data_t ans = 1, _;",
            "for (data_t i : {factors[x].a, factors[x].b, factors[x].c}) { y /= (_ = i <= SQRT_N ? _gcd[i][y % i] : (y % i == 0) * (i - 1) + 1); ans *= _; }",
            "return ans;",
            "}",
            "}",
        ]
    },
    "lagrange-interpolation-fixed-key": {
        "scope": "cpp",
        "prefix": [
            "lagrange-interpolation-fixed-key"
        ],
        "body": [
            "// calculate f(x) % mod, which f(i) = v[i], i in [0, v.size())",
            "// f(x)=\\sum_{i=0}^{n-1} v_i \\prod_{j\\ne i} \\frac{x-x_j}{x_i-x_j}",
            "//     =\\sum_{i=0}^{n-1} v_i \\prod_{j\\ne i} \\frac{x-j}{i-j}",
            "//     =\\sum_{i=0}^{n-1} (-1)^{n-i-1} v_i \\frac{(\\prod_{j<i} x-j)(\\prod_{j>i} x-j)}{i!(n-i-1)!}",
            "// complexity: O(n)",
            "int64_t lagrange_interp_fixed_key(std::vector<int64_t> const &v, uint64_t x, int64_t mod) {",
            "const size_t n = v.size();",
            "if (x < n) return v[x];",
            "//? pre-proceed",
            "std::vector<int64_t> ifact(n);",
            "ifact[0] = ifact[1] = 1;",
            "for (size_t i = 2; i < n; ++i) ifact[i] = mod - mod / i * ifact[mod % i] % mod;",
            "for (size_t i = 3; i < n; ++i) (ifact[i] *= ifact[i - 1]) %= mod;",
            "//? pre-proceed end",
            "std::vector<int64_t> pre(n);",
            "for (size_t i = 0; i < n; ++i) pre[i] = x - i;",
            "for (size_t i = 1; i < n; ++i) (pre[i] *= pre[i - 1]) %= mod;",
            "std::vector<int64_t> suc(n);",
            "for (size_t i = 0; i < n; ++i) suc[i] = x - i;",
            "for (ptrdiff_t i = n - 2; i >= 0; --i) (suc[i] *= suc[i + 1]) %= mod;",
            "int64_t ans = 0;",
            "for (size_t i = 0; i < n; ++i) {",
            "int64_t _ = v[i];",
            "if (i) _ = _ * pre[i - 1] % mod;",
            "if (i + 1 < n) _ = _ * suc[i + 1] % mod;",
            "_ = _ * ifact[i] % mod * ifact[n - i - 1] % mod;",
            "ans = (ans + ((n - i) % 2 ? _ : mod - _)) % mod;",
            "}",
            "return ans;",
            "}"
        ]
    },
    "matrix": {
        "scope": "cpp",
        "prefix": [
            "mat",
            "matrix"
        ],
        "body": [
            "template <class Tp, class Iszero_t = std::function<bool(Tp)>>",
            "class matrix {",
            "#define ASSERTT_(expr, text) \\",
            "if (!(expr)) throw std::runtime_error(text);",
            "#define ASSERT_(expr) ASSERTT_(expr, #expr)",
            "using self = matrix<Tp, Iszero_t>;",
            "protected:",
            "constexpr bool gauss_swapr__(size_t &row_, size_t row_pre_, size_t col_, size_t row_end) {",
            "row_ = row_pre_;",
            "for (size_t j = row_ + 1; j < row_end; ++j)",
            "if (std::abs((*this)(j, col_)) > std::abs((*this)(row_, col_))) row_ = j;",
            "if (row_ != row_pre_) {",
            "swap_row(row_, row_pre_);",
            "return true;",
            "}",
            "return false;",
            "}",
            "protected:",
            "size_t r_sz, c_sz;",
            "Iszero_t iszero;",
            "std::valarray<Tp> data;",
            "public:",
            "matrix(size_t row, size_t col, Iszero_t iszero_func, const Tp &val = Tp{}): r_sz(row), c_sz(col), iszero(iszero_func), data(val, row * col) { ASSERT_(row > 0 && col > 0); }",
            "matrix(size_t row, size_t col, Iszero_t iszero_func, const std::valarray<Tp> &data_): r_sz(row), c_sz(col), iszero(iszero_func), data(data_) { ASSERT_(row > 0 && col > 0); }",
            "constexpr size_t row_size() const { return r_sz; }",
            "constexpr size_t col_size() const { return c_sz; }",
            "std::valarray<Tp> view() const { return data; }",
            "Tp &operator()(size_t r, size_t c) { return data[r * col_size() + c]; }",
            "Tp operator()(size_t r, size_t c) const { return data[r * col_size() + c]; }",
            "friend std::istream &operator>>(std::istream &is, self &mat) {",
            "for (auto &i : mat.data) is >> i;",
            "return is;",
            "}",
            "friend std::ostream &operator<<(std::ostream &os, const self &mat) {",
            "for (size_t i = 0; i < mat.row_size(); ++i)",
            "for (size_t j = 0; j < mat.col_size(); ++j) os << mat(i, j) << \" \\n\"[j == mat.col_size() - 1];",
            "return os;",
            "}",
            "#define SLICE__(name, para1_t, para1, ...) std::valarray<Tp> name(para1_t para1) const __VA_ARGS__ std::slice_array<Tp> name(para1_t para1) __VA_ARGS__ std::valarray<Tp> name##_varray(para1_t para1) const __VA_ARGS__",
            "SLICE__(row, size_t, r, { return data[std::slice(r * col_size(), col_size(), 1)]; })",
            "SLICE__(col, size_t, c, { return data[std::slice(c, row_size(), col_size())]; })",
            "SLICE__(diag, ptrdiff_t, d, {",
            "if (d >= 0) {",
            "assert(d < row_size());",
            "return data[std::slice(d, std::min(row_size(), col_size() - d), col_size() + 1)];",
            "} else {",
            "assert(-d < col_size());",
            "return data[std::slice(-d * row_size(), std::min(col_size(), row_size() + d), col_size() + 1)];",
            "}",
            "})",
            "#undef SLICE__",
            "self submatrix(size_t row_l, size_t row_r, size_t col_l, size_t col_r) const { return self(row_r - row_l, col_r - col_l, iszero, data[std::gslice(row_l * col_size() + col_l, {row_r - row_l, col_r - col_l}, {col_size(), 1})]); }",
            "std::gslice_array<Tp> submatrix_raw(size_t row_l, size_t row_r, size_t col_l, size_t col_r) { return data[std::gslice(row_l * col_size() + col_l, {row_r - row_l, col_r - col_l}, {col_size(), 1})]; }",
            "#define OPB__(op)                                                                                                                                    \\",
            "friend matrix<bool> operator op(const self &lhs, const Tp &val) { return matrix<bool>(lhs.row_size(), lhs.col_size(), lhs.data op val); } \\",
            "friend matrix<bool> operator op(const self &lhs, const self &rhs) {                                                                       \\",
            "ASSERT_(lhs.row_size() == rhs.row_size() && lhs.col_size() == rhs.col_size());                                                               \\",
            "return matrix<bool>(lhs.row_size(), lhs.col_size(), lhs.data op rhs.data);                                                                   \\",
            "}",
            "OPB__(==)",
            "OPB__(!=)",
            "OPB__(<)",
            "OPB__(<=)",
            "OPB__(>)",
            "OPB__(>=)",
            "#undef OPB__",
            "#define OP__(op)                                                                         \\",
            "friend self operator op(self lhs, const Tp &val) { return lhs op## = val; }   \\",
            "self &operator op##=(const Tp &val) {                                         \\",
            "data op## = val;                                                                 \\",
            "return *this;                                                                    \\",
            "}                                                                                    \\",
            "friend self operator op(self lhs, const self &rhs) { return lhs op## = rhs; } \\",
            "self &operator op##=(const self &rhs) {                                       \\",
            "ASSERT_(row_size() == rhs.row_size() && col_size() == rhs.col_size());           \\",
            "data op## = rhs.data;                                                            \\",
            "return *this;                                                                    \\",
            "}",
            "OP__(+)",
            "OP__(-)",
            "OP__(%)",
            "OP__(&)",
            "OP__(^)",
            "OP__(<<)",
            "OP__(>>)",
            "#undef OP__",
            "#define OPF__(op, ...)                                                                 \\",
            "friend self operator op(self lhs, const Tp &val) { return lhs op## = val; } \\",
            "self &operator op##=(const Tp &val) {                                       \\",
            "data op## = val;                                                               \\",
            "return *this;                                                                  \\",
            "}                                                                                  \\",
            "friend self operator op(const self &lhs, const self &rhs) __VA_ARGS__ self &operator op##=(const self &rhs) { return *this = *this op rhs; }",
            "OPF__(*, {",
            "ASSERT_(lhs.col_size() == rhs.row_size());",
            "self ret(lhs.row_size(), rhs.col_size(), lhs.iszero, Tp{});",
            "for (size_t i = 0; i < ret.row_size(); ++i) {",
            "auto &&r_ = lhs.row(i);",
            "for (size_t j = 0; j < ret.col_size(); ++j) ret(i, j) = (r_ * rhs.col(j)).sum();",
            "}",
            "return ret;",
            "})",
            "OPF__(/, { return lhs * rhs.inverse(); })",
            "// using guass method to calc lhs^{-1}*rhs",
            "OPF__(|, {",
            "ASSERT_(lhs.row_size() == lhs.col_size() && rhs.row_size() == lhs.row_size());",
            "self tmp_ = merge_lr(lhs, rhs);",
            "ASSERTT_(std::abs(tmp_.do_gauss()) == lhs.row_size(), \"Inverse not exist\");",
            "for (size_t i = 0; i < lhs.row_size(); ++i) tmp_.data[std::slice(i * (lhs.col_size() + rhs.col_size()) + lhs.col_size(), rhs.col_size(), 1)] /= std::valarray<Tp>(tmp_(i, i), rhs.col_size());",
            "return tmp_.submatrix(0, rhs.row_size(), lhs.col_size(), lhs.col_size() + rhs.col_size());",
            "})",
            "#undef OPF__",
            "// [lhs] [rhs] -> [lhs; rhs]",
            "friend self merge_ud(const self &lhs, const self &rhs) {",
            "ASSERT_(lhs.col_size() == rhs.col_size());",
            "self ret(lhs.row_size() + rhs.row_size(), lhs.col_size(), Tp{}, lhs.iszero);",
            "ret.data[std::slice(0, lhs.row_size() * lhs.col_size(), 1)] = lhs.view();",
            "ret.data[std::slice(lhs.row_size() * lhs.col_size(), rhs.row_size() * rhs.col_size(), 1)] = rhs.view();",
            "return ret;",
            "}",
            "// [lhs] [rhs] -> [lhs rhs]",
            "friend self merge_lr(const self &lhs, const self &rhs) {",
            "ASSERT_(lhs.row_size() == rhs.row_size());",
            "self ret(lhs.row_size(), lhs.col_size() + rhs.col_size(), Tp{}, lhs.iszero);",
            "ret.data[std::gslice(0, {lhs.row_size(), lhs.col_size()}, {ret.col_size(), 1})] = lhs.view();",
            "ret.data[std::gslice(lhs.col_size(), {rhs.row_size(), rhs.col_size()}, {ret.col_size(), 1})] = rhs.view();",
            "return ret;",
            "}",
            "constexpr void swap_row(size_t r1, size_t r2) {",
            "if (r1 == r2) return;",
            "std::valarray<Tp> __ = row(r1);",
            "row(r1) = row(r2);",
            "row(r2) = __;",
            "}",
            "constexpr void swap_col(size_t c1, size_t c2) {",
            "if (c1 == c2) return;",
            "std::valarray<Tp> __ = col(c1);",
            "col(c1) = col(c2);",
            "col(c2) = __;",
            "}",
            "constexpr void swap_diag(size_t d1, size_t d2) {",
            "if (d1 == d2) return;",
            "std::valarray<Tp> __ = diag(d1);",
            "diag(d1) = diag(d2);",
            "diag(d2) = __;",
            "}",
            "virtual int64_t do_gauss_range(size_t row_start, size_t row_end, bool clear_all = true) {",
            "ASSERT_(row_start < row_end && row_end <= row_size());",
            "int64_t rk = 0;",
            "bool neg = false;",
            "for (size_t i = row_start, now_row; i < std::min(row_end, col_size()); ++i) {",
            "neg ^= gauss_swapr__(now_row, rk, i, row_end);",
            "if (iszero((*this)(rk, i))) continue;",
            "std::valarray<Tp> tmp_ = data[std::slice(rk * col_size() + i + 1, col_size() - i - 1, 1)];",
            "for (int64_t j = clear_all ? 0 : rk + 1; j < (int64_t)row_end; ++j) {",
            "if (j == rk || iszero((*this)(j, i))) continue;",
            "Tp &&_ = (*this)(j, i) / (*this)(rk, i);",
            "(*this)(j, i) = 0;",
            "data[std::slice(j * col_size() + i + 1, col_size() - i - 1, 1)] -= tmp_ * _;",
            "}",
            "++rk;",
            "}",
            "return neg ? -rk : rk;",
            "}",
            "int64_t do_gauss(bool clear_all = true) { return do_gauss_range(0, std::min(row_size(), col_size()), clear_all); }",
            "self transpose() const {",
            "self ret(col_size(), row_size(), iszero, Tp{});",
            "for (size_t i = 0; i < row_size(); ++i) ret.col(i) = row(i);",
            "return ret;",
            "}",
            "self inverse() const {",
            "ASSERT_(row_size() == col_size());",
            "self ret(row_size(), col_size(), iszero, Tp{});",
            "ret.diag(0) = 1;",
            "ASSERTT_(std::abs((ret = merge_lr(*this, ret)).do_gauss()) == row_size(), \"Inverse not exist\");",
            "for (size_t i = 0; i < row_size(); ++i) ret.data[std::slice((i * 2 + 1) * col_size(), col_size(), 1)] /= std::valarray<Tp>(ret(i, i), col_size());",
            "ret = ret.submatrix(0, row_size(), col_size(), col_size() * 2);",
            "return ret;",
            "}",
            "Tp trace() const { return diag(0).sum(); }",
            "//! do NOT use this on `matrix_int` or `matrix_bool`",
            "size_t rank() const { return std::abs(self(*this).do_gauss(false)); }",
            "//! do NOT use this on `matrix_int` or `matrix_bool`",
            "Tp det() const {",
            "ASSERT_(row_size() == col_size());",
            "self tmp_(*this);",
            "ptrdiff_t rk_ = tmp_.do_gauss(false);",
            "if (std::abs(rk_) != row_size()) return Tp{};",
            "Tp ret = tmp_(0, 0);",
            "for (size_t i = 1; i < row_size(); ++i) ret *= tmp_(i, i);",
            "return rk_ < 0 ? -ret : ret;",
            "}",
            "friend self pow(self mat, size_t b) {",
            "self res(mat.row_size(), mat.col_size(), mat.iszero, Tp{});",
            "res.diag(0) = 1;",
            "for (; b; b >>= 1, mat *= mat)",
            "if (b & 1) res *= mat;",
            "return res;",
            "}",
            "};",
            "template <class Tp>",
            "class matrix_int: public matrix<Tp> {",
            "static_assert(std::is_integral<Tp>::value);",
            "using self = matrix_int<Tp>;",
            "using base = matrix<Tp>;",
            "private:",
            "constexpr static auto isz__ = [](Tp const &x) { return x == 0; };",
            "public:",
            "matrix_int(size_t row, size_t col, const Tp &val = Tp{}): base(row, col, isz__, val) {}",
            "matrix_int(size_t row, size_t col, const std::valarray<Tp> &data_): base(row, col, isz__, data_) {}",
            "int64_t do_gauss_range(size_t row_start, size_t row_end, bool clear_all = true) override {",
            "ASSERT_(row_start < row_end && row_end <= this->row_size());",
            "int64_t rk = 0;",
            "bool neg = false;",
            "for (size_t i = row_start, now_row; i < std::min(row_end, this->col_size()); ++i) {",
            "neg ^= this->gauss_swapr__(now_row, rk, i, row_end);",
            "if (this->iszero((*this)(rk, i))) continue;",
            "for (int64_t j = clear_all ? 0 : rk; j < (int64_t)row_end; ++j) {",
            "if (j == rk || this->iszero((*this)(j, i))) continue;",
            "while (true) {",
            "Tp _ = (*this)(j, i) / (*this)(rk, i);",
            "this->row(j) -= _ * this->row_varray(rk);",
            "if (!this->iszero((*this)(j, i))) {",
            "this->swap_row(rk, j);",
            "neg ^= 1;",
            "} else",
            "break;",
            "}",
            "}",
            "++rk;",
            "}",
            "return neg ? -rk : rk;",
            "}",
            "};",
            "class matrix_bool: public matrix<bool> {",
            "using self = matrix_bool;",
            "using base = matrix<bool>;",
            "private:",
            "constexpr static auto isz__ = [](bool x) { return !x; };",
            "public:",
            "matrix_bool(size_t row, size_t col, bool val = false): base(row, col, isz__, val) {}",
            "matrix_bool(size_t row, size_t col, const std::valarray<bool> &data_): base(row, col, isz__, data_) {}",
            "int64_t do_gauss_range(size_t row_start, size_t row_end, bool clear_all = true) override {",
            "ASSERT_(row_start < row_end && row_end <= this->row_size());",
            "int64_t rk = 0;",
            "bool neg = false;",
            "for (size_t i = row_start, now_row; i < std::min(row_end, this->col_size()); ++i) {",
            "if (!(*this)(rk, i)) {",
            "for (size_t j = rk + 1; j < row_end; ++j)",
            "if ((*this)(j, i)) {",
            "this->swap_row(j, rk);",
            "neg ^= true;",
            "break;",
            "}",
            "if (!(*this)(rk, i)) continue;",
            "}",
            "std::valarray<bool> tmp_ = data[std::slice(rk * this->col_size() + i + 1, this->col_size() - i - 1, 1)];",
            "for (int64_t j = clear_all ? 0 : rk + 1; j < (int64_t)row_end; ++j) {",
            "if (j == rk || iszero((*this)(j, i))) continue;",
            "(*this)(j, i) = false;",
            "data[std::slice(j * this->col_size() + i + 1, this->col_size() - i - 1, 1)] ^= tmp_;",
            "}",
            "++rk;",
            "}",
            "return neg ? -rk : rk;",
            "}",
            "};",
            "#undef ASSERT_",
            "#undef ASSERTT_"
        ]
    },
    "mod-int": {
        "scope": "cpp",
        "prefix": "mod-int",
        "body": [
            "//? See <https://atcoder.github.io/ac-library/production/document_en/modint.html>",
            "namespace MODINT {",
            "constexpr int64_t safe_mod(int64_t x, int64_t m) { return (x %= m) < 0 ? x + m : x; }",
            "// @return {gcd(a,b), solution of ax \\equiv 1 \\pmod b$}",
            "constexpr std::pair<int64_t, int64_t> invgcd(int64_t a, int64_t b) {",
            "if ((a = safe_mod(a, b)) == 0) return {b, 0};",
            "int64_t s = b, m0 = 0;",
            "for (int64_t q = 0, _ = 0, m1 = 1; a;) {",
            "_ = s - a * (q = s / a);",
            "s = a;",
            "a = _;",
            "_ = m0 - m1 * q;",
            "m0 = m1;",
            "m1 = _;",
            "}",
            "return {s, m0 + (m0 < 0 ? b / s : 0)};",
            "}",
            "template <uint32_t MOD>",
            "class Mint {",
            "static_assert(MOD >= 1);",
            "using self = Mint<MOD>;",
            "protected:",
            "uint32_t v_;",
            "public:",
            "constexpr static uint32_t mod() { return MOD; }",
            "constexpr static self raw(uint32_t v) {",
            "self x;",
            "x.v_ = v;",
            "return x;",
            "}",
            "constexpr Mint(): v_(0) {}",
            "template <class T, std::enable_if_t<std::is_integral<T>::value && std::is_signed<T>::value> * = nullptr>",
            "constexpr Mint(T v): Mint() {",
            "int64_t x = (int64_t)(v % (int64_t)mod());",
            "v_ = (uint32_t)(x + (x < 0 ? mod() : 0));",
            "}",
            "template <class T, std::enable_if_t<std::is_integral<T>::value && std::is_unsigned<T>::value> * = nullptr>",
            "constexpr Mint(T v): v_((uint32_t)(v % mod())) {}",
            "friend std::istream &operator>>(std::istream &is, self &x) {",
            "int64_t xx;",
            "is >> xx;",
            "xx %= mod();",
            "x.v_ = (uint32_t)(xx + (xx < 0 ? mod() : 0));",
            "return is;",
            "}",
            "friend std::ostream &operator<<(std::ostream &os, const self &x) { return os << x.v_; }",
            "constexpr const uint32_t &val() const { return v_; }",
            "constexpr explicit operator uint32_t() const { return val(); }",
            "constexpr uint32_t &data() { return v_; }",
            "constexpr self &operator++() {",
            "if (++v_ == mod()) v_ = 0;",
            "return *this;",
            "}",
            "constexpr self &operator--() {",
            "if (!v_) v_ = mod();",
            "--v_;",
            "return *this;",
            "}",
            "constexpr self operator++(int) {",
            "self result = *this;",
            "++*this;",
            "return result;",
            "}",
            "constexpr self operator--(int) {",
            "self result = *this;",
            "--*this;",
            "return result;",
            "}",
            "constexpr self &operator+=(const self &rhs) {",
            "v_ += rhs.v_;",
            "if (v_ >= mod()) v_ -= mod();",
            "return *this;",
            "}",
            "constexpr self &operator-=(const self &rhs) {",
            "v_ -= rhs.v_;",
            "if (v_ >= mod()) v_ += mod();",
            "return *this;",
            "}",
            "constexpr self &operator*=(const self &rhs) {",
            "v_ = (uint32_t)((uint64_t)v_ * rhs.v_ % mod());",
            "return *this;",
            "}",
            "constexpr self &operator/=(const self &rhs) { return *this = *this * inverse(rhs); }",
            "constexpr self operator+() const { return *this; }",
            "constexpr self operator-() const { return self() - *this; }",
            "constexpr friend self pow(self x, uint64_t y) {",
            "self res(1);",
            "for (; y; y >>= 1, x *= x)",
            "if (y & 1) res *= x;",
            "return res;",
            "}",
            "constexpr friend self inverse(const self &x) {",
            "auto &&_ = invgcd(x.v_, self::mod());",
            "if (_.first != 1) throw std::runtime_error(\"Inverse not exist\");",
            "return _.second;",
            "}",
            "constexpr friend self operator+(self lhs, const self &rhs) { return lhs += rhs; }",
            "constexpr friend self operator-(self lhs, const self &rhs) { return lhs -= rhs; }",
            "constexpr friend self operator*(self lhs, const self &rhs) { return lhs *= rhs; }",
            "constexpr friend self operator/(self lhs, const self &rhs) { return lhs /= rhs; }",
            "constexpr friend bool operator==(const self &lhs, const self &rhs) { return lhs.v_ == rhs.v_; }",
            "constexpr friend bool operator!=(const self &lhs, const self &rhs) { return lhs.v_ != rhs.v_; }",
            "};",
            "template <ptrdiff_t ID = -1>",
            "class DyMint {",
            "using self = DyMint<ID>;",
            "struct Barrett_ {",
            "uint32_t m_;",
            "uint64_t im;",
            "// @param m `1 <= m < 2^31`",
            "constexpr explicit Barrett_(uint32_t m = 998244353): m_(m), im((uint64_t)(-1) / m + 1) {}",
            "// @return m",
            "constexpr uint32_t umod() const { return m_; }",
            "constexpr uint32_t mul(uint32_t a, uint32_t b) const {",
            "uint64_t z = a;",
            "z *= b;",
            "uint64_t x = (uint64_t)(((__uint128_t)z * im) >> 64);",
            "uint32_t v = (uint32_t)(z - x * m_);",
            "return v + (m_ <= v ? m_ : 0);",
            "}",
            "};",
            "protected:",
            "uint32_t v_;",
            "static inline Barrett_ bt_;",
            "public:",
            "constexpr static uint32_t mod() { return bt_.umod(); }",
            "//! MUST be called first",
            "//! set module with same ID",
            "constexpr static void set_mod(uint32_t m) {",
            "assert(1 <= m);",
            "bt_ = Barrett_(m);",
            "}",
            "constexpr static self raw(uint32_t v) {",
            "self x;",
            "x.v_ = v;",
            "return x;",
            "}",
            "constexpr DyMint(): v_(0) {}",
            "template <class T, std::enable_if_t<std::is_integral<T>::value && std::is_signed<T>::value> * = nullptr>",
            "constexpr DyMint(T v): DyMint() {",
            "int64_t x = (int64_t)(v % (int64_t)mod());",
            "v_ = (uint32_t)(x + (x < 0 ? mod() : 0));",
            "}",
            "template <class T, std::enable_if_t<std::is_integral<T>::value && std::is_unsigned<T>::value> * = nullptr>",
            "constexpr DyMint(T v): v_((uint32_t)(v % mod())) {}",
            "friend std::istream &operator>>(std::istream &is, self &x) {",
            "int64_t xx;",
            "is >> xx;",
            "xx %= mod();",
            "x.v_ = (uint32_t)(xx + (xx < 0 ? mod() : 0));",
            "return is;",
            "}",
            "friend std::ostream &operator<<(std::ostream &os, const self &x) { return os << x.v_; }",
            "constexpr const uint32_t &val() const { return v_; }",
            "constexpr explicit operator uint32_t() const { return val(); }",
            "constexpr uint32_t &data() { return v_; }",
            "constexpr self &operator++() {",
            "if (++v_ == mod()) v_ = 0;",
            "return *this;",
            "}",
            "constexpr self &operator--() {",
            "if (!v_) v_ = mod();",
            "--v_;",
            "return *this;",
            "}",
            "constexpr self operator++(int) {",
            "self result = *this;",
            "++*this;",
            "return result;",
            "}",
            "constexpr self operator--(int) {",
            "self result = *this;",
            "--*this;",
            "return result;",
            "}",
            "constexpr self &operator+=(const self &rhs) {",
            "v_ += rhs.v_;",
            "if (v_ >= mod()) v_ -= mod();",
            "return *this;",
            "}",
            "constexpr self &operator-=(const self &rhs) {",
            "v_ -= rhs.v_;",
            "if (v_ >= mod()) v_ += mod();",
            "return *this;",
            "}",
            "constexpr self &operator*=(const self &rhs) {",
            "v_ = bt_.mul(v_, rhs.v_);",
            "return *this;",
            "}",
            "constexpr self &operator/=(const self &rhs) { return *this = *this * inverse(rhs); }",
            "constexpr self operator+() const { return *this; }",
            "constexpr self operator-() const { return self() - *this; }",
            "constexpr friend self pow(self x, uint64_t y) {",
            "self res(1);",
            "for (; y; y >>= 1, x *= x)",
            "if (y & 1) res *= x;",
            "return res;",
            "}",
            "constexpr friend self inverse(const self &x) {",
            "auto &&_ = invgcd(x.v_, self::mod());",
            "if (_.first != 1) throw std::runtime_error(\"Inverse not exist\");",
            "return _.second;",
            "}",
            "constexpr friend self operator+(self lhs, const self &rhs) { return lhs += rhs; }",
            "constexpr friend self operator-(self lhs, const self &rhs) { return lhs -= rhs; }",
            "constexpr friend self operator*(self lhs, const self &rhs) { return lhs *= rhs; }",
            "constexpr friend self operator/(self lhs, const self &rhs) { return lhs /= rhs; }",
            "constexpr friend bool operator==(const self &lhs, const self &rhs) { return lhs.v_ == rhs.v_; }",
            "constexpr friend bool operator!=(const self &lhs, const self &rhs) { return lhs.v_ != rhs.v_; }",
            "};",
            "}  // namespace MODINT",
            "using MODINT::DyMint;",
            "using MODINT::Mint;",
            "using mint998244353 = Mint<998244353>;",
            "using mint1e9a7 = Mint<1000000007>;",
            "using dmint = DyMint<>;",
            "// namespace std {",
            "// template <uint32_t MOD>",
            "// uint32_t abs(Mint<MOD> x) { return x.data(); }",
            "// template <ptrdiff_t ID>",
            "// uint32_t abs(DyMint<ID> x) { return x.data(); }",
            "// }  // namespace std"
        ]
    },
    "newton-interpolation": {
        "scope": "cpp",
        "prefix": [
            "newton-interpolation",
            "newton-interp",
            "interpolation",
            "interp",
        ],
        "body": [
            "template <class T>",
            "class NewtonInterp {",
            "// {(x_0,y_0),(x__1,y_1),...,(x_{n-1},y_{n-1})}",
            "std::vector<std::pair<T, T>> points;",
            "// diffs[r][l] = f[x_l,x_{l+1},...,x_r]",
            "std::vector<std::vector<T>> diffs;",
            "// (x-x_0)(x-x_1)...(x-x_{n-1})",
            "std::vector<T> base;",
            "// f[x_0]+f[x_0,x_1](x-x_0)+...+f[x_0,x_1,...,x_n](x-x_0)(x-x_1)...(x-x_{n-1})",
            "std::vector<T> fit;",
            "public:",
            "explicit NewtonInterp() = default;",
            "NewtonInterp &insert(T const &x, T const &y) {",
            "points.emplace_back(x, y);",
            "size_t n = points.size();",
            "if (n == 1) {",
            "base.push_back(1);",
            "} else {",
            "size_t m = base.size();",
            "base.push_back(0);",
            "for (size_t i = m; i; --i) base[i] = base[i - 1];",
            "base[0] = 0;",
            "for (size_t i = 0; i < m; ++i) base[i] = base[i] - points[n - 2].first * base[i + 1];",
            "}",
            "diffs.emplace_back(points.size());",
            "diffs[n - 1][n - 1] = y;",
            "if (n > 1)",
            "for (size_t i = n - 2; ~i; --i) diffs[n - 1][i] = (diffs[n - 2][i] - diffs[n - 1][i + 1]) / (points[i].first - points[n - 1].first);",
            "fit.push_back(0);",
            "for (size_t i = 0; i < n; ++i) fit[i] = fit[i] + diffs[n - 1][0] * base[i];",
            "return *this;",
            "}",
            "std::vector<T> coeffs() const { return fit; }",
            "T evaluate(T const &x) {",
            "T ans{};",
            "for (auto it = fit.rbegin(); it != fit.rend(); ++it) ans = ans * x + *it;",
            "return ans;",
            "}",
            "};"
        ]
    },
    "prime": {
        "scope": "cpp",
        "prefix": "prime",
        "body": [
            "namespace primes {",
            "// <https://www.jstor.org/stable/2371291/>",
            "// prime.size() approx (n <= 55 ? 16 : (int)(n / (logl(n) - 4)));",
            "std::vector<int32_t> min_pfactor, prime;",
            "std::vector<int64_t> pw, sigma, phi, mu;",
            "void init_prime(uint32_t n) {",
            "min_pfactor.resize(n);",
            "pw.resize(n);",
            "sigma.resize(n);",
            "phi.resize(n);",
            "mu.resize(n);",
            "sigma[1] = phi[1] = mu[1] = 1;",
            "for (int64_t i = 2; i < n; ++i) {",
            "if (!min_pfactor[i]) {",
            "prime.push_back(min_pfactor[i] = i);",
            "pw[i] = i * i;",
            "sigma[i] = i + 1;",
            "phi[i] = i - 1;",
            "mu[i] = -1;",
            "}",
            "for (auto &&j : prime) {",
            "int64_t x = i * j;",
            "if (x >= n) break;",
            "min_pfactor[x] = j;",
            "if (i % j) {",
            "pw[x] = (int64_t)j * j;",
            "sigma[x] = sigma[i] * (j + 1);",
            "phi[x] = phi[i] * (j - 1);",
            "mu[x] = -mu[i];",
            "} else {",
            "sigma[x] = sigma[i] * ((pw[x] = pw[i] * j) - 1) / (pw[i] - 1);",
            "phi[x] = phi[i] * j;",
            "break;",
            "}",
            "}",
            "}",
            "}",
            "}  // namespace primes",
            "using primes::init_prime, primes::prime, primes::min_pfactor, primes::mu, primes::phi, primes::sigma;"
        ]
    },
    "real-basis": {
        "scope": "cpp",
        "prefix": "real-basis",
        "body": [
            "template <std::size_t N = 64>",
            "class RealBasis {",
            "using self = RealBasis<N>;",
            "using field_t = double;",
            "using vector_t = std::array<field_t, N>;",
            "using reference = self &;",
            "using iterator = vector_t *;",
            "using const_iterator = vector_t *;",
            "using reverse_iterator = std::reverse_iterator<iterator>;",
            "using const_reverse_iterator = std::reverse_iterator<const_iterator>;",
            "public:",
            "const field_t EPS;",
            "protected:",
            "vector_t base[N];",
            "bool is_zero(field_t x) const { return std::abs(x) < EPS; }",
            "public:",
            "constexpr explicit RealBasis(field_t EPS_ = 1e-4): EPS(EPS_) { this->clear(); }",
            "constexpr RealBasis(std::initializer_list<vector_t> _list): RealBasis() {",
            "for (auto &&i : _list) this->insert(i);",
            "}",
            "constexpr void clear() {",
            "for (size_t i = 0; i < size(); ++i) base[i].fill(0);",
            "}",
            "constexpr size_t size() const { return N; }",
            "constexpr vector_t &operator[](size_t index) { return this->base[index]; }",
            "constexpr vector_t &operator[](size_t index) const { return const_cast<self * const>(this)->base[index]; }",
            "constexpr iterator begin() { return this->base; }",
            "constexpr const_iterator begin() const { return const_cast<vector_t * const>(this->base); }",
            "constexpr iterator end() { return this->begin() + this->size(); }",
            "constexpr const_iterator end() const { return this->begin() + this->size(); }",
            "reverse_iterator rbegin() { return reverse_iterator(this->end()); }",
            "const_reverse_iterator rbegin() const { return const_reverse_iterator(this->end()); }",
            "reverse_iterator rend() { return reverse_iterator(this->begin()); }",
            "const_reverse_iterator rend() const { return const_reverse_iterator(this->begin()); }",
            "constexpr bool insert(vector_t x) {",
            "bool status = false;",
            "for (size_t i = size() - 1; ~i; --i) {",
            "if (is_zero(x[i])) continue;",
            "if (!is_zero(base[i][i])) {",
            "field_t __ = x[i] / base[i][i];",
            "x[i] = 0;",
            "for (size_t j = 0; j < i; ++j) x[j] -= base[i][j] * __;",
            "} else {",
            "for (size_t j = 0; j < i; ++j)",
            "if (!is_zero(x[j]) && !is_zero(base[j][j])) {",
            "field_t __ = x[j] / base[j][j];",
            "x[j] = 0;",
            "for (size_t k = 0; k < j; ++k) x[k] -= base[j][k] * __;",
            "}",
            "for (size_t j = i + 1; j < size(); ++j)",
            "if (!is_zero(base[j][i]) && !is_zero(x[i])) {",
            "field_t __ = base[j][i] / x[i];",
            "base[j][i] = 0;",
            "for (size_t k = 0; k < i; ++k) base[j][k] -= x[k] * __;",
            "}",
            "base[i] = x;",
            "status = true;",
            "break;",
            "}",
            "}",
            "return status;",
            "}",
            "constexpr size_t rank() const {",
            "size_t res = 0;",
            "for (size_t i = 0; i < size(); ++i) res += !is_zero(base[i][i]);",
            "return res;",
            "}",
            "// @return std::nullopt if x is linear independent with current basis, else return the solution",
            "constexpr std::optional<vector_t> coordinate(vector_t x) {",
            "vector_t res;",
            "for (size_t i = size() - 1; ~i; --i)",
            "if (!is_zero(x[i])) {",
            "if (is_zero(base[i][i])) return std::nullopt;",
            "field_t __ = x[i] / base[i][i];",
            "res[i] = __;",
            "x[i] = 0;",
            "for (size_t j = 0; j <= i; ++j) x[j] -= base[i][j] * __;",
            "}",
            "return res;",
            "}",
            "};"
        ]
    },
    "romberg": {
        "scope": "cpp",
        "prefix": "romberg",
        "body": [
            "class RombergSolver {",
            "private:",
            "std::function<double(double)> f;",
            "double ctqf(double a, double b, double h) const {",
            "double ans = 0;",
            "for (double i = a + h * .5; i < b; i += h) ans += f(i);",
            "return ans;",
            "}",
            "public:",
            "template <typename Func>",
            "RombergSolver(Func &&func): f(func) {}",
            "double operator()(double a, double b, double eps) const {",
            "double h = b - a;",
            "double T1 = (f(a) + f(b)) * h * .5, T2 = 0, S1 = 0, S2 = 0, C1 = 0, C2 = 0, R1 = 0, R2 = 0;",
            "for (int k = 1; k < 4; h *= .5, ++k) {",
            "T2 = (T1 + h * ctqf(a, b, h)) * .5;",
            "S2 = (4 * T2 - T1) / 3;",
            "T1 = T2;",
            "if (k == 1) {",
            "S1 = S2;",
            "continue;",
            "};",
            "C2 = (16 * S2 - S1) / 15;",
            "if (k == 2) {",
            "C1 = C2;",
            "continue;",
            "};",
            "R1 = (64 * C2 - C1) / 63;",
            "}",
            "for (;; h /= 2, T1 = T2, S1 = S2, C1 = C2, R1 = R2)",
            "if (std::abs(R1 - (R2 = (64 * (C2 = (16 * (S2 = (4 * (T2 = (T1 + h * ctqf(a, b, h)) * .5) - T1) / 3) - S1) / 15) - C1) / 63)) < eps) break;",
            "return R2;",
            "}",
            "};"
        ]
    },
    "simpson": {
        "scope": "cpp",
        "prefix": "simpson",
        "body": [
            "class SimpsonSolver {",
            "private:",
            "std::function<double(double)> f;",
            "constexpr static double simpson(double l, double r, double fl, double fmid, double fr) { return (fl + 4 * fmid + fr) * (r - l) / 6; }",
            "double asr(double l, double r, double area, double eps) const {",
            "double mid = r - (r - l) * .5;",
            "double lmid = mid - (mid - l) * .5, rmid = r - (r - mid) * .5;",
            "double fl = f(l), flmid = f(lmid), fmid = f(mid), frmid = f(rmid), fr = f(r);",
            "double ls = simpson(l, mid, fl, flmid, fmid), rs = simpson(mid, r, fmid, frmid, fr);",
            "if (std::abs(ls + rs - area) <= 15 * eps) return ls + rs + (ls + rs - area) / 15;",
            "return asr(l, mid, ls, eps * .5) + asr(mid, r, rs, eps * .5);",
            "}",
            "double asr(double l, double r, double area, double eps, double dep) const {",
            "double mid = r - (r - l) * .5;",
            "double lmid = mid - (mid - l) * .5, rmid = r - (r - mid) * .5;",
            "double fl = f(l), flmid = f(lmid), fmid = f(mid), frmid = f(rmid), fr = f(r);",
            "double ls = simpson(l, mid, fl, flmid, fmid), rs = simpson(mid, r, fmid, frmid, fr);",
            "if (std::abs(ls + rs - area) <= 15 * eps && dep <= 0) return ls + rs + (ls + rs - area) / 15;",
            "return asr(l, mid, ls, eps * .5, dep - 1) + asr(mid, r, rs, eps * .5, dep - 1);",
            "}",
            "public:",
            "template <typename Func>",
            "SimpsonSolver(Func &&func): f(func) {}",
            "double operator()(double l, double r, double eps) const { return asr(l, r, simpson(l, r, f(l), f(r - (r - l) * .5), f(r)), eps); }",
            "double operator()(double l, double r, double eps, double min_dep) const { return asr(l, r, simpson(l, r, f(l), f(r - (r - l) * .5), f(r)), eps, min_dep); }",
            "};"
        ]
    },
    "xor-basis": {
        "scope": "cpp",
        "prefix": "xor-basis",
        "body": [
            "template <std::size_t N = 64>",
            "class XorBasis {",
            "using self = XorBasis<N>;",
            "using field_t = bool;",
            "using vector_t = std::bitset<N>;",
            "using reference = self &;",
            "using iterator = vector_t *;",
            "using const_iterator = vector_t *;",
            "using reverse_iterator = std::reverse_iterator<iterator>;",
            "using const_reverse_iterator = std::reverse_iterator<const_iterator>;",
            "protected:",
            "vector_t base[N];",
            "public:",
            "constexpr XorBasis() { this->clear(); }",
            "constexpr XorBasis(std::initializer_list<vector_t> _list): XorBasis() {",
            "for (auto &&i : _list) this->insert(i);",
            "}",
            "constexpr void clear() {",
            "for (size_t i = 0; i < size(); ++i) base[i].reset();",
            "}",
            "constexpr size_t size() const { return N; }",
            "constexpr vector_t &operator[](size_t index) { return this->base[index]; }",
            "constexpr vector_t &operator[](size_t index) const { return const_cast<self * const>(this)->base[index]; }",
            "constexpr iterator begin() { return this->base; }",
            "constexpr const_iterator begin() const { return const_cast<vector_t * const>(this->base); }",
            "constexpr iterator end() { return this->begin() + this->size(); }",
            "constexpr const_iterator end() const { return this->begin() + this->size(); }",
            "reverse_iterator rbegin() { return reverse_iterator(this->end()); }",
            "const_reverse_iterator rbegin() const { return const_reverse_iterator(this->end()); }",
            "reverse_iterator rend() { return reverse_iterator(this->begin()); }",
            "const_reverse_iterator rend() const { return const_reverse_iterator(this->begin()); }",
            "constexpr bool insert(vector_t x) {",
            "bool status = false;",
            "for (size_t i = size() - 1; ~i; --i) {",
            "if (!(x[i])) continue;",
            "if (base[i][i])",
            "x ^= base[i];",
            "else {",
            "for (size_t j = 0; j < i; ++j)",
            "if (x[j]) x ^= base[j];",
            "for (size_t j = i + 1; j < size(); ++j)",
            "if (base[j][i]) base[j] ^= x;",
            "base[i] = x;",
            "status = true;",
            "break;",
            "}",
            "}",
            "return status;",
            "}",
            "constexpr vector_t max_span() const {",
            "vector_t ret;",
            "for (const auto &i : *this) ret ^= i;",
            "return ret;",
            "}",
            "constexpr size_t rank() const {",
            "size_t res = 0;",
            "for (size_t i = 0; i < size(); ++i) res += base[i][i];",
            "return res;",
            "}",
            "// @return std::nullopt if x is linear independent with current basis, else return the solution",
            "constexpr std::optional<vector_t> coordinate(vector_t x) {",
            "vector_t res;",
            "for (size_t i = size() - 1; ~i; --i)",
            "if (x[i]) {",
            "if (!base[i][i]) return std::nullopt;",
            "res.set(i);",
            "x ^= base[i];",
            "}",
            "return res;",
            "}",
            "};"
        ]
    }
}
{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "exeuclid": {
        "scope": "cpp",
        "prefix": [
            "exeuclid"
        ],
        "body": [
            "namespace exEuclid {",
            "template <class Node>",
            "constexpr Node qpow_(Node a, int64_t b) {",
            "Node res;",
            "for (; b; b >>= 1, a = a + a)",
            "if (b & 1) res = res + a;",
            "return res;",
            "}",
            "template <class Node>",
            "Node solve_(int64_t p, int64_t q, int64_t r, int64_t l, Node a, Node b) {",
            "#pragma GCC diagnostic push",
            "#pragma GCC diagnostic ignored \"-Wfloat-conversion\"",
            "auto div = [](int64_t a, int64_t b, int64_t c, int64_t d) -> int64_t { return (1.l * a * b + c) / d; };",
            "#pragma GCC diagnostic pop",
            "if (!l) return Node();",
            "if (p >= q) return solve_(p % q, q, r, l, a, qpow_(a, p / q) + b);",
            "int64_t m = div(l, p, r, q);",
            "if (!m) return qpow_(b, l);",
            "int64_t cnt = l - div(q, m, -r - 1, p);",
            "return qpow_(b, (q - r - 1) / p) + a + solve_(q, p, (q - r - 1) % p, m - 1, b, a) + qpow_(b, cnt);",
            "}",
            "//! USE THIS",
            "// consider line s: y = (p * x + r) / q, 0 < x <= l",
            "// result will add a when s cross with horizontal line",
            "// result will add b when s cross with vertical line",
            "template <class Node>",
            "constexpr Node solve(int64_t p, int64_t q, int64_t r, int64_t l, Node const &a, Node const &b) { return qpow_(a, r / q) + solve_(p, q, r % q, l, a, b); }",
            "//! USE THIS",
            "// let f(x) = floor((p * x + r) / q)",
            "// @param u (DO NOT EDIT) count of horizontal lines have been crossed",
            "// @param r (DO NOT EDIT) count of vertical lines have been crossed",
            "// @param i sum_i i (needed by i_f)",
            "// @param f sum_i i f(i)",
            "// @param sqr_f sum_i f^2(i)",
            "// @param i_f sum_i i*f(i) (need i)",
            "template <class T = int64_t>",
            "struct Node final {",
            "T u, r;",
            "T i, f, sqr_f, i_f;",
            "Node(T const &u = 0, T const &r = 0, T const &i = 0, T const &f = 0, T const &sqr_f = 0, T const &i_f = 0): u(u), r(r), i(i), f(f), sqr_f(sqr_f), i_f(i_f) {}",
            "Node operator+(Node const &rhs) const {",
            "return Node{u + rhs.u,",
            "r + rhs.r,",
            "i + rhs.i + r * rhs.r,",
            "f + rhs.f + u * rhs.r,",
            "sqr_f + rhs.sqr_f + u * u * rhs.r + 2 * u * rhs.f,",
            "i_f + rhs.i_f + u * r * rhs.r + u * rhs.i + r * rhs.f};",
            "}",
            "};",
            "}  // namespace exEuclid"
        ]
    },
    "lagrange-interpolation-fixed-key": {
        "scope": "cpp",
        "prefix": [
            "lagrange-interpolation-fixed-key"
        ],
        "body": [
            "// calculate f(x) % mod, which f(i) = v[i], i in [0, v.size())",
            "// f(x)=\\sum_{i=0}^{n-1} v_i \\prod_{j\\ne i} \\frac{x-x_j}{x_i-x_j}",
            "//     =\\sum_{i=0}^{n-1} v_i \\prod_{j\\ne i} \\frac{x-j}{i-j}",
            "//     =\\sum_{i=0}^{n-1} (-1)^{n-i-1} v_i \\frac{(\\prod_{j<i} x-j)(\\prod_{j>i} x-j)}{i!(n-i-1)!}",
            "// complexity: O(n)",
            "int64_t lagrange_interp_fixed_key(std::vector<int64_t> const &v, uint64_t x, int64_t mod) {",
            "const size_t n = v.size();",
            "if (x < n) return v[x];",
            "//? pre-proceed",
            "std::vector<int64_t> ifact(n);",
            "ifact[0] = ifact[1] = 1;",
            "for (size_t i = 2; i < n; ++i) ifact[i] = mod - mod / i * ifact[mod % i] % mod;",
            "for (size_t i = 3; i < n; ++i) (ifact[i] *= ifact[i - 1]) %= mod;",
            "//? pre-proceed end",
            "std::vector<int64_t> pre(n);",
            "for (size_t i = 0; i < n; ++i) pre[i] = x - i;",
            "for (size_t i = 1; i < n; ++i) (pre[i] *= pre[i - 1]) %= mod;",
            "std::vector<int64_t> suc(n);",
            "for (size_t i = 0; i < n; ++i) suc[i] = x - i;",
            "for (ptrdiff_t i = n - 2; i >= 0; --i) (suc[i] *= suc[i + 1]) %= mod;",
            "int64_t ans = 0;",
            "for (size_t i = 0; i < n; ++i) {",
            "int64_t _ = v[i];",
            "if (i) _ = _ * pre[i - 1] % mod;",
            "if (i + 1 < n) _ = _ * suc[i + 1] % mod;",
            "_ = _ * ifact[i] % mod * ifact[n - i - 1] % mod;",
            "ans = (ans + ((n - i) % 2 ? _ : mod - _)) % mod;",
            "}",
            "return ans;",
            "}"
        ]
    }
}
{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "convolution-fft": {
        "scope": "cpp",
        "prefix": [
            "conv",
            "convolution",
            "convolution-fft",
            "fft-double"
        ],
        "body": [
            "namespace FFT {",
            "using CP = std::complex<double>;",
            "const double PI = acos(-1.0);",
            "size_t n = 0;",
            "std::vector<size_t> rev;",
            "void init(size_t m) {",
            "if (n > m) return;",
            "n = 1;",
            "int k = 0;",
            "while (n <= m) {",
            "n <<= 1;",
            "++k;",
            "}",
            "rev.resize(n);",
            "for (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (k - 1));",
            "}",
            "void dft(std::vector<CP> &a, int op) {",
            "for (int i = 0; i < n; ++i)",
            "if (rev[i] > i) std::swap(a[rev[i]], a[i]);",
            "for (int i = 1; i < n; i <<= 1) {",
            "CP now(std::cos(PI / i), op * std::sin(PI / i));",
            "for (int j = 0, p = (i << 1); j < n; j += p) {",
            "CP w(1, 0);",
            "for (int k = 0; k < i; ++k, w = w * now) {",
            "CP x = a[j + k], y = a[j + k + i] * w;",
            "a[j + k] = x + y;",
            "a[j + k + i] = x - y;",
            "}",
            "}",
            "}",
            "if (op == -1)",
            "for (int i = 0; i < n; ++i) a[i] = {a[i].real() / n, a[i].imag() / n};",
            "}",
            "std::vector<double> conv(std::vector<double> const &a, std::vector<double> const &b) {",
            "init(a.size() + b.size() - 1);",
            "std::vector<CP> a_(n), b_(n), c_(n);",
            "for (size_t i = 0; i < a.size(); ++i) a_[i] = a[i];",
            "for (size_t i = 0; i < b.size(); ++i) b_[i] = b[i];",
            "dft(a_, 1);",
            "dft(b_, 1);",
            "for (size_t i = 0; i < n; ++i) c_[i] = a_[i] * b_[i];",
            "dft(c_, -1);",
            "std::vector<double> c(a.size() + b.size() - 1);",
            "for (size_t i = 0; i < a.size() + b.size() - 1; ++i) c[i] = c_[i].real();",
            "return c;",
            "}",
            "}  // namespace FFT",
            "using FFT::conv;"
        ]
    },
    "exeuclid": {
        "scope": "cpp",
        "prefix": [
            "exeuclid"
        ],
        "body": [
            "namespace exEuclid {",
            "template <class Node>",
            "constexpr Node qpow_(Node a, int64_t b) {",
            "Node res;",
            "for (; b; b >>= 1, a = a + a)",
            "if (b & 1) res = res + a;",
            "return res;",
            "}",
            "template <class Node>",
            "Node solve_(int64_t p, int64_t q, int64_t r, int64_t l, Node a, Node b) {",
            "#pragma GCC diagnostic push",
            "#pragma GCC diagnostic ignored \"-Wfloat-conversion\"",
            "auto div = [](int64_t a, int64_t b, int64_t c, int64_t d) -> int64_t { return (1.l * a * b + c) / d; };",
            "#pragma GCC diagnostic pop",
            "if (!l) return Node();",
            "if (p >= q) return solve_(p % q, q, r, l, a, qpow_(a, p / q) + b);",
            "int64_t m = div(l, p, r, q);",
            "if (!m) return qpow_(b, l);",
            "int64_t cnt = l - div(q, m, -r - 1, p);",
            "return qpow_(b, (q - r - 1) / p) + a + solve_(q, p, (q - r - 1) % p, m - 1, b, a) + qpow_(b, cnt);",
            "}",
            "//! USE THIS",
            "// consider line s: y = (p * x + r) / q, 0 < x <= l",
            "// result will add a when s cross with horizontal line",
            "// result will add b when s cross with vertical line",
            "template <class Node>",
            "constexpr Node solve(int64_t p, int64_t q, int64_t r, int64_t l, Node const &a, Node const &b) { return qpow_(a, r / q) + solve_(p, q, r % q, l, a, b); }",
            "//! USE THIS",
            "// let f(x) = floor((p * x + r) / q)",
            "// @param u (DO NOT EDIT) count of horizontal lines have been crossed",
            "// @param r (DO NOT EDIT) count of vertical lines have been crossed",
            "// @param i sum_i i (needed by i_f)",
            "// @param f sum_i i f(i)",
            "// @param sqr_f sum_i f^2(i)",
            "// @param i_f sum_i i*f(i) (need i)",
            "template <class T = int64_t>",
            "struct Node final {",
            "T u, r;",
            "T i, f, sqr_f, i_f;",
            "Node(T const &u = 0, T const &r = 0, T const &i = 0, T const &f = 0, T const &sqr_f = 0, T const &i_f = 0): u(u), r(r), i(i), f(f), sqr_f(sqr_f), i_f(i_f) {}",
            "Node operator+(Node const &rhs) const {",
            "return Node{u + rhs.u,",
            "r + rhs.r,",
            "i + rhs.i + r * rhs.r,",
            "f + rhs.f + u * rhs.r,",
            "sqr_f + rhs.sqr_f + u * u * rhs.r + 2 * u * rhs.f,",
            "i_f + rhs.i_f + u * r * rhs.r + u * rhs.i + r * rhs.f};",
            "}",
            "};",
            "}  // namespace exEuclid"
        ]
    },
    "lagrange-interpolation-fixed-key": {
        "scope": "cpp",
        "prefix": [
            "lagrange-interpolation-fixed-key"
        ],
        "body": [
            "// calculate f(x) % mod, which f(i) = v[i], i in [0, v.size())",
            "// f(x)=\\sum_{i=0}^{n-1} v_i \\prod_{j\\ne i} \\frac{x-x_j}{x_i-x_j}",
            "//     =\\sum_{i=0}^{n-1} v_i \\prod_{j\\ne i} \\frac{x-j}{i-j}",
            "//     =\\sum_{i=0}^{n-1} (-1)^{n-i-1} v_i \\frac{(\\prod_{j<i} x-j)(\\prod_{j>i} x-j)}{i!(n-i-1)!}",
            "// complexity: O(n)",
            "int64_t lagrange_interp_fixed_key(std::vector<int64_t> const &v, uint64_t x, int64_t mod) {",
            "const size_t n = v.size();",
            "if (x < n) return v[x];",
            "//? pre-proceed",
            "std::vector<int64_t> ifact(n);",
            "ifact[0] = ifact[1] = 1;",
            "for (size_t i = 2; i < n; ++i) ifact[i] = mod - mod / i * ifact[mod % i] % mod;",
            "for (size_t i = 3; i < n; ++i) (ifact[i] *= ifact[i - 1]) %= mod;",
            "//? pre-proceed end",
            "std::vector<int64_t> pre(n);",
            "for (size_t i = 0; i < n; ++i) pre[i] = x - i;",
            "for (size_t i = 1; i < n; ++i) (pre[i] *= pre[i - 1]) %= mod;",
            "std::vector<int64_t> suc(n);",
            "for (size_t i = 0; i < n; ++i) suc[i] = x - i;",
            "for (ptrdiff_t i = n - 2; i >= 0; --i) (suc[i] *= suc[i + 1]) %= mod;",
            "int64_t ans = 0;",
            "for (size_t i = 0; i < n; ++i) {",
            "int64_t _ = v[i];",
            "if (i) _ = _ * pre[i - 1] % mod;",
            "if (i + 1 < n) _ = _ * suc[i + 1] % mod;",
            "_ = _ * ifact[i] % mod * ifact[n - i - 1] % mod;",
            "ans = (ans + ((n - i) % 2 ? _ : mod - _)) % mod;",
            "}",
            "return ans;",
            "}"
        ]
    },
    "newton-interpolation": {
        "scope": "cpp",
        "prefix": [
            "newton-interpolation",
            "newton-interp",
            "interpolation",
            "interp",
        ],
        "body": [
            "template <class T>",
            "class NewtonInterp {",
            "// {(x_0,y_0),(x__1,y_1),...,(x_{n-1},y_{n-1})}",
            "std::vector<std::pair<T, T>> points;",
            "// diffs[r][l] = f[x_l,x_{l+1},...,x_r]",
            "std::vector<std::vector<T>> diffs;",
            "// (x-x_0)(x-x_1)...(x-x_{n-1})",
            "std::vector<T> base;",
            "// f[x_0]+f[x_0,x_1](x-x_0)+...+f[x_0,x_1,...,x_n](x-x_0)(x-x_1)...(x-x_{n-1})",
            "std::vector<T> fit;",
            "public:",
            "explicit NewtonInterp() = default;",
            "NewtonInterp &insert(T const &x, T const &y) {",
            "points.emplace_back(x, y);",
            "size_t n = points.size();",
            "if (n == 1) {",
            "base.push_back(1);",
            "} else {",
            "size_t m = base.size();",
            "base.push_back(0);",
            "for (size_t i = m; i; --i) base[i] = base[i - 1];",
            "base[0] = 0;",
            "for (size_t i = 0; i < m; ++i) base[i] = base[i] - points[n - 2].first * base[i + 1];",
            "}",
            "diffs.emplace_back(points.size());",
            "diffs[n - 1][n - 1] = y;",
            "if (n > 1)",
            "for (size_t i = n - 2; ~i; --i) diffs[n - 1][i] = (diffs[n - 2][i] - diffs[n - 1][i + 1]) / (points[i].first - points[n - 1].first);",
            "fit.push_back(0);",
            "for (size_t i = 0; i < n; ++i) fit[i] = fit[i] + diffs[n - 1][0] * base[i];",
            "return *this;",
            "}",
            "std::vector<T> coeffs() const { return fit; }",
            "T evaluate(T const &x) {",
            "T ans{};",
            "for (auto it = fit.rbegin(); it != fit.rend(); ++it) ans = ans * x + *it;",
            "return ans;",
            "}",
            "};"
        ]
    }
}
{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "barrett": {
        "scope": "cpp",
        "prefix": "barrett",
        "body": [
            "// Reference: https://en.wikipedia.org/wiki/Barrett_reduction",
            "struct Barrett {",
            "uint32_t _m;",
            "uint64_t im;",
            "\n// @param m `1 <= m < 2^31`",
            "constexpr explicit Barrett(uint32_t m): _m(m), im((uint64_t)(-1) / m + 1) {}",
            "\n// @return m",
            "constexpr uint32_t umod() const { return _m; }",
            "\n// @param a `0 <= a < m`",
            "// @param b `0 <= b < m`",
            "// @return `a * b % m`",
            "constexpr uint32_t mul(uint32_t a, uint32_t b) const {",
            "uint64_t z = (uint64_t)(a) * b;",
            "uint32_t v = (uint32_t)(z - (uint64_t)(((u128)(z)*im) >> 64) * _m);",
            "return v + (_m <= v ? _m : 0);",
            "}",
            "};"
        ],
        "description": "Fast modular multiplication by barrett reduction"
    },
    "convolution-fft": {
        "scope": "cpp",
        "prefix": [
            "conv",
            "convolution",
            "convolution-fft",
            "fft-double"
        ],
        "body": [
            "namespace FFT {",
            "using CP = std::complex<double>;",
            "const double PI = acos(-1.0);",
            "size_t n = 0;",
            "std::vector<size_t> rev;",
            "void init(size_t m) {",
            "if (n > m) return;",
            "n = 1;",
            "int k = 0;",
            "while (n <= m) {",
            "n <<= 1;",
            "++k;",
            "}",
            "rev.resize(n);",
            "for (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (k - 1));",
            "}",
            "void dft(std::vector<CP> &a, int op) {",
            "for (int i = 0; i < n; ++i)",
            "if (rev[i] > i) std::swap(a[rev[i]], a[i]);",
            "for (int i = 1; i < n; i <<= 1) {",
            "CP now(std::cos(PI / i), op * std::sin(PI / i));",
            "for (int j = 0, p = (i << 1); j < n; j += p) {",
            "CP w(1, 0);",
            "for (int k = 0; k < i; ++k, w = w * now) {",
            "CP x = a[j + k], y = a[j + k + i] * w;",
            "a[j + k] = x + y;",
            "a[j + k + i] = x - y;",
            "}",
            "}",
            "}",
            "if (op == -1)",
            "for (int i = 0; i < n; ++i) a[i] = {a[i].real() / n, a[i].imag() / n};",
            "}",
            "std::vector<double> conv(std::vector<double> const &a, std::vector<double> const &b) {",
            "init(a.size() + b.size() - 1);",
            "std::vector<CP> a_(n), b_(n), c_(n);",
            "for (size_t i = 0; i < a.size(); ++i) a_[i] = a[i];",
            "for (size_t i = 0; i < b.size(); ++i) b_[i] = b[i];",
            "dft(a_, 1);",
            "dft(b_, 1);",
            "for (size_t i = 0; i < n; ++i) c_[i] = a_[i] * b_[i];",
            "dft(c_, -1);",
            "std::vector<double> c(a.size() + b.size() - 1);",
            "for (size_t i = 0; i < a.size() + b.size() - 1; ++i) c[i] = c_[i].real();",
            "return c;",
            "}",
            "}  // namespace FFT",
            "using FFT::conv;"
        ]
    },
    "exeuclid": {
        "scope": "cpp",
        "prefix": [
            "exeuclid"
        ],
        "body": [
            "namespace exEuclid {",
            "template <class Node>",
            "constexpr Node qpow_(Node a, int64_t b) {",
            "Node res;",
            "for (; b; b >>= 1, a = a + a)",
            "if (b & 1) res = res + a;",
            "return res;",
            "}",
            "template <class Node>",
            "Node solve_(int64_t p, int64_t q, int64_t r, int64_t l, Node a, Node b) {",
            "#pragma GCC diagnostic push",
            "#pragma GCC diagnostic ignored \"-Wfloat-conversion\"",
            "auto div = [](int64_t a, int64_t b, int64_t c, int64_t d) -> int64_t { return (1.l * a * b + c) / d; };",
            "#pragma GCC diagnostic pop",
            "if (!l) return Node();",
            "if (p >= q) return solve_(p % q, q, r, l, a, qpow_(a, p / q) + b);",
            "int64_t m = div(l, p, r, q);",
            "if (!m) return qpow_(b, l);",
            "int64_t cnt = l - div(q, m, -r - 1, p);",
            "return qpow_(b, (q - r - 1) / p) + a + solve_(q, p, (q - r - 1) % p, m - 1, b, a) + qpow_(b, cnt);",
            "}",
            "//! USE THIS",
            "// consider line s: y = (p * x + r) / q, 0 < x <= l",
            "// result will add a when s cross with horizontal line",
            "// result will add b when s cross with vertical line",
            "template <class Node>",
            "constexpr Node solve(int64_t p, int64_t q, int64_t r, int64_t l, Node const &a, Node const &b) { return qpow_(a, r / q) + solve_(p, q, r % q, l, a, b); }",
            "//! USE THIS",
            "// let f(x) = floor((p * x + r) / q)",
            "// @param u (DO NOT EDIT) count of horizontal lines have been crossed",
            "// @param r (DO NOT EDIT) count of vertical lines have been crossed",
            "// @param i sum_i i (needed by i_f)",
            "// @param f sum_i i f(i)",
            "// @param sqr_f sum_i f^2(i)",
            "// @param i_f sum_i i*f(i) (need i)",
            "template <class T = int64_t>",
            "struct Node final {",
            "T u, r;",
            "T i, f, sqr_f, i_f;",
            "Node(T const &u = 0, T const &r = 0, T const &i = 0, T const &f = 0, T const &sqr_f = 0, T const &i_f = 0): u(u), r(r), i(i), f(f), sqr_f(sqr_f), i_f(i_f) {}",
            "Node operator+(Node const &rhs) const {",
            "return Node{u + rhs.u,",
            "r + rhs.r,",
            "i + rhs.i + r * rhs.r,",
            "f + rhs.f + u * rhs.r,",
            "sqr_f + rhs.sqr_f + u * u * rhs.r + 2 * u * rhs.f,",
            "i_f + rhs.i_f + u * r * rhs.r + u * rhs.i + r * rhs.f};",
            "}",
            "};",
            "}  // namespace exEuclid"
        ]
    },
    "lagrange-interpolation-fixed-key": {
        "scope": "cpp",
        "prefix": [
            "lagrange-interpolation-fixed-key"
        ],
        "body": [
            "// calculate f(x) % mod, which f(i) = v[i], i in [0, v.size())",
            "// f(x)=\\sum_{i=0}^{n-1} v_i \\prod_{j\\ne i} \\frac{x-x_j}{x_i-x_j}",
            "//     =\\sum_{i=0}^{n-1} v_i \\prod_{j\\ne i} \\frac{x-j}{i-j}",
            "//     =\\sum_{i=0}^{n-1} (-1)^{n-i-1} v_i \\frac{(\\prod_{j<i} x-j)(\\prod_{j>i} x-j)}{i!(n-i-1)!}",
            "// complexity: O(n)",
            "int64_t lagrange_interp_fixed_key(std::vector<int64_t> const &v, uint64_t x, int64_t mod) {",
            "const size_t n = v.size();",
            "if (x < n) return v[x];",
            "//? pre-proceed",
            "std::vector<int64_t> ifact(n);",
            "ifact[0] = ifact[1] = 1;",
            "for (size_t i = 2; i < n; ++i) ifact[i] = mod - mod / i * ifact[mod % i] % mod;",
            "for (size_t i = 3; i < n; ++i) (ifact[i] *= ifact[i - 1]) %= mod;",
            "//? pre-proceed end",
            "std::vector<int64_t> pre(n);",
            "for (size_t i = 0; i < n; ++i) pre[i] = x - i;",
            "for (size_t i = 1; i < n; ++i) (pre[i] *= pre[i - 1]) %= mod;",
            "std::vector<int64_t> suc(n);",
            "for (size_t i = 0; i < n; ++i) suc[i] = x - i;",
            "for (ptrdiff_t i = n - 2; i >= 0; --i) (suc[i] *= suc[i + 1]) %= mod;",
            "int64_t ans = 0;",
            "for (size_t i = 0; i < n; ++i) {",
            "int64_t _ = v[i];",
            "if (i) _ = _ * pre[i - 1] % mod;",
            "if (i + 1 < n) _ = _ * suc[i + 1] % mod;",
            "_ = _ * ifact[i] % mod * ifact[n - i - 1] % mod;",
            "ans = (ans + ((n - i) % 2 ? _ : mod - _)) % mod;",
            "}",
            "return ans;",
            "}"
        ]
    },
    "mod-int": {
        "scope": "cpp",
        "prefix": "mod-int",
        "body": [
            "//? See <https://atcoder.github.io/ac-library/production/document_en/modint.html>",
            "namespace MODINT {",
            "constexpr int64_t safe_mod(int64_t x, int64_t m) { return (x %= m) < 0 ? x + m : x; }",
            "// @return {gcd(a,b), solution of ax \\equiv 1 \\pmod b$}",
            "constexpr std::pair<int64_t, int64_t> invgcd(int64_t a, int64_t b) {",
            "if ((a = safe_mod(a, b)) == 0) return {b, 0};",
            "int64_t s = b, m0 = 0;",
            "for (int64_t q = 0, _ = 0, m1 = 1; a;) {",
            "_ = s - a * (q = s / a);",
            "s = a;",
            "a = _;",
            "_ = m0 - m1 * q;",
            "m0 = m1;",
            "m1 = _;",
            "}",
            "return {s, m0 + (m0 < 0 ? b / s : 0)};",
            "}",
            "template <uint32_t MOD>",
            "class Mint {",
            "static_assert(MOD >= 1);",
            "using self = Mint<MOD>;",
            "protected:",
            "uint32_t v_;",
            "public:",
            "constexpr static uint32_t mod() { return MOD; }",
            "constexpr static self raw(uint32_t v) {",
            "self x;",
            "x.v_ = v;",
            "return x;",
            "}",
            "constexpr Mint(): v_(0) {}",
            "template <class T, std::enable_if_t<std::is_integral<T>::value && std::is_signed<T>::value> * = nullptr>",
            "constexpr Mint(T v): Mint() {",
            "int64_t x = (int64_t)(v % (int64_t)mod());",
            "v_ = (uint32_t)(x + (x < 0 ? mod() : 0));",
            "}",
            "template <class T, std::enable_if_t<std::is_integral<T>::value && std::is_unsigned<T>::value> * = nullptr>",
            "constexpr Mint(T v): v_((uint32_t)(v % mod())) {}",
            "friend std::istream &operator>>(std::istream &is, self &x) {",
            "int64_t xx;",
            "is >> xx;",
            "xx %= mod();",
            "x.v_ = (uint32_t)(xx + (xx < 0 ? mod() : 0));",
            "return is;",
            "}",
            "friend std::ostream &operator<<(std::ostream &os, const self &x) { return os << x.v_; }",
            "constexpr const uint32_t &val() const { return v_; }",
            "constexpr explicit operator uint32_t() const { return val(); }",
            "constexpr uint32_t &data() { return v_; }",
            "constexpr self &operator++() {",
            "if (++v_ == mod()) v_ = 0;",
            "return *this;",
            "}",
            "constexpr self &operator--() {",
            "if (!v_) v_ = mod();",
            "--v_;",
            "return *this;",
            "}",
            "constexpr self operator++(int) {",
            "self result = *this;",
            "++*this;",
            "return result;",
            "}",
            "constexpr self operator--(int) {",
            "self result = *this;",
            "--*this;",
            "return result;",
            "}",
            "constexpr self &operator+=(const self &rhs) {",
            "v_ += rhs.v_;",
            "if (v_ >= mod()) v_ -= mod();",
            "return *this;",
            "}",
            "constexpr self &operator-=(const self &rhs) {",
            "v_ -= rhs.v_;",
            "if (v_ >= mod()) v_ += mod();",
            "return *this;",
            "}",
            "constexpr self &operator*=(const self &rhs) {",
            "v_ = (uint32_t)((uint64_t)v_ * rhs.v_ % mod());",
            "return *this;",
            "}",
            "constexpr self &operator/=(const self &rhs) { return *this = *this * inverse(rhs); }",
            "constexpr self operator+() const { return *this; }",
            "constexpr self operator-() const { return self() - *this; }",
            "constexpr friend self pow(self x, uint64_t y) {",
            "self res(1);",
            "for (; y; y >>= 1, x *= x)",
            "if (y & 1) res *= x;",
            "return res;",
            "}",
            "constexpr friend self inverse(const self &x) {",
            "auto &&_ = invgcd(x.v_, self::mod());",
            "if (_.first != 1) throw std::runtime_error(\"Inverse not exist\");",
            "return _.second;",
            "}",
            "constexpr friend self operator+(self lhs, const self &rhs) { return lhs += rhs; }",
            "constexpr friend self operator-(self lhs, const self &rhs) { return lhs -= rhs; }",
            "constexpr friend self operator*(self lhs, const self &rhs) { return lhs *= rhs; }",
            "constexpr friend self operator/(self lhs, const self &rhs) { return lhs /= rhs; }",
            "constexpr friend bool operator==(const self &lhs, const self &rhs) { return lhs.v_ == rhs.v_; }",
            "constexpr friend bool operator!=(const self &lhs, const self &rhs) { return lhs.v_ != rhs.v_; }",
            "};",
            "template <ptrdiff_t ID = -1>",
            "class DyMint {",
            "using self = DyMint<ID>;",
            "struct Barrett_ {",
            "uint32_t m_;",
            "uint64_t im;",
            "// @param m `1 <= m < 2^31`",
            "constexpr explicit Barrett_(uint32_t m = 998244353): m_(m), im((uint64_t)(-1) / m + 1) {}",
            "// @return m",
            "constexpr uint32_t umod() const { return m_; }",
            "constexpr uint32_t mul(uint32_t a, uint32_t b) const {",
            "uint64_t z = a;",
            "z *= b;",
            "uint64_t x = (uint64_t)(((__uint128_t)z * im) >> 64);",
            "uint32_t v = (uint32_t)(z - x * m_);",
            "return v + (m_ <= v ? m_ : 0);",
            "}",
            "};",
            "protected:",
            "uint32_t v_;",
            "static inline Barrett_ bt_;",
            "public:",
            "constexpr static uint32_t mod() { return bt_.umod(); }",
            "//! MUST be called first",
            "//! set module with same ID",
            "constexpr static void set_mod(uint32_t m) {",
            "assert(1 <= m);",
            "bt_ = Barrett_(m);",
            "}",
            "constexpr static self raw(uint32_t v) {",
            "self x;",
            "x.v_ = v;",
            "return x;",
            "}",
            "constexpr DyMint(): v_(0) {}",
            "template <class T, std::enable_if_t<std::is_integral<T>::value && std::is_signed<T>::value> * = nullptr>",
            "constexpr DyMint(T v): DyMint() {",
            "int64_t x = (int64_t)(v % (int64_t)mod());",
            "v_ = (uint32_t)(x + (x < 0 ? mod() : 0));",
            "}",
            "template <class T, std::enable_if_t<std::is_integral<T>::value && std::is_unsigned<T>::value> * = nullptr>",
            "constexpr DyMint(T v): v_((uint32_t)(v % mod())) {}",
            "friend std::istream &operator>>(std::istream &is, self &x) {",
            "int64_t xx;",
            "is >> xx;",
            "xx %= mod();",
            "x.v_ = (uint32_t)(xx + (xx < 0 ? mod() : 0));",
            "return is;",
            "}",
            "friend std::ostream &operator<<(std::ostream &os, const self &x) { return os << x.v_; }",
            "constexpr const uint32_t &val() const { return v_; }",
            "constexpr explicit operator uint32_t() const { return val(); }",
            "constexpr uint32_t &data() { return v_; }",
            "constexpr self &operator++() {",
            "if (++v_ == mod()) v_ = 0;",
            "return *this;",
            "}",
            "constexpr self &operator--() {",
            "if (!v_) v_ = mod();",
            "--v_;",
            "return *this;",
            "}",
            "constexpr self operator++(int) {",
            "self result = *this;",
            "++*this;",
            "return result;",
            "}",
            "constexpr self operator--(int) {",
            "self result = *this;",
            "--*this;",
            "return result;",
            "}",
            "constexpr self &operator+=(const self &rhs) {",
            "v_ += rhs.v_;",
            "if (v_ >= mod()) v_ -= mod();",
            "return *this;",
            "}",
            "constexpr self &operator-=(const self &rhs) {",
            "v_ -= rhs.v_;",
            "if (v_ >= mod()) v_ += mod();",
            "return *this;",
            "}",
            "constexpr self &operator*=(const self &rhs) {",
            "v_ = bt_.mul(v_, rhs.v_);",
            "return *this;",
            "}",
            "constexpr self &operator/=(const self &rhs) { return *this = *this * inverse(rhs); }",
            "constexpr self operator+() const { return *this; }",
            "constexpr self operator-() const { return self() - *this; }",
            "constexpr friend self pow(self x, uint64_t y) {",
            "self res(1);",
            "for (; y; y >>= 1, x *= x)",
            "if (y & 1) res *= x;",
            "return res;",
            "}",
            "constexpr friend self inverse(const self &x) {",
            "auto &&_ = invgcd(x.v_, self::mod());",
            "if (_.first != 1) throw std::runtime_error(\"Inverse not exist\");",
            "return _.second;",
            "}",
            "constexpr friend self operator+(self lhs, const self &rhs) { return lhs += rhs; }",
            "constexpr friend self operator-(self lhs, const self &rhs) { return lhs -= rhs; }",
            "constexpr friend self operator*(self lhs, const self &rhs) { return lhs *= rhs; }",
            "constexpr friend self operator/(self lhs, const self &rhs) { return lhs /= rhs; }",
            "constexpr friend bool operator==(const self &lhs, const self &rhs) { return lhs.v_ == rhs.v_; }",
            "constexpr friend bool operator!=(const self &lhs, const self &rhs) { return lhs.v_ != rhs.v_; }",
            "};",
            "}  // namespace MODINT",
            "using MODINT::DyMint;",
            "using MODINT::Mint;",
            "using mint998244353 = Mint<998244353>;",
            "using mint1e9a7 = Mint<1000000007>;",
            "using dmint = DyMint<>;",
            "// namespace std {",
            "// template <uint32_t MOD>",
            "// uint32_t abs(Mint<MOD> x) { return x.data(); }",
            "// template <ptrdiff_t ID>",
            "// uint32_t abs(DyMint<ID> x) { return x.data(); }",
            "// }  // namespace std"
        ]
    },
    "newton-interpolation": {
        "scope": "cpp",
        "prefix": [
            "newton-interpolation",
            "newton-interp",
            "interpolation",
            "interp",
        ],
        "body": [
            "template <class T>",
            "class NewtonInterp {",
            "// {(x_0,y_0),(x__1,y_1),...,(x_{n-1},y_{n-1})}",
            "std::vector<std::pair<T, T>> points;",
            "// diffs[r][l] = f[x_l,x_{l+1},...,x_r]",
            "std::vector<std::vector<T>> diffs;",
            "// (x-x_0)(x-x_1)...(x-x_{n-1})",
            "std::vector<T> base;",
            "// f[x_0]+f[x_0,x_1](x-x_0)+...+f[x_0,x_1,...,x_n](x-x_0)(x-x_1)...(x-x_{n-1})",
            "std::vector<T> fit;",
            "public:",
            "explicit NewtonInterp() = default;",
            "NewtonInterp &insert(T const &x, T const &y) {",
            "points.emplace_back(x, y);",
            "size_t n = points.size();",
            "if (n == 1) {",
            "base.push_back(1);",
            "} else {",
            "size_t m = base.size();",
            "base.push_back(0);",
            "for (size_t i = m; i; --i) base[i] = base[i - 1];",
            "base[0] = 0;",
            "for (size_t i = 0; i < m; ++i) base[i] = base[i] - points[n - 2].first * base[i + 1];",
            "}",
            "diffs.emplace_back(points.size());",
            "diffs[n - 1][n - 1] = y;",
            "if (n > 1)",
            "for (size_t i = n - 2; ~i; --i) diffs[n - 1][i] = (diffs[n - 2][i] - diffs[n - 1][i + 1]) / (points[i].first - points[n - 1].first);",
            "fit.push_back(0);",
            "for (size_t i = 0; i < n; ++i) fit[i] = fit[i] + diffs[n - 1][0] * base[i];",
            "return *this;",
            "}",
            "std::vector<T> coeffs() const { return fit; }",
            "T evaluate(T const &x) {",
            "T ans{};",
            "for (auto it = fit.rbegin(); it != fit.rend(); ++it) ans = ans * x + *it;",
            "return ans;",
            "}",
            "};"
        ]
    },
    "real-basis": {
        "scope": "cpp",
        "prefix": "real-basis",
        "body": [
            "template <std::size_t N = 64>",
            "class RealBasis {",
            "using self = RealBasis<N>;",
            "using field_t = double;",
            "using vector_t = std::array<field_t, N>;",
            "using reference = self &;",
            "using iterator = vector_t *;",
            "using const_iterator = vector_t *;",
            "using reverse_iterator = std::reverse_iterator<iterator>;",
            "using const_reverse_iterator = std::reverse_iterator<const_iterator>;",
            "public:",
            "const field_t EPS;",
            "protected:",
            "vector_t base[N];",
            "bool is_zero(field_t x) const { return std::abs(x) < EPS; }",
            "public:",
            "constexpr explicit RealBasis(field_t EPS_ = 1e-4): EPS(EPS_) { this->clear(); }",
            "constexpr RealBasis(std::initializer_list<vector_t> _list): RealBasis() {",
            "for (auto &&i : _list) this->insert(i);",
            "}",
            "constexpr void clear() {",
            "for (size_t i = 0; i < size(); ++i) base[i].fill(0);",
            "}",
            "constexpr size_t size() const { return N; }",
            "constexpr vector_t &operator[](size_t index) { return this->base[index]; }",
            "constexpr vector_t &operator[](size_t index) const { return const_cast<self * const>(this)->base[index]; }",
            "constexpr iterator begin() { return this->base; }",
            "constexpr const_iterator begin() const { return const_cast<vector_t * const>(this->base); }",
            "constexpr iterator end() { return this->begin() + this->size(); }",
            "constexpr const_iterator end() const { return this->begin() + this->size(); }",
            "reverse_iterator rbegin() { return reverse_iterator(this->end()); }",
            "const_reverse_iterator rbegin() const { return const_reverse_iterator(this->end()); }",
            "reverse_iterator rend() { return reverse_iterator(this->begin()); }",
            "const_reverse_iterator rend() const { return const_reverse_iterator(this->begin()); }",
            "constexpr bool insert(vector_t x) {",
            "bool status = false;",
            "for (size_t i = size() - 1; ~i; --i) {",
            "if (is_zero(x[i])) continue;",
            "if (!is_zero(base[i][i])) {",
            "field_t __ = x[i] / base[i][i];",
            "x[i] = 0;",
            "for (size_t j = 0; j < i; ++j) x[j] -= base[i][j] * __;",
            "} else {",
            "for (size_t j = 0; j < i; ++j)",
            "if (!is_zero(x[j]) && !is_zero(base[j][j])) {",
            "field_t __ = x[j] / base[j][j];",
            "x[j] = 0;",
            "for (size_t k = 0; k < j; ++k) x[k] -= base[j][k] * __;",
            "}",
            "for (size_t j = i + 1; j < size(); ++j)",
            "if (!is_zero(base[j][i]) && !is_zero(x[i])) {",
            "field_t __ = base[j][i] / x[i];",
            "base[j][i] = 0;",
            "for (size_t k = 0; k < i; ++k) base[j][k] -= x[k] * __;",
            "}",
            "base[i] = x;",
            "status = true;",
            "break;",
            "}",
            "}",
            "return status;",
            "}",
            "constexpr size_t rank() const {",
            "size_t res = 0;",
            "for (size_t i = 0; i < size(); ++i) res += !is_zero(base[i][i]);",
            "return res;",
            "}",
            "// @return std::nullopt if x is linear independent with current basis, else return the solution",
            "constexpr std::optional<vector_t> coordinate(vector_t x) {",
            "vector_t res;",
            "for (size_t i = size() - 1; ~i; --i)",
            "if (!is_zero(x[i])) {",
            "if (is_zero(base[i][i])) return std::nullopt;",
            "field_t __ = x[i] / base[i][i];",
            "res[i] = __;",
            "x[i] = 0;",
            "for (size_t j = 0; j <= i; ++j) x[j] -= base[i][j] * __;",
            "}",
            "return res;",
            "}",
            "};"
        ]
    },
    "romberg": {
        "scope": "cpp",
        "prefix": "romberg",
        "body": [
            "class RombergSolver {",
            "private:",
            "std::function<double(double)> f;",
            "double ctqf(double a, double b, double h) const {",
            "double ans = 0;",
            "for (double i = a + h * .5; i < b; i += h) ans += f(i);",
            "return ans;",
            "}",
            "public:",
            "template <typename Func>",
            "RombergSolver(Func &&func): f(func) {}",
            "double operator()(double a, double b, double eps) const {",
            "double h = b - a;",
            "double T1 = (f(a) + f(b)) * h * .5, T2 = 0, S1 = 0, S2 = 0, C1 = 0, C2 = 0, R1 = 0, R2 = 0;",
            "for (int k = 1; k < 4; h *= .5, ++k) {",
            "T2 = (T1 + h * ctqf(a, b, h)) * .5;",
            "S2 = (4 * T2 - T1) / 3;",
            "T1 = T2;",
            "if (k == 1) {",
            "S1 = S2;",
            "continue;",
            "};",
            "C2 = (16 * S2 - S1) / 15;",
            "if (k == 2) {",
            "C1 = C2;",
            "continue;",
            "};",
            "R1 = (64 * C2 - C1) / 63;",
            "}",
            "for (;; h /= 2, T1 = T2, S1 = S2, C1 = C2, R1 = R2)",
            "if (std::abs(R1 - (R2 = (64 * (C2 = (16 * (S2 = (4 * (T2 = (T1 + h * ctqf(a, b, h)) * .5) - T1) / 3) - S1) / 15) - C1) / 63)) < eps) break;",
            "return R2;",
            "}",
            "};"
        ]
    },
    "simpson": {
        "scope": "cpp",
        "prefix": "simpson",
        "body": [
            "class SimpsonSolver {",
            "private:",
            "std::function<double(double)> f;",
            "constexpr static double simpson(double l, double r, double fl, double fmid, double fr) { return (fl + 4 * fmid + fr) * (r - l) / 6; }",
            "double asr(double l, double r, double area, double eps) const {",
            "double mid = r - (r - l) * .5;",
            "double lmid = mid - (mid - l) * .5, rmid = r - (r - mid) * .5;",
            "double fl = f(l), flmid = f(lmid), fmid = f(mid), frmid = f(rmid), fr = f(r);",
            "double ls = simpson(l, mid, fl, flmid, fmid), rs = simpson(mid, r, fmid, frmid, fr);",
            "if (std::abs(ls + rs - area) <= 15 * eps) return ls + rs + (ls + rs - area) / 15;",
            "return asr(l, mid, ls, eps * .5) + asr(mid, r, rs, eps * .5);",
            "}",
            "double asr(double l, double r, double area, double eps, double dep) const {",
            "double mid = r - (r - l) * .5;",
            "double lmid = mid - (mid - l) * .5, rmid = r - (r - mid) * .5;",
            "double fl = f(l), flmid = f(lmid), fmid = f(mid), frmid = f(rmid), fr = f(r);",
            "double ls = simpson(l, mid, fl, flmid, fmid), rs = simpson(mid, r, fmid, frmid, fr);",
            "if (std::abs(ls + rs - area) <= 15 * eps && dep <= 0) return ls + rs + (ls + rs - area) / 15;",
            "return asr(l, mid, ls, eps * .5, dep - 1) + asr(mid, r, rs, eps * .5, dep - 1);",
            "}",
            "public:",
            "template <typename Func>",
            "SimpsonSolver(Func &&func): f(func) {}",
            "double operator()(double l, double r, double eps) const { return asr(l, r, simpson(l, r, f(l), f(r - (r - l) * .5), f(r)), eps); }",
            "double operator()(double l, double r, double eps, double min_dep) const { return asr(l, r, simpson(l, r, f(l), f(r - (r - l) * .5), f(r)), eps, min_dep); }",
            "};"
        ]
    },
    "xor-basis": {
        "scope": "cpp",
        "prefix": "xor-basis",
        "body": [
            "template <std::size_t N = 64>",
            "class XorBasis {",
            "using self = XorBasis<N>;",
            "using field_t = bool;",
            "using vector_t = std::bitset<N>;",
            "using reference = self &;",
            "using iterator = vector_t *;",
            "using const_iterator = vector_t *;",
            "using reverse_iterator = std::reverse_iterator<iterator>;",
            "using const_reverse_iterator = std::reverse_iterator<const_iterator>;",
            "protected:",
            "vector_t base[N];",
            "public:",
            "constexpr XorBasis() { this->clear(); }",
            "constexpr XorBasis(std::initializer_list<vector_t> _list): XorBasis() {",
            "for (auto &&i : _list) this->insert(i);",
            "}",
            "constexpr void clear() {",
            "for (size_t i = 0; i < size(); ++i) base[i].reset();",
            "}",
            "constexpr size_t size() const { return N; }",
            "constexpr vector_t &operator[](size_t index) { return this->base[index]; }",
            "constexpr vector_t &operator[](size_t index) const { return const_cast<self * const>(this)->base[index]; }",
            "constexpr iterator begin() { return this->base; }",
            "constexpr const_iterator begin() const { return const_cast<vector_t * const>(this->base); }",
            "constexpr iterator end() { return this->begin() + this->size(); }",
            "constexpr const_iterator end() const { return this->begin() + this->size(); }",
            "reverse_iterator rbegin() { return reverse_iterator(this->end()); }",
            "const_reverse_iterator rbegin() const { return const_reverse_iterator(this->end()); }",
            "reverse_iterator rend() { return reverse_iterator(this->begin()); }",
            "const_reverse_iterator rend() const { return const_reverse_iterator(this->begin()); }",
            "constexpr bool insert(vector_t x) {",
            "bool status = false;",
            "for (size_t i = size() - 1; ~i; --i) {",
            "if (!(x[i])) continue;",
            "if (base[i][i])",
            "x ^= base[i];",
            "else {",
            "for (size_t j = 0; j < i; ++j)",
            "if (x[j]) x ^= base[j];",
            "for (size_t j = i + 1; j < size(); ++j)",
            "if (base[j][i]) base[j] ^= x;",
            "base[i] = x;",
            "status = true;",
            "break;",
            "}",
            "}",
            "return status;",
            "}",
            "constexpr vector_t max_span() const {",
            "vector_t ret;",
            "for (const auto &i : *this) ret ^= i;",
            "return ret;",
            "}",
            "constexpr size_t rank() const {",
            "size_t res = 0;",
            "for (size_t i = 0; i < size(); ++i) res += base[i][i];",
            "return res;",
            "}",
            "// @return std::nullopt if x is linear independent with current basis, else return the solution",
            "constexpr std::optional<vector_t> coordinate(vector_t x) {",
            "vector_t res;",
            "for (size_t i = size() - 1; ~i; --i)",
            "if (x[i]) {",
            "if (!base[i][i]) return std::nullopt;",
            "res.set(i);",
            "x ^= base[i];",
            "}",
            "return res;",
            "}",
            "};"
        ]
    }
}
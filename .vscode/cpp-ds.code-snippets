{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "persistable-segtree": {
        "scope": "cpp",
        "prefix": [
            "psegtree",
            "p-segtree"
        ],
        "body": [
            "template <typename Tp>",
            "class persistable_seg_tree {",
            "static const size_t MRATE = 24;",
            "using self = persistable_seg_tree<Tp>;",
            "using data_t = Tp;",
            "using index_t = size_t;",
            "protected:",
            "struct node_t {",
            "data_t data;",
            "index_t l, r;",
            "node_t(data_t const &data_ = data_t(0), index_t l_ = 0, index_t r_ = 0): data(data_), l(l_), r(r_) {}",
            "};",
            "index_t data_sz;",
            "std::vector<node_t> nodes;",
            "std::vector<index_t> roots;",
            "void _init(index_t const &l, index_t const &r, std::vector<data_t> const &a, index_t &now) {",
            "now = nodes.size();",
            "nodes.emplace_back(data_t(0), nodes.size(), nodes.size());",
            "if (l == r) {",
            "nodes[now].data = a[l];",
            "return;",
            "}",
            "index_t mid = l + ((r - l) >> 1);",
            "_init(l, mid, a, nodes[now].l);",
            "_init(mid + 1, r, a, nodes[now].r);",
            "}",
            "void _modify(index_t const &l, index_t const &r, index_t &now, index_t const &pre, index_t const &pos, data_t const &k) {",
            "now = nodes.size();",
            "nodes.push_back(nodes[pre]);",
            "if (l == r) {",
            "nodes[now].data = k;",
            "return;",
            "}",
            "index_t mid = l + ((r - l) >> 1);",
            "if (pos <= mid)",
            "_modify(l, mid, nodes[now].l, nodes[pre].l, pos, k);",
            "else",
            "_modify(mid + 1, r, nodes[now].r, nodes[pre].r, pos, k);",
            "}",
            "data_t const &_query(index_t const &now, index_t const &l, index_t const &r, index_t const &pos) const {",
            "if (l == r) return nodes[now].data;",
            "index_t mid = l + ((r - l) >> 1);",
            "if (pos <= mid)",
            "return _query(nodes[now].l, l, mid, pos);",
            "else",
            "return _query(nodes[now].r, mid + 1, r, pos);",
            "}",
            "public:",
            "constexpr explicit persistable_seg_tree(index_t const &_size): data_sz(_size), nodes(1), roots(1) { nodes.reserve(data_sz * MRATE); }",
            "//! index starts at 1",
            "explicit persistable_seg_tree(std::vector<data_t> const &data_array): persistable_seg_tree(data_array.size() - 1) { _init(1, data_sz, data_array, roots.back()); }",
            "self &clear() {",
            "nodes.clear();",
            "roots.clear();",
            "return *this;",
            "}",
            "constexpr index_t data_size() const { return this->data_sz; }",
            "constexpr index_t node_size() const { return nodes.size(); }",
            "constexpr index_t version_size() const { return roots.size(); }",
            "self &modify(index_t const &version, index_t const &pos, data_t const &data) {",
            "roots.push_back(0);",
            "_modify(1, data_sz, roots.back(), roots[version], pos, data);",
            "return *this;",
            "}",
            "data_t const &query(index_t const &version, index_t const &pos) {",
            "roots.push_back(roots[version]);",
            "return _query(roots[version], 1, data_sz, pos);",
            "}",
            "size_t memory_used() const { return sizeof(nodes[0]) * nodes.capacity() + sizeof(roots[0]) * roots.capacity(); }",
            "};"
        ]
    },
    "sqrt-bucket": {
        "scope": "cpp",
        "prefix": [
            "blocking",
            "sqrt-blocking",
            "sqrt-bucket"
        ],
        "body": [
            "namespace SqrtBucket {",
            "template <class Tp, typename Ext>",
            "struct BlockInfo final {",
            "using self = BlockInfo<Tp, Ext>;",
            "const size_t l, r;",
            "Tp result;",
            "const std::function<void(self &, std::vector<Tp> &)> bfunc;",
            "Ext ext;",
            "//! Info of range [l, r]",
            "// @param bfunc build function: bfunc(blk, data)",
            "BlockInfo(size_t l, size_t r, std::vector<Tp> &data, std::function<void(self &, std::vector<Tp> &)> bfunc): l(l), r(r), result(), bfunc(bfunc), ext() { bfunc(*this, data); }",
            "void refresh(std::vector<Tp> &data) { bfunc(*this, data); }",
            "};",
            "template <class Tp>",
            "struct BlockInfo<Tp, void> final {",
            "using self = BlockInfo<Tp, void>;",
            "const size_t l, r;",
            "Tp result;",
            "const std::function<void(self &, std::vector<Tp> &)> bfunc;",
            "//! Info of range [l, r]",
            "// @param bfunc build function: bfunc(blk, data)",
            "BlockInfo(size_t l, size_t r, std::vector<Tp> &data, std::function<void(self &, std::vector<Tp> &)> bfunc): l(l), r(r), result(), bfunc(bfunc) { bfunc(*this, data); }",
            "void refresh(std::vector<Tp> &data) { bfunc(*this, data); }",
            "};",
            "// @param Tp: element type",
            "// @param Ext: type of extra data for each block, change this if necearry",
            "template <typename Tp, typename Ext = void>",
            "class Bucket {",
            "public:",
            "using self = Bucket<Tp, Ext>;",
            "using BInfo = BlockInfo<Tp, Ext>;",
            "protected:",
            "const size_t bsize;",
            "protected:",
            "std::vector<Tp> data;",
            "std::vector<BInfo> blk;",
            "public:",
            "// @param bfunc build function: bfunc(blk, data)",
            "Bucket(",
            "size_t bsize,",
            "std::vector<Tp> const &data_,",
            "std::function<void(BInfo &, std::vector<Tp> const &)> bfunc): bsize(bsize), data(data_), blk() {",
            "assert(data.size() > 0);",
            "size_t _ = (data.size() + bsize - 1) / bsize;",
            "blk.reserve(_);",
            "for (size_t i = 0; i < _; ++i) blk.emplace_back(i * bsize, std::min(data.size(), (i + 1) * bsize) - 1, data, bfunc);",
            "}",
            "//! range: [l, r]",
            "// @param usfunc update function for single element: usfunc(blk, data, xl, xr); update [xl, xr] in blk and data, which xl and xr are absolute indexes",
            "// @param ubfunc update function for block: ubfunc(blk, data); update blk",
            "template <class USFunc = std::function<void(BInfo &, std::vector<Tp> &, size_t, size_t)>, class UBFunc = std::function<void(BInfo &, std::vector<Tp> &)>>",
            "self &update(size_t l, size_t r, USFunc usfunc, UBFunc ubfunc) {",
            "ptrdiff_t bl = (l + bsize - 1) / bsize, br = (r + 1) / bsize - 1;",
            "for (ptrdiff_t i = bl; i <= br; ++i) ubfunc(blk[i], data);",
            "if (r < bl * bsize) {",
            "usfunc(blk[bl - 1], data, l, r);",
            "} else {",
            "if (l < bl * bsize) usfunc(blk[bl - 1], data, l, bl * bsize - 1);",
            "if ((br + 1) * bsize <= r) usfunc(blk[br + 1], data, (br + 1) * bsize, r);",
            "}",
            "return *this;",
            "}",
            "};",
            "}  // namespace SqrtBucket",
            "using SqrtBucket::Bucket;",
        ]
    },
    "UDHeap": {
        "scope": "cpp",
        "prefix": "udheap",
        "body": [
            "template <class Tp>",
            "class UDHeap {",
            "private:",
            "std::priority_queue<Tp> dq;",
            "std::priority_queue<Tp, std::vector<Tp>, std::greater<Tp>> uq;",
            "\npublic:",
            "using self = UDHeap<Tp>;",
            "UDHeap() {}",
            "self &clear() {",
            "while (!dq.empty()) dq.pop();",
            "while (!uq.empty()) uq.pop();",
            "return *this;",
            "}",
            "self &insert(const Tp &x) {",
            "if (dq.empty() && uq.empty()) {",
            "dq.push(x);",
            "return *this;",
            "}",
            "(x > dq.top() ? uq.push(x) : dq.push(x));",
            "if (uq.size() > dq.size() + 1) {",
            "dq.push(uq.top());",
            "uq.pop();",
            "} else if (dq.size() > uq.size() + 1) {",
            "uq.push(dq.top());",
            "dq.pop();",
            "}",
            "return *this;",
            "}",
            "Tp get_mid() const { return uq.size() > dq.size() ? uq.top() : dq.top(); }",
            "self &pop_mid() {",
            "uq.size() > dq.size() ? uq.pop() : dq.pop();",
            "return *this;",
            "}",
            "};"
        ]
    }
}
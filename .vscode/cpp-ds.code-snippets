{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "balanced-tree-based-on-fenwick-tree": {
        "scope": "cpp",
        "prefix": [
            "bst-bit",
            "bt-bit"
        ],
        "body": [
            "//! based on BIT, need discretization before using",
            "template <uint64_t N>",
            "class BT: public BIT<N, uint64_t> {",
            "protected:",
            "const static uint64_t LOG_N = std::ceil(std::log2(N));",
            "uint64_t sum(uint64_t pos) const { uint64_t ret = 0; for (uint64_t i = pos; i; i = (int64_t)i - lowbit(i)) ret += tree[i]; return ret; }",
            "uint64_t query_rk(uint64_t pos) const {",
            "uint64_t idx = 0;",
            "for (uint64_t i = LOG_N; ~i; --i) {",
            "idx += 1 << i;",
            "if (idx >= N || tree[idx] >= pos idx -= 1 << i;",
            "else pos -= tree[idx];",
            "}",
            "return idx + 1;",
            "}",
            "public:",
            "BT() = default;",
            "void insert(uint64_t pos) { modify(pos); }",
            "void remove(uint64_t pos) { modify(pos, -1); }",
            "uint64_t kth_num(uint64_t k) const { return query_rk(k); }",
            "};"
        ]
    },
    "persistable-segtree": {
        "scope": "cpp",
        "prefix": [
            "psegtree",
            "p-segtree"
        ],
        "body": [
            "template <typename Tp>",
            "class persistable_seg_tree {",
            "static const size_t MRATE = 24;",
            "using self = persistable_seg_tree<Tp>;",
            "using data_t = Tp;",
            "using index_t = size_t;",
            "protected:",
            "struct node_t {",
            "data_t data;",
            "index_t l, r;",
            "node_t(data_t const &data_ = data_t(0), index_t l_ = 0, index_t r_ = 0): data(data_), l(l_), r(r_) {}",
            "};",
            "index_t data_sz;",
            "std::vector<node_t> nodes;",
            "std::vector<index_t> roots;",
            "void _init(index_t const &l, index_t const &r, std::vector<data_t> const &a, index_t &now) {",
            "now = nodes.size();",
            "nodes.emplace_back(data_t(0), nodes.size(), nodes.size());",
            "if (l == r) {",
            "nodes[now].data = a[l];",
            "return;",
            "}",
            "index_t mid = l + ((r - l) >> 1);",
            "_init(l, mid, a, nodes[now].l);",
            "_init(mid + 1, r, a, nodes[now].r);",
            "}",
            "void _modify(index_t const &l, index_t const &r, index_t &now, index_t const &pre, index_t const &pos, data_t const &k) {",
            "now = nodes.size();",
            "nodes.push_back(nodes[pre]);",
            "if (l == r) {",
            "nodes[now].data = k;",
            "return;",
            "}",
            "index_t mid = l + ((r - l) >> 1);",
            "if (pos <= mid)",
            "_modify(l, mid, nodes[now].l, nodes[pre].l, pos, k);",
            "else",
            "_modify(mid + 1, r, nodes[now].r, nodes[pre].r, pos, k);",
            "}",
            "data_t const &_query(index_t const &now, index_t const &l, index_t const &r, index_t const &pos) const {",
            "if (l == r) return nodes[now].data;",
            "index_t mid = l + ((r - l) >> 1);",
            "if (pos <= mid)",
            "return _query(nodes[now].l, l, mid, pos);",
            "else",
            "return _query(nodes[now].r, mid + 1, r, pos);",
            "}",
            "public:",
            "constexpr explicit persistable_seg_tree(index_t const &_size): data_sz(_size), nodes(1), roots(1) { nodes.reserve(data_sz * MRATE); }",
            "//! index starts at 1",
            "explicit persistable_seg_tree(std::vector<data_t> const &data_array): persistable_seg_tree(data_array.size() - 1) { _init(1, data_sz, data_array, roots.back()); }",
            "self &clear() {",
            "nodes.clear();",
            "roots.clear();",
            "return *this;",
            "}",
            "constexpr index_t data_size() const { return this->data_sz; }",
            "constexpr index_t node_size() const { return nodes.size(); }",
            "constexpr index_t version_size() const { return roots.size(); }",
            "self &modify(index_t const &version, index_t const &pos, data_t const &data) {",
            "roots.push_back(0);",
            "_modify(1, data_sz, roots.back(), roots[version], pos, data);",
            "return *this;",
            "}",
            "data_t const &query(index_t const &version, index_t const &pos) {",
            "roots.push_back(roots[version]);",
            "return _query(roots[version], 1, data_sz, pos);",
            "}",
            "size_t memory_used() const { return sizeof(nodes[0]) * nodes.capacity() + sizeof(roots[0]) * roots.capacity(); }",
            "};"
        ]
    },
    "RMQ-ST-2D": {
        "scope": "cpp",
        "prefix": [
            "rmq-2d",
            "rmq-st-2d"
        ],
        "body": [
            "template <typename data_t, typename query_func = std::function<data_t(const data_t &, const data_t &)>>",
            "class RMQ_ST_2D {",
            "protected:",
            "query_func qfunc;",
            "std::vector<std::vector<std::vector<data_t>>> f;",
            "public:",
            "RMQ_ST_2D() = delete;",
            "// @param ifunc ifunc(x, y) = value in (x, y)",
            "RMQ_ST_2D(query_func qfunc): qfunc(qfunc), f() {}",
            "//! [0, n) * [0, m)",
            "template <typename init_func = std::function<data_t(size_t, size_t)>>",
            "void init(size_t n, size_t m, init_func ifunc) {",
            "const size_t K = (size_t)std::log2(std::max(n, m)) + 1;",
            "f.resize(K);",
            "for (auto &i : f) {",
            "i.resize(n);",
            "for (auto &j : i) j.resize(m);",
            "}",
            "for (size_t i = 0; i < n; ++i)",
            "for (size_t j = 0; j < m; ++j) f[0][i][j] = ifunc(i, j);",
            "for (size_t k = 1, p = 1, q = 2; k < K; ++k, p = q, q *= 2)",
            "for (int i = 0; i + q - 1 < n; ++i)",
            "for (int j = 0; j + q - 1 < m; ++j)",
            "f[k][i][j] = qfunc(qfunc(f[k - 1][i][j], f[k - 1][i + p][j]), qfunc(f[k - 1][i][j + p], f[k - 1][i + p][j + p]));",
            "}",
            "//! [x, x + l) * [y, y + l)",
            "data_t query(size_t x, size_t y, size_t l) const {",
            "size_t _ = (size_t)std::log2(l);",
            "return qfunc(qfunc(f[_][x][y], f[_][x + l - (1 << _)][y]), qfunc(f[_][x][y + l - (1 << _)], f[_][x + l - (1 << _)][y + l - (1 << _)]));",
            "}",
            "};"
        ]
    },
    "sqrt-bucket": {
        "scope": "cpp",
        "prefix": [
            "blocking",
            "sqrt-blocking",
            "sqrt-bucket"
        ],
        "body": [
            "namespace SqrtBucket {",
            "template <class Tp, typename Ext>",
            "struct BlockInfo final {",
            "using self = BlockInfo<Tp, Ext>;",
            "const size_t l, r;",
            "Tp result;",
            "const std::function<void(self &, std::vector<Tp> &)> bfunc;",
            "Ext ext;",
            "//! Info of range [l, r]",
            "// @param bfunc build function: bfunc(blk, data)",
            "BlockInfo(size_t l, size_t r, std::vector<Tp> &data, std::function<void(self &, std::vector<Tp> &)> bfunc): l(l), r(r), result(), bfunc(bfunc), ext() { bfunc(*this, data); }",
            "void refresh(std::vector<Tp> &data) { bfunc(*this, data); }",
            "};",
            "template <class Tp>",
            "struct BlockInfo<Tp, void> final {",
            "using self = BlockInfo<Tp, void>;",
            "const size_t l, r;",
            "Tp result;",
            "const std::function<void(self &, std::vector<Tp> &)> bfunc;",
            "//! Info of range [l, r]",
            "// @param bfunc build function: bfunc(blk, data)",
            "BlockInfo(size_t l, size_t r, std::vector<Tp> &data, std::function<void(self &, std::vector<Tp> &)> bfunc): l(l), r(r), result(), bfunc(bfunc) { bfunc(*this, data); }",
            "void refresh(std::vector<Tp> &data) { bfunc(*this, data); }",
            "};",
            "// @param Tp: element type",
            "// @param Ext: type of extra data for each block, change this if necearry",
            "template <typename Tp, typename Ext = void>",
            "class Bucket {",
            "public:",
            "using self = Bucket<Tp, Ext>;",
            "using BInfo = BlockInfo<Tp, Ext>;",
            "protected:",
            "const size_t bsize;",
            "protected:",
            "std::vector<Tp> data;",
            "std::vector<BInfo> blk;",
            "public:",
            "// @param bfunc build function: bfunc(blk, data)",
            "Bucket(",
            "size_t bsize,",
            "std::vector<Tp> const &data_,",
            "std::function<void(BInfo &, std::vector<Tp> const &)> bfunc): bsize(bsize), data(data_), blk() {",
            "assert(data.size() > 0);",
            "size_t _ = (data.size() + bsize - 1) / bsize;",
            "blk.reserve(_);",
            "for (size_t i = 0; i < _; ++i) blk.emplace_back(i * bsize, std::min(data.size(), (i + 1) * bsize) - 1, data, bfunc);",
            "}",
            "//! range: [l, r]",
            "// @param usfunc update function for single element: usfunc(blk, data, xl, xr); update [xl, xr] in blk and data, which xl and xr are absolute indexes",
            "// @param ubfunc update function for block: ubfunc(blk, data); update blk",
            "template <class USFunc = std::function<void(BInfo &, std::vector<Tp> &, size_t, size_t)>, class UBFunc = std::function<void(BInfo &, std::vector<Tp> &)>>",
            "self &update(size_t l, size_t r, USFunc usfunc, UBFunc ubfunc) {",
            "ptrdiff_t bl = (l + bsize - 1) / bsize, br = (r + 1) / bsize - 1;",
            "for (ptrdiff_t i = bl; i <= br; ++i) ubfunc(blk[i], data);",
            "if (r < bl * bsize) {",
            "usfunc(blk[bl - 1], data, l, r);",
            "} else {",
            "if (l < bl * bsize) usfunc(blk[bl - 1], data, l, bl * bsize - 1);",
            "if ((br + 1) * bsize <= r) usfunc(blk[br + 1], data, (br + 1) * bsize, r);",
            "}",
            "return *this;",
            "}",
            "};",
            "}  // namespace SqrtBucket",
            "using SqrtBucket::Bucket;",
        ]
    },
    "treap-no-rotate": {
        "scope": "cpp",
        "prefix": [
            "fhqtreap",
            "treap-nr",
            "treap-no-rotate"
        ],
        "body": [
            "// Treap without rotate",
            "template <class Tp>",
            "class TreapNR {",
            "static_assert(!std::is_unsigned<Tp>::value, \"Tp should not be unsigned\");",
            "using self = TreapNR<Tp>;",
            "protected:",
            "struct Node {",
            "Node *l, *r;",
            "uint_fast64_t rid;",
            "size_t cnt, sz;",
            "Tp val;",
            "Node(uint_fast64_t rid, Tp val): l(nullptr), r(nullptr), rid(rid), cnt(1), sz(1), val(val) {}",
            "explicit Node(Node *rhs): rid(rhs->rid), cnt(rhs->cnt), sz(rhs->sz), val(rhs->val) {}",
            "constexpr void update() {",
            "sz = cnt;",
            "if (l != nullptr) sz += l->sz;",
            "if (r != nullptr) sz += r->sz;",
            "}",
            "};",
            "std::pair<Node *, Node *> split(Node *cur, Tp const &val) {",
            "if (cur == nullptr) return {nullptr, nullptr};",
            "if (val < cur->val) {",
            "auto _ = split(cur->l, val);",
            "cur->l = _.second;",
            "cur->update();",
            "return {_.first, cur};",
            "} else {",
            "auto _ = split(cur->r, val);",
            "cur->r = _.first;",
            "cur->update();",
            "return {cur, _.second};",
            "}",
            "}",
            "std::tuple<Node *, Node *, Node *> split_by_rk(Node *cur, size_t rk) {",
            "if (cur == nullptr) return {nullptr, nullptr, nullptr};",
            "size_t szl = cur->l == nullptr ? 0 : cur->l->sz;",
            "if (rk <= szl) {",
            "auto _ = split_by_rk(cur->l, rk);",
            "cur->l = std::get<2>(_);",
            "cur->update();",
            "return {std::get<0>(_), std::get<1>(_), cur};",
            "} else if (rk <= szl + cur->cnt) {",
            "Node *lt = cur->l, *rt = cur->r;",
            "cur->l = cur->r = nullptr;",
            "return {lt, cur, rt};",
            "} else {",
            "auto _ = split_by_rk(cur->r, rk - szl - cur->cnt);",
            "cur->r = std::get<0>(_);",
            "cur->update();",
            "return {cur, std::get<1>(_), std::get<2>(_)};",
            "}",
            "}",
            "Node *merge(Node *u, Node *v) {",
            "if (u == nullptr && v == nullptr) return nullptr;",
            "if (u != nullptr && v == nullptr) return u;",
            "if (v != nullptr && u == nullptr) return v;",
            "if (u->rid < v->rid) {",
            "u->r = merge(u->r, v);",
            "u->update();",
            "return u;",
            "} else {",
            "v->l = merge(u, v->l);",
            "v->update();",
            "return v;",
            "}",
            "}",
            "size_t rank_(Node *cur, Tp const &val) {",
            "auto _ = split(cur, val - 1);",
            "size_t ret = (_.first == nullptr ? 0 : _.first->sz) + 1;",
            "root = merge(_.first, _.second);",
            "return ret;",
            "}",
            "Tp val_(Node *cur, size_t rk) {",
            "auto _ = split_by_rk(cur, rk);",
            "Tp ret = std::get<1>(_)->val;",
            "root = merge(std::get<0>(_), merge(std::get<1>(_), std::get<2>(_)));",
            "return ret;",
            "}",
            "void copy_(Node *dst, const Node *src) {",
            "if (src->l != nullptr) {",
            "dst->l = new Node(src->l);",
            "copy_(dst->l, src->l);",
            "}",
            "if (src->r != nullptr) {",
            "if (src->r == src->l) {",
            "dst->r = dst->l;",
            "return;",
            "}",
            "dst->r = new Node(src->r);",
            "copy_(dst->r, src->r);",
            "}",
            "}",
            "void clear_(Node *now) {",
            "if (now == nullptr) return;",
            "if (now->l == now->r) now->r = nullptr;",
            "if (now->l != nullptr) clear_(now->l);",
            "if (now->r != nullptr) clear_(now->r);",
            "delete now;",
            "}",
            "std::mt19937_64 key_eng_;",
            "Node *root;",
            "public:",
            "TreapNR(): key_eng_(), root(nullptr) {}",
            "explicit TreapNR(uint64_t seed): key_eng_(seed), root(nullptr) {}",
            "TreapNR(self const &rhs): key_eng_(rhs.key_eng_), root(new Node(rhs.root)) { copy_(root, rhs.root); }",
            "self &operator=(self const &rhs) {",
            "clear();",
            "key_eng_ = rhs.key_eng_;",
            "root = new Node(rhs.root);",
            "copy_(root, rhs.root);",
            "return *this;",
            "}",
            "~TreapNR() { clear(); }",
            "void clear() {",
            "clear_(root);",
            "root = nullptr;",
            "}",
            "void insert(Tp const &val) {",
            "auto _ = split(root, val);",
            "auto _1 = split(_.first, val - 1);",
            "Node *new_node;",
            "if (_1.second == nullptr)",
            "new_node = new Node(key_eng_(), val);",
            "else {",
            "_1.second->cnt++;",
            "_1.second->update();",
            "}",
            "root = merge(merge(_1.first, _1.second == nullptr ? new_node : _1.second), _.second);",
            "}",
            "// only erase once if multiple @{val} stored",
            "void erase(Tp const &val) {",
            "auto _ = split(root, val);",
            "auto _1 = split(_.first, val - 1);",
            "if (_1.second->cnt > 1) {",
            "_1.second->cnt--;",
            "_1.second->update();",
            "_1.first = merge(_1.first, _1.second);",
            "} else {",
            "if (_.first == _1.second) _.first = nullptr;",
            "delete _1.second;",
            "_1.second = nullptr;",
            "}",
            "root = merge(_1.first, _.second);",
            "}",
            "// @return rank of @{val} (1 + <number of value less than @{val}>)",
            "//! rank start at 1",
            "size_t rank(Tp const &val) { return rank_(root, val); }",
            "// @return value which is @{rk}-th least",
            "//! rank start at 1",
            "Tp val(size_t rk) {",
            "assert(rk > 0);",
            "return val_(root, rk);",
            "}",
            "// @return lagrest value which less than @{val}",
            "Tp prev_val(Tp const &val) {",
            "auto _ = split(root, val - 1);",
            "Tp ret = val_(_.first, _.first->sz);",
            "root = merge(_.first, _.second);",
            "return ret;",
            "}",
            "// @return smallest value which greater than @{val}",
            "Tp next_val(Tp const &val) {",
            "auto _ = split(root, val);",
            "Tp ret = val_(_.second, 1);",
            "root = merge(_.first, _.second);",
            "return ret;",
            "}",
            "};"
        ]
    },
    "treap-no-rotate-flip": {
        "scope": "cpp",
        "prefix": [
            "fhqtreap-flip",
            "treap-nr-flip",
            "treap-no-rotate-flip"
        ],
        "body": [
            "// Treap without rotate",
            "template <class Tp>",
            "class TreapNR {",
            "static_assert(!std::is_unsigned<Tp>::value, \"Tp should not be unsigned\");",
            "using self = TreapNR<Tp>;",
            "protected:",
            "struct Node {",
            "Node *l, *r;",
            "uint_fast64_t rid;",
            "size_t cnt, sz;",
            "Tp val;",
            "bool flp = false;",
            "Node(uint_fast64_t rid, Tp val): l(nullptr), r(nullptr), rid(rid), cnt(1), sz(1), val(val) {}",
            "explicit Node(Node *rhs): rid(rhs->rid), cnt(rhs->cnt), sz(rhs->sz), val(rhs->val) {}",
            "friend std::ostream &operator<<(std::ostream &os, Node &ptr) {",
            "ptr.flip();",
            "if (ptr.l != nullptr) os << *(ptr.l);",
            "os << ptr.val << ' ';",
            "if (ptr.r != nullptr) os << *(ptr.r);",
            "return os;",
            "}",
            "constexpr void update() {",
            "sz = cnt;",
            "if (l != nullptr) sz += l->sz;",
            "if (r != nullptr) sz += r->sz;",
            "}",
            "protected:",
            "void flip_() {",
            "std::swap(l, r);",
            "if (l != nullptr) l->flp ^= 1;",
            "if (r != nullptr) r->flp ^= 1;",
            "flp = false;",
            "}",
            "public:",
            "// swap left subtree and right subtree recursively, with lazytag",
            "void flip() {",
            "if (flp) flip_();",
            "}",
            "};",
            "std::pair<Node *, Node *> split(Node *cur, size_t sz) {",
            "if (cur == nullptr) return {nullptr, nullptr};",
            "cur->flip();",
            "size_t lsz = cur->l == nullptr ? 0 : cur->l->sz;",
            "if (lsz < sz) {",
            "auto &&_ = split(cur->r, sz - lsz - 1);",
            "cur->r = _.first;",
            "cur->update();",
            "return {cur, _.second};",
            "} else {",
            "auto &&_ = split(cur->l, sz);",
            "cur->l = _.second;",
            "cur->update();",
            "return {_.first, cur};",
            "}",
            "}",
            "Node *merge(Node *u, Node *v) {",
            "if (u == nullptr && v == nullptr) return nullptr;",
            "if (u != nullptr && v == nullptr) return u;",
            "if (v != nullptr && u == nullptr) return v;",
            "u->flip();",
            "v->flip();",
            "if (u->rid < v->rid) {",
            "u->r = merge(u->r, v);",
            "u->update();",
            "return u;",
            "} else {",
            "v->l = merge(u, v->l);",
            "v->update();",
            "return v;",
            "}",
            "}",
            "void copy_(Node *dst, const Node *src) {",
            "if (src->l != nullptr) {",
            "dst->l = new Node(src->l);",
            "copy_(dst->l, src->l);",
            "}",
            "if (src->r != nullptr) {",
            "if (src->r == src->l) {",
            "dst->r = dst->l;",
            "return;",
            "}",
            "dst->r = new Node(src->r);",
            "copy_(dst->r, src->r);",
            "}",
            "}",
            "void clear_(Node *now) {",
            "if (now == nullptr) return;",
            "if (now->l == now->r) now->r = nullptr;",
            "if (now->l != nullptr) clear_(now->l);",
            "if (now->r != nullptr) clear_(now->r);",
            "delete now;",
            "}",
            "std::mt19937_64 key_eng_;",
            "Node *root;",
            "public:",
            "TreapNR(): key_eng_(), root(nullptr) {}",
            "explicit TreapNR(uint64_t seed): key_eng_(seed), root(nullptr) {}",
            "TreapNR(self const &rhs): key_eng_(rhs.key_eng_), root(new Node(rhs.root)) { copy_ (root, rhs.root); }",
            "self &operator=(self const &rhs) {",
            "clear();",
            "key_eng_ = rhs.key_eng_;",
            "root = new Node(rhs.root);",
            "copy_(root, rhs.root);",
            "return *this;",
            "}",
            "~TreapNR() { clear(); }",
            "void clear() {",
            "clear_(root);",
            "root = nullptr;",
            "}",
            "//! auto write '\\n' after finish writing",
            "friend std::ostream &operator<<(std::ostream &os, self &tree) {",
            "if (tree.root == nullptr) return os << '\\n';",
            "return (os << *(tree.root)).seekp(-1, std::ios_base::end) << '\\n';",
            "}",
            "void insert(Tp const &val) {",
            "auto &&_ = split(root, val);",
            "auto &&_1 = split(_.first, val - 1);",
            "Node *new_node;",
            "if (_1.second == nullptr)",
            "new_node = new Node(key_eng_(), val);",
            "else {",
            "_1.second->cnt++;",
            "_1.second->update();",
            "}",
            "root = merge(merge(_1.first, _1.second == nullptr ? new_node : _1.second), _.second);",
            "}",
            "// [a_1, a_2, ..., a_l, a_{l+1}, ..., a_r, a_{r+1}, ... a_n]",
            "// -> [a_1, a_2, ..., a_r, a_{r-1}, ..., a_l, a_{r+1}, ... a_n]",
            "// a_i is i-th value inserted in",
            "void reverse(size_t l, size_t r) {",
            "assert(0 < l && l <= r);",
            "auto &&tl = split(root, l - 1);",
            "auto &&tr = split(tl.second, r - l + 1);",
            "tr.first->flp = true;",
            "root = merge(tl.first, merge(tr.first, tr.second));",
            "}",
            "};"
        ]
    },
    "UDHeap": {
        "scope": "cpp",
        "prefix": "udheap",
        "body": [
            "template <class Tp>",
            "class UDHeap {",
            "private:",
            "std::priority_queue<Tp> dq;",
            "std::priority_queue<Tp, std::vector<Tp>, std::greater<Tp>> uq;",
            "\npublic:",
            "using self = UDHeap<Tp>;",
            "UDHeap() {}",
            "self &clear() {",
            "while (!dq.empty()) dq.pop();",
            "while (!uq.empty()) uq.pop();",
            "return *this;",
            "}",
            "self &insert(const Tp &x) {",
            "if (dq.empty() && uq.empty()) {",
            "dq.push(x);",
            "return *this;",
            "}",
            "(x > dq.top() ? uq.push(x) : dq.push(x));",
            "if (uq.size() > dq.size() + 1) {",
            "dq.push(uq.top());",
            "uq.pop();",
            "} else if (dq.size() > uq.size() + 1) {",
            "uq.push(dq.top());",
            "dq.pop();",
            "}",
            "return *this;",
            "}",
            "Tp get_mid() const { return uq.size() > dq.size() ? uq.top() : dq.top(); }",
            "self &pop_mid() {",
            "uq.size() > dq.size() ? uq.pop() : dq.pop();",
            "return *this;",
            "}",
            "};"
        ]
    }
}
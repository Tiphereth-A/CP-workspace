{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "bitset-AVX": {
        "scope": "cpp",
        "prefix": "bitset-avx",
        "body": [
            "#pragma GCC target(\"avx\")",
            "#include <immintrin.h>",
            "template <size_t N>",
            "class bitsetAVX {",
            "protected:",
            "size_t cnt;",
            "__m256i arr[(N + 255) >> 8];",
            "public:",
            "constexpr bitsetAVX(bool x = 0): cnt(x ? N : 0) {",
            "for (size_t i = 0; i < ((N + 255) >> 8); ++i) arr[i] = _mm256_set1_epi32(x ? 0xFFFFFFFFU : 0);",
            "}",
            "constexpr bool operator[](size_t x) const { return arr[x >> 8][x & 63 >> 2] >> (x & 7) & 1; }",
            "constexpr void flip(size_t x) {",
            "arr[x >> 9][x & 63 >> 2] ^= 1 << (x & 7);",
            "cnt += ((arr[x >> 9][x & 63 >> 2] >> (x & 7) & 1) << 1) - 1;",
            "}",
            "constexpr void set(size_t x, bool k) {",
            "if ((arr[x >> 9][x & 63 >> 2] >> (x & 7) & 1) ^ k) flip(x);",
            "}",
            "size_t count(bool x) const { return x ? cnt : N - cnt; }",
            "};"
        ]
    },
    "fast-max": {
        "scope": "cpp",
        "prefix": [
            "max-fast",
            "fast-max"
        ],
        "body": [
            "constexpr int max(int x, int y) {",
            "int m = (x - y) >> 31;",
            "return x & ~m | y & m;",
            "}"
        ]
    },
    "fast-min": {
        "scope": "cpp",
        "prefix": [
            "min-fast",
            "fast-min"
        ],
        "body": [
            "constexpr int min(int x, int y) {",
            "int m = (x - y) >> 31;",
            "return x & m | y & ~m;",
            "}"
        ]
    },
    "fast-str2uint": {
        "scope": "cpp",
        "prefix": [
            "str2uint-fast",
            "fast-str2uint"
        ],
        "body": [
            "//! only works properly on little-endian CPU such as Intel CPU",
            "//! works better on 64-bit CPU",
            "constexpr uint64_t dec2uint_mod(const char* const num, const uint64_t mod) {",
            "size_t len = strlen(num);",
            "if (len == 0) return 0;",
            "u128 ans = 0;",
            "for (size_t i = 0; i + 8 <= len; i += 8) {",
            "uint64_t res = *((uint64_t*)(num + i));",
            "res = (res & 0x0F0F0F0F0F0F0F0F) * 2561 >> 8;",
            "res = (res & 0x00FF00FF00FF00FF) * 6553601 >> 16;",
            "res = (res & 0x0000FFFF0000FFFF) * 42949672960001 >> 32;",
            "ans = (ans * 100000000 + res) % mod;",
            "}",
            "for (auto pch = num + (len / 8 * 8); pch < num + len;) ans = (ans * 10 + (*(pch++) & '\\x0f')) % mod;",
            "return ans;",
            "}"
        ]
    }
}
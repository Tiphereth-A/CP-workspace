{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "fast-IO": {
        "scope": "cpp",
        "prefix": "fastIO",
        "body": [
            "namespace fast_io {",
            "namespace type_traits {",
            "template <class Tp>",
            "using is_int = typename std::conditional<(std::is_integral<Tp>::value && std::is_signed<Tp>::value) || std::is_same<Tp, __int128_t>::value, std::true_type, std::false_type>::type;",
            "\ntemplate <class Tp>",
            "using is_uint = typename std::conditional<(std::is_integral<Tp>::value && std::is_unsigned<Tp>::value) || std::is_same<Tp, __uint128_t>::value, std::true_type, std::false_type>::type;",
            "\ntemplate <class Tp>",
            "using make_uint = typename std::conditional<std::is_same<Tp, __int128_t>::value, __uint128_t, typename std::conditional<std::is_signed<Tp>::value, std::make_unsigned<Tp>, std::common_type<Tp>>::type>::type;",
            "}  // namespace type_traits",
            "\ntemplate <size_t BUFFER_SIZE>",
            "class FastIn {",
            "\tusing self = FastIn<BUFFER_SIZE>;",
            "\nprotected:",
            "\tchar buffer_[BUFFER_SIZE], *now_ = buffer_, *end_ = buffer_;",
            "\tFILE *file_;",
            "\npublic:",
            "\texplicit FastIn(FILE *file = stdin) noexcept: file_(file) {}",
            "\n\tinline char fetch() noexcept { return this->now_ == this->end_ && (this->end_ = (this->now_ = this->buffer_) + fread(this->buffer_, 1, BUFFER_SIZE, this->file_), this->now_ == this->end_) ? EOF : *(this->now_)++; }",
            "\tinline char visit() noexcept { return this->now_ == this->end_ && (this->end_ = (this->now_ = this->buffer_) + fread(this->buffer_, 1, BUFFER_SIZE, this->file_), this->now_ == this->end_) ? EOF : *(this->now_); }",
            "\tinline void set_file(FILE *file) noexcept {",
            "\t\tthis->file_ = file;",
            "\t\tnow_ = end_ = buffer_;",
            "\t}",
            "\n\ttemplate <typename Tp, typename std::enable_if<type_traits::is_int<Tp>::value>::type * = nullptr>",
            "\tinline self &read(Tp &n) {",
            "\t\tbool is_neg = false;",
            "\t\tchar ch = this->fetch();",
            "\t\twhile (!isdigit(ch)) {",
            "\t\t\tis_neg |= ch == '-';",
            "\t\t\tch = this->fetch();",
            "\t\t}",
            "\t\tn = 0;",
            "\t\twhile (isdigit(ch)) {",
            "\t\t\t(n *= 10) += ch & 0x0f;",
            "\t\t\tch = this->fetch();",
            "\t\t}",
            "\t\tif (is_neg) n = -n;",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename Tp, typename std::enable_if<type_traits::is_uint<Tp>::value>::type * = nullptr>",
            "\tinline self &read(Tp &n) noexcept {",
            "\t\tchar ch = this->fetch();",
            "\t\twhile (!isdigit(ch)) ch = this->fetch();",
            "\t\tn = 0;",
            "\t\twhile (isdigit(ch)) {",
            "\t\t\t(n *= 10) += ch & 0x0f;",
            "\t\t\tch = this->fetch();",
            "\t\t}",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &read(char &n) noexcept {",
            "\t\tn = this->fetch();",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &read(char *n) noexcept {",
            "\t\tchar *n_ = n;",
            "\t\twhile (!isgraph(*n_ = this->fetch()));",
            "\t\twhile (isgraph(*(++n_) = this->fetch()));",
            "\t\t*n_ = '\\0';",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &read(std::string &n) noexcept {",
            "\t\tchar n_;",
            "\t\twhile (!isgraph(n_ = this->fetch()));",
            "\t\tn.push_back(n_);",
            "\t\twhile (isgraph(n_ = this->fetch())) n.push_back(n_);",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &getline(char *n) noexcept {",
            "\t\tchar *n_ = n;",
            "\t\twhile (!isprint(*n_ = this->fetch()));",
            "\t\twhile (isprint(*(++n_) = this->fetch()));",
            "\t\t*n_ = '\\0';",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &getline(std::string &n) noexcept {",
            "\t\tchar n_;",
            "\t\twhile (!isprint(n_ = this->fetch()));",
            "\t\tn.push_back(n_);",
            "\t\twhile (isprint(n_ = this->fetch())) n.push_back(n_);",
            "\t\treturn *this;",
            "\t}",
            "};",
            "\ntemplate <size_t BUFFER_SIZE>",
            "class FastOut {",
            "\tusing self = FastOut<BUFFER_SIZE>;",
            "\nprotected:",
            "\tchar buffer_[BUFFER_SIZE], *now_ = buffer_;",
            "\tconst char * const end_ = buffer_ + BUFFER_SIZE;",
            "\tFILE *file_;",
            "\npublic:",
            "\texplicit FastOut(FILE *file = stdout) noexcept: file_(file) {}",
            "\t~FastOut() noexcept { this->flush(); }",
            "\n\tinline void flush() noexcept { fwrite(this->buffer_, 1, this->now_ - this->buffer_, this->file_), this->now_ = this->buffer_; }",
            "\t\tinline void set_file(FILE *file) noexcept {",
            "\t\tthis->file_ = file;",
            "\t}",
            "\n\tinline self &linebreak() noexcept {",
            "\t\tthis->write('\\n');",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &write(const char &n) noexcept {",
            "\t\tif (this->now_ == this->end_) this->flush();",
            "\t\t*(this->now_)++ = n;",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &write(const char *n) noexcept {",
            "\t\tsize_t len = strlen(n), l_;",
            "\t\tconst char *n_ = n;",
            "\t\twhile (this->now_ + len >= this->end_) {",
            "\t\t\tl_ = this->end_ - this->now_;",
            "\t\t\tmemcpy(this->now_, n_, l_);",
            "\t\t\tthis->now_ += l_;",
            "\t\t\tn_ += l_;",
            "\t\t\tlen -= l_;",
            "\t\t\tthis->flush();",
            "\t\t}",
            "\t\tmemcpy(this->now_, n_, len);",
            "\t\tthis->now_ += len;",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <class Tp, typename std::enable_if<type_traits::is_int<Tp>::value>::type * = nullptr>",
            "\tinline self &write(Tp n) noexcept {",
            "\t\tif (n < 0) {",
            "\t\t\tthis->write('-');",
            "\t\t\tn = -n;",
            "\t\t}",
            "\t\treturn this->write(static_cast<typename type_traits::make_uint<Tp>::type>(n));",
            "\t}",
            "\ttemplate <class Tp, typename std::enable_if<type_traits::is_uint<Tp>::value>::type * = nullptr>",
            "\tinline self &write(Tp n) noexcept {",
            "\t\tstatic char num[63], *p;",
            "\t\tp = num;",
            "\t\tdo { *p++ = char(n % 10) | '0'; } while (n /= 10);",
            "\t\t*p = '\\0';",
            "\t\tthis->write(num);",
            "\t\treturn *this;",
            "\t}",
            "\tinline self &write(const std::string &str) noexcept {",
            "\t\tthis->write(str.c_str());",
            "\t\treturn *this;",
            "\t}",
            "};",
            "\nconst std::size_t BUFFER_SIZE = 1 << 21;",
            "FastIn<BUFFER_SIZE> fast_in;",
            "FastOut<BUFFER_SIZE> fast_out;",
            "}  // namespace fast_io",
            "using fast_io::fast_in;",
            "using fast_io::fast_out;"
        ]
    },
    "untie": {
        "scope": "cpp",
        "prefix": ["fast_ios", "fast_cin_cout"],
        "body": [
            "ios::sync_with_stdio(false);",
            "cin.tie(nullptr);",
            "cout.tie(nullptr);"
        ]
    },
    "fast-max": {
        "scope": "cpp",
        "prefix": ["max_fast", "fast_max"],
        "body": [
            "int max(int x, int y) {",
            "\tint m = (x - y) >> 31;",
            "\treturn x & ~m | y & m;",
            "}"
        ]
    },
    "fast-min": {
        "scope": "cpp",
        "prefix": ["min_fast", "fast_min"],
        "body": [
            "int min(int x, int y) {",
            "\tint m = (x - y) >> 31;",
            "\treturn x & m | y & ~m;",
            "}"
        ]
    },
    "fast-str2uint": {
        "scope": "cpp",
        "prefix": [
            "str2uint_fast",
            "dec2uint_fast",
            "fast_str2uint",
            "fast_dec2uint"
        ],
        "body": [
            "//! only works properly on little-endian CPU such as Intel CPU",
            "//! works better on 64-bit CPU",
            "inline constexpr uint64_t dec2uint_mod(const char* const num, const uint64_t mod) {",
            "\tsize_t len = strlen(num);",
            "\tif (len == 0) return 0;",
            "\tu128 ans = 0;",
            "\tfor (size_t i = 0; i + 8 <= len; i += 8) {",
            "\t\tuint64_t res = *((uint64_t*)(num + i));",
            "\t\tres = (res & 0x0F0F0F0F0F0F0F0F) * 2561 >> 8;",
            "\t\tres = (res & 0x00FF00FF00FF00FF) * 6553601 >> 16;",
            "\t\tres = (res & 0x0000FFFF0000FFFF) * 42949672960001 >> 32;",
            "\t\tans = (ans * 100000000 + res) % mod;",
            "\t}",
            "\tfor (auto pch = num + (len / 8 * 8); pch < num + len;) ans = (ans * 10 + (*(pch++) & '\\x0f')) % mod;",
            "\treturn ans;",
            "}"
        ]
    }
}

{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "init-cpp-simple": {
        "scope": "cpp",
        "prefix": [
            "iis",
            "init_simple"
        ],
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using i64 = int64_t;",
            "using u64 = uint64_t;",
            "\nconst int N = 1e5 + 5;",
            "\nint main() {",
            "\t$0",
            "\treturn 0;",
            "}"
        ]
    },
    "init-cpp": {
        "scope": "cpp",
        "prefix": [
            "ii",
            "init"
        ],
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using i64 = int64_t;",
            "using u64 = uint64_t;",
            "using i128 = __int128_t;",
            "using u128 = __uint128_t;",
            "using pii = pair<int, int>;",
            "\n#define _for(i, l, r, vals...) for (decltype(l + r) i = (l), i##end = (r), ##vals; i <= i##end; ++i)",
            "#define _rfor(i, r, l, vals...) for (make_signed_t<decltype(r - l)> i = (r), i##end = (l), ##vals; i >= i##end; --i)",
            "#define _foreach_val(i, container) for (auto i : container)",
            "#define _foreach_ref(i, container) for (auto &i : container)",
            "#define _foreach_cref(i, container) for (const auto &i : container)",
            "#define _foreach_rref(i, container) for (auto &&i : container)",
            "#define _foreach_iter(it, container) for (auto it = (container).begin(); it != (container).end(); ++it)",
            "#define _foreach_iter_range(it, container, l, r) for (auto it = (container).begin() + l; it != (container).begin() + r; ++it)",
            "#define _ins(a) std::inserter((a), (a).begin())",
            "#define _all(a) (a).begin(), (a).end()",
            "#define _set_nul(a) memset(a, 0, sizeof(a))",
            "#define _set_inf(a) memset(a, 0x3f, sizeof(a))",
            "#define _set_nul_n(a, n) memset(a, 0, sizeof(*(a)) * (n))",
            "#define _set_inf_n(a, n) memset(a, 0x3f, sizeof(*(a)) * (n))",
            "#define _run_exit(expressions) _run_return(expressions, 0)",
            "#define _run_return(expressions, val) return (expressions), val",
            "#define _run_return_void(expressions) \\",
            "\t{                         \\",
            "\t\texpressions;            \\",
            "\t\treturn;                 \\",
            "\t}",
            "#define _run_break(expressions) \\",
            "\t{                           \\",
            "\t\texpressions;            \\",
            "\t\tbreak;                  \\",
            "\t}",
            "#define _run_continue(expressions) \\",
            "\t{                              \\",
            "\t\texpressions;               \\",
            "\t\tcontinue;                  \\",
            "\t}",
            "#define _mid(l, r) ((l) + (((r) - (l)) >> 1))",
            "#define _len(l, r) ((r) - (l) + 1)",
            "#define _lowbit(x) (1 << __builtin_ctz(x))",
            "#define _lowbit_64(x) (1 << __builtin_ctzll(x))",
            "#define _debug                                              \\",
            "\t{                                                       \\",
            "\t\tfprintf(stderr, \"%d %s\\n\", __LINE__, __FUNCTION__); \\",
            "\t\tfflush(stderr);                                     \\",
            "\t}",
            "\ntemplate <class T>",
            "bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }",
            "template <class T>",
            "bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }",
            "\nconst uint32_t OFFSET = 5;",
            "const uint32_t N = 1e5 + OFFSET, M = 2e5 + OFFSET, K = 21;",
            "const uint32_t MOD = 1e9 + 7;",
            "const double EPS = 1e-6;",
            "const int INF = 0x3f3f3f3f;",
            "const i64 INFLL = 0x3f3f3f3f3f3f3f3f;",
            "const double PI = acos(-1.0);",
            "const pii DIR4[4] = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};",
            "const pii DIR8[8] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};",
            "const int EXP10[10] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};",
            "\nconstexpr auto __STATIC__ = []() { return 0.0; }();",
            "\n#define MULTI_CASES",
            "inline auto solve() -> void {",
            "$0",
            "}",
            "\nint main() {",
            "#ifdef _LOCAL_",
            "\tauto _CLOCK_ST = std::chrono::steady_clock::now();",
            "#endif",
            "",
            "\tios::sync_with_stdio(false);",
            "\tcin.tie(nullptr);",
            "\tcout.tie(nullptr);",
            "",
            "#ifdef MULTI_CASES",
            "\tint _t;",
            "\tcin >> _t;",
            "\twhile (_t--)",
            "#endif",
            "\t\tsolve();",
            "",
            "#ifdef _LOCAL_",
            "\tstd::clog << \"\\n---\\n\"",
            "\t          << \"Time used: \" << std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - _CLOCK_ST).count() << \" ms\" << std::endl;",
            "#endif",
            "\treturn 0;",
            "}",
        ]
    },
    "foreach": {
        "scope": "cpp",
        "prefix": [
            "fors",
            "foreach"
        ],
        "body": [
            "#define _for(i, l, r, vals...) for (decltype(l + r) i = (l), i##end = (r), ##vals; i <= i##end; ++i)",
            "#define _rfor(i, r, l, vals...) for (make_signed_t<decltype(r - l)> i = (r), i##end = (l), ##vals; i >= i##end; --i)",
            "#define _foreach_val(i, container) for (auto i : container)",
            "#define _foreach_ref(i, container) for (auto& i : container)",
            "#define _foreach_cref(i, container) for (const auto& i : container)",
            "#define _foreach_rref(i, container) for (auto&& i : container)",
            "#define _foreach_iter(it, container) for (auto it = (container).begin(); it != (container).end(); ++it)",
            "#define _foreach_iter_range(it, container, l, r) for (auto it = (container).begin() + l; it != (container).begin() + r; ++it)",
        ]
    },
    "fast-IO": {
        "scope": "cpp",
        "prefix": "fastIO",
        "body": [
            "namespace FastIO {",
            "char buf[1 << 21], buf2[1 << 21], a[20], *p1 = buf, *p2 = buf;",
            "int p, p3 = -1;",
            "inline char getc() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++; }",
            "inline void flush() { fwrite(buf2, 1, p3 + 1, stdout), p3 = -1; }",
            "inline void read() {}",
            "template <class T, typename std::enable_if<is_signed_v<T>>::type* = nullptr>",
            "inline void read(T& x) {",
            "\tint f = x = 0;",
            "\tchar ch = getc();",
            "\twhile (!isdigit(ch)) {",
            "\t\tif (ch == '-') f = 1;",
            "\t\tch = getc();",
            "\t}",
            "\twhile (isdigit(ch)) { x = x * 10 + (ch & 0x0f), ch = getc(); }",
            "\tif (f) x = -x;",
            "}",
            "template <class T, typename std::enable_if<is_unsigned_v<T>>::type* = nullptr>",
            "inline void read(T& x) {",
            "\tx = 0;",
            "\tchar ch = getc();",
            "\twhile (!isdigit(ch)) ch = getc();",
            "\twhile (isdigit(ch)) { x = x * 10 + (ch & 0x0f), ch = getc(); }",
            "}",
            "inline void read(char* str) {",
            "\tchar ch = getc(), *now = str;",
            "\twhile (!isprint(ch)) ch = getc();",
            "\twhile (isprint(ch)) { *(now++) = ch, ch = getc(); }",
            "\t*(now++) = '\\0';",
            "}",
            "inline void read(std::string& str) {",
            "\tchar ch = getc();",
            "\twhile (!isprint(ch)) ch = getc();",
            "\twhile (isprint(ch)) { str.push_back(ch), ch = getc(); }",
            "}",
            "template <typename T, typename... T2, typename std::enable_if<is_signed_v<T> || is_unsigned_v<T> || is_same_v<T, char*> || is_same_v<T, string&>>::type* = nullptr>",
            "inline void read(T& x, T2&... oth) {",
            "\tread(x);",
            "\tread(oth...);",
            "}",
            "inline void print() {}",
            "inline void print(char a) { buf2[++p3] = a; }",
            "template <class T, typename std::enable_if<is_signed_v<T>>::type* = nullptr>",
            "inline void print(T x) {",
            "\tif (x < 0) { buf2[++p3] = '-', x = -x; }",
            "\tdo { a[++p] = x % 10 + 48; } while (x /= 10);",
            "\tdo { buf2[++p3] = a[p]; } while (--p);",
            "}",
            "template <class T, typename std::enable_if<is_unsigned_v<T>>::type* = nullptr>",
            "inline void print(T x) {",
            "\tdo { a[++p] = x % 10 + 48; } while (x /= 10);",
            "\tdo { buf2[++p3] = a[p]; } while (--p);",
            "}",
            "inline void print(const std::string& str) {",
            "\tfor (char ch : str) {",
            "\tif (p3 > 1 << 20) flush();",
            "\tprint(ch);",
            "\t}",
            "}",
            "template <typename T, typename... T2, typename std::enable_if<is_signed_v<T> || is_unsigned_v<T> || is_same_v<T, char> || is_same_v<T, string&> || is_same_v<T, const string&>>::type* = nullptr>",
            "inline void print(T x, T2... oth) {",
            "\tif (p3 > 1 << 20) flush();",
            "\tprint(x);",
            "\tprint(oth...);",
            "}",
            "}  // namespace FastIO",
            "using FastIO::print;",
            "using FastIO::read;",
            "//======================================",
        ]
    },
    "untie": {
        "scope": "cpp",
        "prefix": [
            "fast_ios",
            "fast_cin_cout"
        ],
        "body": [
            "ios::sync_with_stdio(false);",
            "cin.tie(nullptr);",
            "cout.tie(nullptr);",
        ]
    },
    "combination": {
        "scope": "cpp",
        "prefix": [
            "comb",
            "combination",
            "m_choose_n"
        ],
        "body": "auto m_choose_n = [](int m, int n, i64 mod = MOD) -> i64 { return m < n ? 0 : fact[m] * inv_fact[n] % mod * inv_fact[m - n] % mod; };"
    },
    "factorial-and-inverse": {
        "scope": "cpp",
        "prefix": [
            "fact",
            "factorial"
        ],
        "body": [
            "i64 fact[N * 2], inv_fact[N];",
            "auto __STATIC__ = []() {",
            "\tstatic i64 ffact[N];",
            "\tffact[0] = fact[0] = inv_fact[0] = fact[1] = inv_fact[1] = 1;",
            "\t_for(i, 2, N * 2 - 1) fact[i] = fact[i - 1] * i % MOD;",
            "\t_for(i, 1, N - 1) ffact[i] = ffact[i - 1] * fact[i] % MOD;",
            "\ti64 _ = qpow(ffact[N - 1]);",
            "\t_rfor(i, N - 1, 2) {",
            "\t\tinv_fact[i] = _ * ffact[i - 1] % MOD;",
            "\t\t_ = _ * fact[i] % MOD;",
            "\t}",
            "\treturn 0.0;",
            "}();",
        ]
    },
    "gcd-lambda": {
        "scope": "cpp",
        "prefix": "gcd_lambda",
        "body": [
            "template <typename T>",
            "auto gcd = [](T n, T m) -> T {",
            "\twhile (m ^= n ^= m ^= n %= m)\n\t\t;",
            "\treturn n;",
            "};",
        ]
    },
    "graph": {
        "scope": "cpp",
        "prefix": [
            "graph",
            "edges"
        ],
        "body": [
            "struct Edge {",
            "\tint w, to, next;",
            "\tEdge(int _w = 0, int _to = 0, int _next = 0) : w(_w), to(_to), next(_next) {}",
            "} e[M];",
            "int head[N], cnt_edge;",
            "int in[N], out[N];",
            "void addEdge(int x, int y, int w = 1) {",
            "\te[++cnt_edge] = Edge(w, y, head[x]);",
            "\thead[x] = cnt_edge;",
            "\t++in[y];",
            "\t++out[x];",
            "}",
            "\n#define _for_graph(head, e, i, now) for (int i = head[now], to = e[i].to; i; to = e[i = e[i].next].to)"
        ]
    },
    "fast-max": {
        "scope": "cpp",
        "prefix": [
            "max_fast",
            "fast_max"
        ],
        "body": [
            "int max(int x, int y) {",
            "\tint m = (x - y) >> 31;",
            "\treturn x & ~m | y & m;",
            "}"
        ]
    },
    "fast-min": {
        "scope": "cpp",
        "prefix": [
            "min_fast",
            "fast_min"
        ],
        "body": [
            "int min(int x, int y) {",
            "\tint m = (x - y) >> 31;",
            "\treturn x & m | y & ~m;",
            "}"
        ]
    },
    "fast-str2uint": {
        "scope": "cpp",
        "prefix": [
            "str2uint_fast",
            "dec2uint_fast",
            "fast_str2uint",
            "fast_dec2uint"
        ],
        "body": [
            "//! only works properly on little-endian CPU such as Intel CPU",
            "//! works better on 64-bit CPU",
            "inline constexpr uint64_t dec2uint_mod(const char* const num, const uint64_t mod) {",
            "\tsize_t len = strlen(num);",
            "\tif (len == 0) return 0;",
            "\tu128 ans = 0;",
            "\tfor (size_t i = 0; i + 8 <= len; i += 8) {",
            "\t\tuint64_t res = *((uint64_t*)(num + i));",
            "\t\tres = (res & 0x0F0F0F0F0F0F0F0F) * 2561 >> 8;",
            "\t\tres = (res & 0x00FF00FF00FF00FF) * 6553601 >> 16;",
            "\t\tres = (res & 0x0000FFFF0000FFFF) * 42949672960001 >> 32;",
            "\t\tans = (ans * 100000000 + res) % mod;",
            "\t}",
            "\tfor (auto pch = num + (len / 8 * 8); pch < num + len;) ans = (ans * 10 + (*(pch++) & '\\x0f')) % mod;",
            "\treturn ans;",
            "}"
        ]
    },
    "exgcd": {
        "scope": "cpp",
        "prefix": "exgcd",
        "body": [
            "template <typename T = i64>",
            "T exgcd(T a, T b, T& x, T& y) {",
            "\tif (b == 0) {",
            "\t\tx = 1;",
            "\t\ty = 0;",
            "\t\treturn a;",
            "\t}",
            "\tT res = exgcd(b, a % b, y, x);",
            "\ty -= a / b * x;",
            "\treturn res;",
            "}"
        ]
    },
    "qwick-pow": {
        "scope": "cpp",
        "prefix": "qpow",
        "body": [
            "template <typename Tp = i64>",
            "inline constexpr Tp qpow(Tp a, Tp b = MOD - 2, const Tp& mod = MOD) {",
            "\tTp res(1);",
            "\tfor (; b; b >>= 1, (a *= a) %= mod)",
            "\t\tif (b & 1) (res *= a) %= mod;",
            "\treturn res;",
            "};"
        ]
    },
    "dijkstra": {
        "scope": "cpp",
        "prefix": [
            "dijkstra",
            "dijk"
        ],
        "body": [
            "int  dis[N];",
            "void dijkstra(int s) {",
            "\tpriority_queue<pii, vector<pii>, greater<pii>> q;",
            "\tmemset(dis, 0x3f, sizeof(dis));",
            "\tdis[s] = 0;",
            "\tq.emplace(0, s);",
            "\twhile (!q.empty()) {",
            "\t\tpii now = q.top();",
            "\t\tq.pop();",
            "\t\tint v = now.second;",
            "\t\tif (dis[v] < now.first) continue;",
            "\t\tfor (int i = head[v], to; i; i = e[i].next) {",
            "\t\t\tto = e[i].to;",
            "\t\t\tif (dis[to] > dis[v] + e[i].w) q.emplace(dis[to] = dis[v] + e[i].w, to);",
            "\t\t}",
            "\t}",
            "}"
        ]
    },
    "dsu-basic": {
        "scope": "cpp",
        "prefix": "dsu_basic",
        "body": [
            "int  fa[N];",
            "int  find(int x) { return x == fa[x] ? fa[x] : fa[x] = find(fa[x]); }",
            "void merge(int x, int y) { fa[find(x)] = find(y); }",
        ]
    },
    "johnson": {
        "scope": "cpp",
        "prefix": "johnson",
        "body": [
            "namespace Johnson_shortest_path {",
            "const int64_t INF = 0x3f3f3f3f3f3f3f3f;",
            "\nstruct Edge {",
            "\tint to, next;",
            "\tint64_t w;",
            "\tEdge(int64_t _w = 0, int _to = 0, int _next = -1):",
            "\t\tto(_to), next(_next), w(_w) {}",
            "} e[M];",
            "int head[N], cnt_edge;",
            "void addEdge(int x, int y, int w = 1) {",
            "\te[++cnt_edge] = Edge(w, y, head[x]);",
            "\thead[x] = cnt_edge;",
            "}",
            "\n#define _for_graph(head, e, i, now) for (int i = head[now], to = e[i].to; ~i; to = e[i = e[i].next].to)",
            "\nint n, m;",
            "int vis[N];",
            "int64_t h[N], dis[N];",
            "bool f[N];",
            "\nbool bellman_ford(int s) {",
            "\tqueue<int> q;",
            "\tmemset(h, 0x3f, sizeof(h[0]) * (n + 1));",
            "\th[s] = 0;",
            "\tf[s] = true;",
            "\tq.push(s);",
            "\twhile (!q.empty()) {",
            "\t\tint now = q.front();",
            "\t\tq.pop();",
            "\t\tf[now] = 0;",
            "\t\t_for_graph(head, e, i, now)",
            "\t\t\tif (h[to] > h[now] + e[i].w) {",
            "\t\t\t\th[to] = h[now] + e[i].w;",
            "\t\t\t\tif (f[to]) continue;",
            "\t\t\t\tif (++vis[to] > n) return false;",
            "\t\t\t\tf[to] = true;",
            "\t\t\t\tq.push(to);",
            "\t\t\t}",
            "\t}",
            "\treturn true;",
            "}",
            "\nvoid dijkstra(int s) {",
            "\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;",
            "\tmemset(dis, 0x3f, sizeof(dis[0]) * (n + 1));",
            "\tmemset(f, 0, sizeof(f[0]) * (n + 1));",
            "\tq.emplace(0, s);",
            "\tdis[s] = 0;",
            "\twhile (!q.empty()) {",
            "\t\tint now = q.top().second;",
            "\t\tq.pop();",
            "\t\tif (f[now]) continue;",
            "\t\tf[now] = 1;",
            "\t\t_for_graph(head, e, i, now)",
            "\t\t\tif (dis[to] > dis[now] + e[i].w) {",
            "\t\t\t\tdis[to] = dis[now] + e[i].w;",
            "\t\t\t\tif (!f[to]) q.emplace(dis[to], to);",
            "\t\t\t}",
            "\t}",
            "}",
            "\nint64_t ans[N][N];",
            "\n//! Must initialize only in once.",
            "// return true if no negetive cycle",
            "inline bool init(int vertex_num, int edge_num, const tuple<int, int, int> *arcs) {",
            "\tn = vertex_num;",
            "\tm = edge_num;",
            "\tmemset(head, 0xff, sizeof(head[0]) * (n + 1));",
            "\t_for(i, 1, m) addEdge(get<0>(arcs[i]), get<1>(arcs[i]), get<2>(arcs[i]));",
            "\t_for(i, 1, n) addEdge(0, i, 0);",
            "\tif (!bellman_ford(0)) return false;",
            "\t_for(u, 1, n)",
            "\t\t_for_graph(head, e, i, u) e[i].w += h[u] - h[to];",
            "\t_for(i, 1, n) {",
            "\t\tdijkstra(i);",
            "\t\t_for(j, 1, n) ans[i][j] = ((dis[j] == INF) ? INF : (dis[j] + h[j] - h[i]));",
            "\t}",
            "\treturn true;",
            "}",
            "inline bool is_disconnected(int x, int y) { return ans[x][y] == INF; }",
            "inline int64_t distance(int x, int y) { return ans[x][y]; }",
            "}"
        ]
    },
    "kruakal": {
        "scope": "cpp",
        "prefix": "kruskal",
        "body": [
            "struct Edge {",
            "\tint  w, from, to;",
            "\tbool operator<(const Edge& other) const { return w < other.w; }",
            "} e[M];",
            "int  cnt_edge;",
            "void addEdge(int x, int y, int w = 1) { e[++cnt_edge] = {w, x, y}; }",
            "",
            "int  fa[N];",
            "int  find(int x) { return x == fa[x] ? fa[x] : fa[x] = find(fa[x]); }",
            "void merge(int x, int y) { fa[find(x)] = find(y); }",
            "",
            "long long kruskal(int n, int k = 1) {",
            "\tsort(e + 1, e + cnt_edge + 1);",
            "\tfor (int i = 0; i <= n; ++i) fa[i] = i;",
            "\tint       cnt = 0;",
            "\tlong long ans = 0;",
            "\tfor (int i = 1, fx, fy; i <= cnt_edge; ++i) {",
            "\t\tfx = find(e[i].from);",
            "\t\tfy = find(e[i].to);",
            "\t\tif (fx == fy) continue;",
            "\t\tfa[fx] = fy;",
            "\t\t++cnt;",
            "\t\tans += e[i].w;",
            "\t\tif (cnt == n - k) break;",
            "\t}",
            "\tif (cnt != n - k) throw \"No Answer\";",
            "\treturn ans;",
            "}",
        ]
    },
    "mul_mod": {
        "scope": "cpp",
        "prefix": "mul_mod",
        "body": [
            "template <typename Tp = i64>",
            "inline constexpr Tp mul_mod(Tp a, Tp b, const Tp& mod) {",
            "\tTp d = floor(1.0l * a * b / mod + 0.5l), ret = a * b - d * mod;",
            "\treturn ret < 0 ? ret + mod : ret;",
            "}",
        ]
    },
    "pow_mod": {
        "scope": "cpp",
        "prefix": "pow_mod",
        "body": [
            "template <typename Tp = i64>",
            "inline constexpr Tp qpow(Tp a, Tp b, const Tp& mod = MOD) {",
            "\tTp res(1);",
            "\tfor (; b; b >>= 1, a = mul_mod(a, a, mod))",
            "\t\tif (b & 1) res = mul_mod(res, a, mod);",
            "\treturn res;",
            "}"
        ]
    },
    "euler_phi": {
        "scope": "cpp",
        "prefix": [
            "phi",
            "euler_phi"
        ],
        "body": [
            "template <typename Tp = i64>",
            "inline constexpr Tp euler_phi(Tp n) {",
            "\tTp ans = n;",
            "\tfor (Tp i = 2; i <= sqrt(n); ++i)",
            "\t\tif (n % i == 0) {",
            "\t\t\tans = ans / i * (i - 1);",
            "\t\t\twhile (n % i == 0) n /= i;",
            "\t\t}",
            "\tif (n > 1) ans = ans / n * (n - 1);",
            "\treturn ans;",
            "}",
        ]
    },
    "inverse": {
        "scope": "cpp",
        "prefix": [
            "inv",
            "inverse"
        ],
        "body": [
            "template <class Tp = i64>",
            "inline constexpr Tp inverse(make_signed_t<Tp> n, const Tp& mod) {",
            "\tmake_signed_t<Tp> b = mod, m0 = 0;",
            "\tfor (Tp q, m1 = 1; n;) {",
            "\t\tq = b / n;",
            "\t\tb -= n * q;",
            "\t\tm0 -= m1 * q;",
            "\t\tswap(n, b);",
            "\t\tswap(m0, m1);",
            "\t}",
            "\treturn (m0 + (m0 < 0 ? mod / b : 0)) % mod;",
            "}",
        ]
    },
    "prime": {
        "scope": "cpp",
        "prefix": "prime",
        "body": [
            "const int N = 2e6 + 5, P = 1.5e5 + 5;",
            "\nbool vis[N];",
            "int prime[P], cnt_prime;",
            "long long phi[N], mu[N];",
            "inline void init_prime(const int& n = N - 1) {",
            "\tphi[1] = mu[1] = 1;",
            "\tfor (int i = 2; i <= n; ++i) {",
            "\t\tif (!vis[i]) {",
            "\t\t\tprime[++cnt_prime] = i;",
            "\t\t\tmu[i] = -1;",
            "\t\t\tphi[i] = i - 1;",
            "\t\t}",
            "\t\tfor (int j = 1; j <= cnt_prime && i * prime[j] <= n; ++j) {",
            "\t\t\tvis[i * prime[j]] = 1;",
            "\t\t\tphi[i * prime[j]] = phi[i] * prime[j];",
            "\t\t\tif (i % prime[j] == 0) break;",
            "\t\t\tphi[i * prime[j]] -= phi[i];",
            "\t\t\tmu[i * prime[j]] = -mu[i];",
            "\t\t}",
            "\t}",
            "}",
        ]
    },
    "ostream-int128": {
        "scope": "cpp",
        "prefix": [
            "os128",
            "out128",
            "cout128"
        ],
        "body": [
            "ostream& operator<<(ostream& os, i128 n) {",
            "\tif (n < 0) {",
            "\t\tos << '-';",
            "\t\tn = -n;",
            "\t}",
            "\tif (n > 9) os << (i128)(n / 10);",
            "\tos << (uint_fast16_t)(n % 10);",
            "\treturn os;",
            "}",
            "ostream& operator<<(ostream& os, u128 n) {",
            "\tif (n > 9) os << (u128)(n / 10);",
            "\tos << (uint_fast16_t)(n % 10);",
            "\treturn os;",
            "}",
        ]
    },
    "tarjan-scc": {
        "scope": "cpp",
        "prefix": [
            "scc",
            "tarjan-scc"
        ],
        "body": [
            "int dfn[N], low[N], cnt_dfn;",
            "stack<int> stk;",
            "bool in_stk[N];",
            "int scc_id[N], scc_size[N], cnt_scc;",
            "void tarjan(int now) {",
            "\tin_stk[now] = 1;",
            "\tdfn[now] = low[now] = ++cnt_dfn;",
            "\tstk.push(now);",
            "\t_for_graph(head, e, i, now) if (!dfn[to]) {",
            "\t\ttarjan(to);",
            "\t\tchkmin(low[now], low[to]);",
            "\t}",
            "\telse if (in_stk[to]) chkmin(low[now], dfn[to]);",
            "\tif (dfn[now] == low[now]) {",
            "\t\t++cnt_scc;",
            "\t\twhile (stk.top() != now) {",
            "\t\t\t++scc_size[scc_id[stk.top()] = cnt_scc];",
            "\t\t\tin_stk[stk.top()] = 0;",
            "\t\t\tstk.pop();",
            "\t\t}",
            "\t\t++scc_size[scc_id[stk.top()] = cnt_scc];",
            "\t\tin_stk[stk.top()] = 0;",
            "\t\tstk.pop();",
            "\t}",
            "}",
        ]
    },
    "2-sat": {
        "scope": "cpp",
        "prefix": ["2_sat","sat","sat_2"],
        "body": [
            "namespace SAT_2 {",
            "struct Edge {",
            "\tint to, next;",
            "\tEdge(int _to = 0, int _next = 0):",
            "\t\tto(_to), next(_next) {}",
            "} e[M];",
            "int head[N], cnt_edge;",
            "void addEdge(int x, int y) {",
            "\te[++cnt_edge] = Edge(y, head[x]);",
            "\thead[x] = cnt_edge;",
            "}",
            "\n#define _for_graph(head, e, i, now) for (int i = head[now], to = e[i].to; i; to = e[i = e[i].next].to)",
            "\nint dfn[N], low[N], cnt_dfn;",
            "stack<int> stk;",
            "bool in_stk[N];",
            "int scc_id[N], cnt_scc;",
            "void tarjan(int now) {",
            "\tdfn[now] = low[now] = ++cnt_dfn;",
            "\tstk.push(now);",
            "\tin_stk[now] = 1;",
            "\t_for_graph(head, e, i, now)",
            "\t\tif (!dfn[to]) {",
            "\t\t\ttarjan(to);",
            "\t\t\tchkmin(low[now], low[to]);",
            "\t\t} else if (in_stk[to])",
            "\t\t\tchkmin(low[now], dfn[to]);",
            "\tif (dfn[now] == low[now]) {",
            "\t\t++cnt_scc;",
            "\t\twhile (stk.top() != now) {",
            "\t\t\tscc_id[stk.top()] = cnt_scc;",
            "\t\t\tin_stk[stk.top()] = 0;",
            "\t\t\tstk.pop();",
            "\t\t}",
            "\t\tscc_id[stk.top()] = cnt_scc;",
            "\t\tin_stk[stk.top()] = 0;",
            "\t\tstk.pop();",
            "\t}",
            "}",
            "\nint n;",
            "\n//! Must initialize only in once.",
            "// return true if the restricts is legel, otherwise illegel",
            "bool init(int _n, int m, tuple<int, bool, int, bool> *restricts) {",
            "\tn = _n;",
            "\tfor (int i = 1; i <= m; ++i) {",
            "\t\tauto &[x, bit_x, y, bit_y] = restricts[i];",
            "\t\taddEdge(x + bit_x * n, y + !bit_y * n);",
            "\t\taddEdge(y + bit_y * n, x + !bit_x * n);",
            "\t}",
            "\tfor (int i = 1; i <= n * 2; ++i)",
            "\t\tif (!dfn[i]) tarjan(i);",
            "\tfor (int i = 1; i <= n; ++i)",
            "\t\tif (scc_id[i] == scc_id[i + n]) return false;",
            "\treturn true;",
            "}",
            "bool possible_value(int x) { return scc_id[x] < scc_id[x + n]; }",
            "}  // namespace SAT_2"
        ]
    },
    "rpow": {
        "scope": "cpp",
        "prefix": "rpow",
        "body": [
            "template <typename Tp = i64>",
            "class rpow final {",
            "private:",
            "\tuint32_t mod;",
            "\tTp base;",
            "\tstd::array<Tp, 65536> block1, block2;",
            "\npublic:",
            "\n\trpow() {}",
            "\trpow(const Tp& _base, const uint32_t& _mod, Tp&& _1) { this->init(_base, _mod, _1); }",
            "\tvoid init(const Tp& _base, const uint32_t& _mod, Tp&& _1) {",
            "\t\tbase = _base;",
            "\t\tmod = _mod;",
            "\t\tblock1[0] = block2[0] = _1;",
            "\t\tfor (uint32_t i = 1; i < 65536; i++) block1[i] = block1[i - 1] * base % mod;",
            "\t\tTp _(block1.back() * base % mod);",
            "\t\tfor (uint32_t i = 1; i < 65536; i++) block2[i] = block2[i - 1] * _ % mod;",
            "\t}",
            "\n\tTp&& get_base() { return std::move(base); }",
            "\tuint32_t&& get_mod() { return std::move(mod); }",
            "\n\tTp operator()(std::size_t exponent) { return block1[exponent & 65535] * block2[exponent >> 16] % mod; }",
            "};"
        ]
    }
}
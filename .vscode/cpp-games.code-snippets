{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "Sudoku": {
        "scope": "cpp",
        "prefix": [
            "sudoku"
        ],
        "body": [
            "namespace SUDOKU {",
            "class DLX {",
            "protected:",
            "struct Node {",
            "size_t l, r, u, d, row, col;",
            "constexpr Node(size_t l = 0, size_t r = 0, size_t u = 0, size_t d = 0, size_t row = 0, size_t col = 0): l(l), r(r), u(u), d(d), row(row), col(col) {}",
            "friend std::ostream &operator<<(std::ostream &os, Node const &data) { return os << data.l << ' ' << data.r << ' ' << data.u << ' ' << data.d << ' ' << data.row << ' ' << data.col; }",
            "};",
            "std::vector<Node> data;",
            "std::vector<size_t> cnt_col;",
            "bool multians;",
            "#define l_(x) data[x].l",
            "#define r_(x) data[x].r",
            "#define u_(x) data[x].u",
            "#define d_(x) data[x].d",
            "#define row_(x) data[x].row",
            "#define col_(x) data[x].col",
            "#define for_(i, start, dir) for (size_t start__ = (start), i = dir##_(start__); i != start__; i = dir##_(i))",
            "void remove_(size_t col) {",
            "r_(l_(col)) = r_(col);",
            "l_(r_(col)) = l_(col);",
            "for_(i, col, d)",
            "for_(j, i, r) {",
            "u_(d_(j)) = u_(j);",
            "d_(u_(j)) = d_(j);",
            "--cnt_col[col_(j)];",
            "}",
            "}",
            "void resume_(size_t col) {",
            "r_(l_(col)) = l_(r_(col)) = col;",
            "for_(i, col, u)",
            "for_(j, i, r) {",
            "u_(d_(j)) = d_(u_(j)) = j;",
            "++cnt_col[col_(j)];",
            "}",
            "}",
            "bool dance_(std::vector<size_t> &ans_, std::function<void(std::vector<size_t> const &)> const &func_) {",
            "size_t now = r_(0);",
            "if (now == 0) return func_(ans_), true;",
            "for_(i, 0, r)",
            "if (cnt_col[i] < cnt_col[now]) now = i;",
            "remove_(now);",
            "bool ret = false;",
            "for_(i, now, d) {",
            "ans_.push_back(row_(i));",
            "for_(j, i, r) remove_(col_(j));",
            "ret |= dance_(ans_, func_);",
            "for_(j, i, l) resume_(col_(j));",
            "if (!multians && ret) return true;",
            "ans_.pop_back();",
            "}",
            "resume_(now);",
            "return ret;",
            "}",
            "void ins_row_(size_t row, const std::vector<size_t> &cols) {",
            "assert(row > 0);",
            "size_t sz = data.size();",
            "for (size_t i = 0; i < cols.size(); ++i) {",
            "data.emplace_back(sz + i - 1, sz + i + 1, u_(cols[i]), cols[i], row, cols[i]);",
            "u_(cols[i]) = d_(u_(cols[i])) = sz + i;",
            "++cnt_col[cols[i]];",
            "if (d_(cols[i]) == cols[i]) d_(cols[i]) = sz + i;",
            "}",
            "r_(l_(sz) = data.size() - 1) = sz;",
            "}",
            "public:",
            "explicit DLX(size_t width, bool multi_ans = false): data(), cnt_col(), multians(multi_ans) { reset(width); }",
            "explicit DLX(std::vector<std::vector<bool>> const &grid, bool multi_ans = false): data(), cnt_col(), multians(multi_ans) { reset_grid(grid); }",
            "friend std::ostream &operator<<(std::ostream &os, DLX const &dlx) {",
            "os << dlx.data[0].l << ' ' << dlx.cnt_col.size() << ' ' << dlx.data.size() << '\\n';",
            "for (size_t i = 1; i < dlx.cnt_col.size(); ++i) os << dlx.cnt_col[i] << \" \\n\"[i == dlx.cnt_col.size() - 1];",
            "for (size_t i = 0; i < dlx.data.size(); ++i) os << i << \": \" << dlx.data[i] << '\\n';",
            "return os;",
            "}",
            "void reset(size_t width) {",
            "assert(width > 0);",
            "data.clear();",
            "cnt_col.resize(width + 1, 0);",
            "for (size_t i = 0; i <= width; ++i) data.emplace_back(i - 1, i + 1, i, i, 0, i);",
            "r_(l_(0) = width) = 0;",
            "}",
            "void reset_grid(std::vector<std::vector<bool>> const &grid) {",
            "size_t col = grid[0].size();",
            "for (size_t i = 1; i < grid.size(); ++i) col = std::max(col, grid[i].size());",
            "reset(col);",
            "std::vector<size_t> _;",
            "for (size_t i = 0; i < grid.size(); ++i) {",
            "_.clear();",
            "for (size_t j = 0; j < grid[i].size(); ++j)",
            "if (grid[i][j]) _.push_back(j + 1);",
            "if (!_.empty()) ins_row_(i + 1, _);",
            "}",
            "}",
            "std::pair<bool, std::vector<size_t>> dance(std::function<void(std::vector<size_t> const &)> func = [](std::vector<size_t> const &) {}) {",
            "std::vector<size_t> ans;",
            "return {dance_(ans, func), ans};",
            "}",
            "#undef l_",
            "#undef r_",
            "#undef u_",
            "#undef d_",
            "#undef row_",
            "#undef col_",
            "#undef for_",
            "};",
            "template <size_t N>",
            "class Sudoku {",
            "static_assert(N > 0);",
            "constexpr static size_t N2 = N * N, N4 = N2 * N2;",
            "using self = Sudoku<N>;",
            "using data_t = std::array<std::array<size_t, N2>, N2>;",
            "protected:",
            "data_t data;",
            "public:",
            "Sudoku(): data() {}",
            "friend std::istream &operator>>(std::istream &is, self &sdk) {",
            "for (size_t i = 0; i < N2; ++i)",
            "for (size_t j = 0; j < N2; ++j) is >> sdk.data[i][j];",
            "return is;",
            "}",
            "friend std::ostream &operator<<(std::ostream &os, self const &sdk) {",
            "for (size_t i = 0; i < N2; ++i)",
            "for (size_t j = 0; j < N2; ++j) {",
            "os << sdk.data[i][j];",
            "if (i != N2 - 1 || j != N2 - 1) os << \" \\n\"[j == N2 - 1];",
            "}",
            "return os;",
            "}",
            "void set(size_t row, size_t col, size_t val) {",
            "assert(row < N2 && col < N2 && val <= N2);",
            "data[row][col] = val;",
            "}",
            "size_t get(size_t row, size_t col) const { return data[row][col]; }",
            "std::vector<self> solve(bool get_all_solution = false) {",
            "std::vector<std::vector<bool>> st(N2 * N4, std::vector<bool>(4 * N4));",
            "bool not_filled = true;",
            "for (size_t i = 0; i < N2; ++i)",
            "for (size_t j = 0; j < N2; ++j) {",
            "for (size_t k = 1; k <= N2; ++k) {",
            "if (data[i][j] && data[i][j] != k) continue;",
            "not_filled |= data[i][j] == 0;",
            "auto _ = (k - 1) * N4 + i * N2 + j;",
            "st[_][i * N2 + j] = st[_][i * N2 + k + N4 - 1] = st[_][j * N2 + k + N4 * 2 - 1] = st[_][(i / N * N + j / N) * N2 + k + N4 * 3 - 1] = true;",
            "}",
            "}",
            "std::vector<self> ans;",
            "if (!not_filled) {",
            "ans.push_back(*this);",
            "return ans;",
            "}",
            "auto func = [&ans](std::vector<size_t> const &res) {",
            "self sdk;",
            "for (auto &&_ : res) sdk.set((_ - 1) % N4 / N2, (_ - 1) % N2, (_ - 1) / N4 + 1);",
            "ans.push_back(sdk);",
            "};",
            "DLX dlx(st, get_all_solution);",
            "dlx.dance(func);",
            "return ans;",
            "}",
            "};",
            "}  // namespace SUDOKU",
            "using SUDOKU::Sudoku;",
        ]
    },
    "Texas Hold'em Poker": {
        "scope": "cpp",
        "prefix": [
            "thpoker",
            "texas",
            "texas-holdem",
            "texas-poker"
        ],
        "body": [
            "namespace TexasHoldemPoker {",
            "constexpr int bsr(int a) { return 31 - __builtin_clz(a); }",
            "// Returns the submask containing highest k bits set",
            "// Returns -1 instead if popcnt(a) < k",
            "constexpr int hbits(int a, int k) { int b = 0; for (int i = 0; i < k; ++i) { if (!a) return -1; a &= ~(b |= 1 << bsr(a)); } return b; }",
            "class Card {",
            "protected:",
            "int data = 0;",
            "public:",
            "constexpr static char RANKS[16] = \"0123456789TJQKA\"; constexpr static char SUITS[5] = \"CDHS\";",
            "Card() = default;",
            "Card(char rank, char suit) { encode(rank, suit); }",
            "explicit Card(const std::string &str): Card(str[0], str[1]) { assert(str.size() == 2); }",
            "// Parses a card in a format as \"2C\"",
            "// @return: 4 * (rank - 2) + suit  (2 <= rank <= 14)",
            "constexpr void encode(char rank, char suit) {",
            "int r = 2, s = 0;",
            "for (; r < 15; ++r) if (RANKS[r] == rank) break; assert(r < 15);",
            "for (; s < 4; ++s) if (SUITS[s] == suit) break; assert(s < 4);",
            "data = (r - 2) << 2 | s;",
            "}",
            "constexpr int get_rank() const { return (data >> 2) + 2; } constexpr int get_suit() const { return data & 3; }",
            "// @return: {rank_char, suit_char}",
            "constexpr std::pair<char, char> decode() const { return {RANKS[get_rank()], SUITS[get_suit()]}; }",
            "friend std::istream &operator>>(std::istream &is, Card &card) { char rk, st; is >> rk >> st; card.encode(rk, st); return is; }",
            "friend std::ostream &operator<<(std::ostream &os, const Card &card) { auto &&_ = card.decode(); return os << _.first << _.second; }",
            "};",
            "enum Category {HIGH_CARD, ONE_PAIR, TWO_PAIR, THREE_OF_A_KIND, STRAIGHT, FLUSH, FULL_HOUSE, FOUR_OF_A_KIND, STRAIGHT_FLUSH};",
            "constexpr static char CATEGORY_STR[9][20] = {\"HIGH_CARD\", \"ONE_PAIR\", \"TWO_PAIR\", \"THREE_OF_A_KIND\", \"STRAIGHT\", \"FLUSH\", \"FULL_HOUSE\", \"FOUR_OF_A_KIND\", \"STRAIGHT_FLUSH\"};",
            "class Hand {",
            "protected:",
            "std::vector<Card> cds;",
            "// ranks for all",
            "int rka = 0;",
            "// suit -> rank",
            "int mps[4] = {};",
            "// rank -> count",
            "int cnt[15] = {};",
            "// count -> rank",
            "int mpc[5] = {};",
            "public:",
            "Hand() = default;",
            "// Set first 5 element as hand _",
            "Hand &reset(const std::vector<Card> &_) {",
            "assert(_.size() >= 5);",
            "cds.clear();",
            "for (size_t i = 0; i < 5; ++i) cds.push_back(_[i]);",
            "for (auto &&card : cds) { auto r = card.get_rank(), s = card.get_suit(); rka |= mps[s] |= 1 << r; ++cnt[r]; }",
            "for (int r = 2; r < 15; ++r) mpc[cnt[r]] |= 1 << r;",
            "return *this;",
            "}",
            "// Returns the best poker hand with the tie-breaker in [0, 2^20)",
            "std::pair<Category, int> parse() const {",
            "assert(cds.size() == 5);",
            "//! The judger of all the categories",
            "const static std::function<std::tuple<bool, Category, int>(const Hand &)> checks[8] = {",
            "// 8. STRAIGHT_FLUSH: highest (5 for A2345)",
            "[](const Hand &h) -> std::tuple<bool, Category, int> {",
            "int f = 0;",
            "for (int s = 0; s < 4; ++s) f |= h.mps[s] & h.mps[s] << 1 & h.mps[s] << 2 & h.mps[s] << 3 & (h.mps[s] << 4 | h.mps[s] >> 14 << 5);",
            "return {!!f, STRAIGHT_FLUSH, bsr(f)};",
            "},",
            "// 7. FOUR_OF_A_KIND: quadruple, other card",
            "[](const Hand &h) -> std::tuple<bool, Category, int> {",
            "if (!h.mpc[4]) return {false, FOUR_OF_A_KIND, 0};",
            "const int r4 = bsr(h.mpc[4]);",
            "return {true, FOUR_OF_A_KIND, r4 << 4 | bsr(h.rka ^ 1 << r4)};",
            "},",
            "// 6. FULL_HOUSE: triple, pair",
            "[](const Hand &h) -> std::tuple<bool, Category, int> {",
            "if (!h.mpc[3]) return {false, FULL_HOUSE, 0};",
            "const int r3 = bsr(h.mpc[3]), d = (h.mpc[3] ^ 1 << r3) | h.mpc[2];",
            "if (!d) return {false, FULL_HOUSE, 1};",
            "const int r2 = bsr(d);",
            "return {true, FULL_HOUSE, r3 << 4 | r2};",
            "},",
            "// 5. FLUSH: 5 highest cards",
            "[](const Hand &h) -> std::tuple<bool, Category, int> {",
            "int flush = -1;",
            "for (int s = 0, _; s < 4; ++s) if (flush < (_ = hbits(h.mps[s], 5))) flush = _;",
            "return {flush >= 0, FLUSH, flush};",
            "},",
            "// 4. STRAIGHT: highest (5 for A2345)",
            "[](const Hand &h) -> std::tuple<bool, Category, int> {",
            "const int f = h.rka & h.rka << 1 & h.rka << 2 & h.rka << 3 & (h.rka << 4 | h.rka >> 14 << 5);",
            "return {!!f, STRAIGHT, bsr(f)};",
            "},",
            "// 3. THREE_OF_A_KIND: triple, 2 highest other cards",
            "[](const Hand &h) -> std::tuple<bool, Category, int> {",
            "if (!h.mpc[3]) return {false, THREE_OF_A_KIND, 0};",
            "const int r3 = bsr(h.mpc[3]);",
            "return {true, THREE_OF_A_KIND, r3 << 16 | hbits(h.rka ^ 1 << r3, 2)};",
            "},",
            "// 2. TWO_PAIR: larger pair, smaller pair, other card",
            "// 1. ONE_PAIR: pair, 3 highest other cards",
            "[](const Hand &h) -> std::tuple<bool, Category, int> {",
            "if (!h.mpc[2]) return {false, ONE_PAIR, 0};",
            "const int r2 = bsr(h.mpc[2]);",
            "const int d = h.mpc[2] ^ 1 << r2;",
            "if (!d) return {true, ONE_PAIR, r2 << 16 | hbits(h.rka ^ 1 << r2, 3)};",
            "const int r22 = bsr(d);",
            "return {true, TWO_PAIR, r2 << 8 | r22 << 4 | bsr(h.rka ^ 1 << r2 ^ 1 << r22)};",
            "},",
            "// 0. HIGH_CARD: 5 highest cards",
            "[](const Hand &h) -> std::tuple<bool, Category, int> { return {true, HIGH_CARD, hbits(h.rka, 5)}; }};",
            "for (auto &&func : checks) { auto ret = func(*this); if (std::get<0>(ret)) return {std::get<1>(ret), std::get<2>(ret)}; }",
            "//? Should be never reached",
            "exit(114);",
            "}",
            "friend std::ostream &operator<<(std::ostream &os, const Hand &hands) { for (size_t i = 0; i < 5 - 1; ++i) os << hands.cds[i] << ' '; return os << hands.cds[5 - 1]; }",
            "};",
            "} using TexasHoldemPoker::Card; using TexasHoldemPoker::Category; using TexasHoldemPoker::Hand;"
        ]
    }
}
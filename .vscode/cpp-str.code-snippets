{
    // Place your CP-workplace workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "hash-str": {
        "scope": "cpp",
        "prefix": [
            "hash-str"
        ],
        "body": [
            "class HashStr {",
            "protected:",
            "const static uint64_t mod = (1ull << 61) - 1; const static uint64_t _2e30n1 = (1ul << 30) - 1, _2e31n1 = (1ul << 31) - 1;",
            "std::uniform_int_distribution<uint32_t> b_range;",
            "std::mt19937 e;",
            "uint32_t b;",
            "std::vector<uint64_t> p, hash;",
            "bool base_reseted_ = true;",
            "constexpr uint64_t mul_(uint64_t a, uint64_t b) const {",
            "uint64_t au = a >> 31, ad = a & _2e31n1; uint64_t bu = b >> 31, bd = b & _2e31n1;",
            "uint64_t _ = ad * bu + au * bd;",
            "return ((au * bu) << 1) + ad * bd + ((_ & _2e30n1) << 31) + (_ >> 30);",
            "}",
            "constexpr uint64_t mod_(uint64_t a) const { a = (a & mod) + (a >> 61); return a > mod ? a - mod : a; }",
            "public:",
            "explicit HashStr(uint32_t base = 0, uint32_t range_a = 129, uint32_t range_b = UINT32_MAX): b_range(129, range_b), e() { reset_base(b = base); }",
            "HashStr &reset_base(uint32_t base = 0) { if (!(b = base)) b = mod_(b_range(e)); base_reseted_ = true; return *this; }",
            "HashStr &reset(std::string_view str) {",
            "hash.resize(1, 0);",
            "for (auto &&ch : str) hash.push_back(mod_(mul_(hash.back(), b) + ch + 1));",
            "if (base_reseted_) { p.resize(1, 1); for (size_t i = 0; i < str.size(); ++i) p.push_back(mod_(mul_(p.back(), b))); base_reseted_ = false; }",
            "return *this;",
            "}",
            "uint32_t get_base() const { return b; }",
            "uint64_t get(size_t pos, size_t len = SIZE_MAX) const { assert(pos < hash.size()); auto &&end_ = hash[pos + std::min(len, hash.size() - 1 - pos)]; return mod_(end_ + mod * 7 - mul_(hash[pos], p[len])); }",
            "};"
        ]
    },
    "hash-str2": {
        "scope": "cpp",
        "prefix": [
            "hash-str2"
        ],
        "body": [
            "class HashStr2 {",
            "protected:",
            "std::uniform_int_distribution<uint32_t> b_range;",
            "std::mt19937 e;",
            "const uint64_t mod1, mod2;",
            "uint32_t b;",
            "std::vector<std::pair<uint64_t, uint64_t>> p, hash;",
            "bool base_reseted_ = true;",
            "public:",
            "explicit HashStr2(uint64_t mod1, uint64_t mod2, uint32_t base = 0, uint32_t range_a = 129, uint32_t range_b = UINT32_MAX): b_range(range_a, range_b), e(), mod1(mod1), mod2(mod2) { reset_base(b = base); }",
            "HashStr2 &reset_base(uint32_t base = 0) { if (!(b = base)) b = b_range(e) % std::min(mod1, mod2); base_reseted_ = true; return *this; }",
            "HashStr2 &reset(std::string_view str) {",
            "hash.resize(1, {0, 0});",
            "for (auto &&ch : str) hash.emplace_back((hash.back().first * b % mod1 + ch + 1) % mod1, (hash.back().second * b % mod2 + ch + 1) % mod2);",
            "if (base_reseted_) {",
            "p.resize(1, {1, 1});",
            "for (size_t i = 0; i < str.size(); ++i) p.emplace_back(p.back().first * b % mod1, p.back().second * b % mod2);",
            "base_reseted_ = false;",
            "}",
            "return *this;",
            "}",
            "uint32_t get_base() const { return b; }",
            "std::pair<uint64_t, uint64_t> get(size_t pos, size_t len = SIZE_MAX) const {",
            "assert(pos < hash.size());",
            "auto &&end_ = hash[pos + std::min(len, hash.size() - 1 - pos)];",
            "return {(end_.first + mod1 - (int64_t)hash[pos].first * p[len].first % mod1) % mod1, (end_.second + mod2 - (int64_t)hash[pos].second * p[len].second % mod2) % mod2};",
            "}",
            "};"
        ]
    },
    "KMP-FFT": {
        "scope": "cpp",
        "prefix": [
            "kmp-fft",
            "fft-kmp"
        ],
        "body": [
            "//! requires FFT",
            "//! EPS should be a little larger (about <length of string> * <minimum character> * <normal EPS (such as 1e-6)>)",
            "namespace FFT_KMP {",
            "const double EPS = 1e2;",
            "// KMP",
            "std::vector<size_t> match_normal(std::string_view s, std::string_view t) {",
            "size_t m = s.size(), n = t.size();",
            "std::vector<double> a(m), b(n), f(n);",
            "std::copy(s.begin(), s.end(), a.rbegin());",
            "std::copy(t.begin(), t.end(), b.begin());",
            "double T = std::accumulate(a.begin(), a.end(), .0, [](auto &&x, auto &&y) { return x + y * y; });",
            "std::partial_sum(b.begin(), b.end(), f.begin(), [](auto &&x, auto &&y) { return x + y * y; });",
            "std::vector<double> g = FFT::conv(a, b);",
            "std::vector<size_t> res;",
            "for (size_t i = m - 1; i < n; ++i)",
            "if (abs(T + f[i] - (i < m ? 0 : f[i - m]) - 2 * g[i]) < EPS) res.push_back(i - m + 1);",
            "return res;",
            "}",
            "// KMP with wildcard `*`",
            "std::vector<size_t> match_star(std::string_view s, std::string_view t) {",
            "size_t m = s.size(), n = t.size();",
            "std::vector<double> a(m), aa(m), b(n), bb(m);",
            "for (size_t i = 0; i < m; ++i) a[m - i - 1] = s[i] == '*' ? 0 : s[i];",
            "aa = a;",
            "for (size_t i = 0; i < n; ++i) b[i] = t[i] == '*' ? 0 : t[i];",
            "bb = b;",
            "std::for_each(aa.begin(), aa.end(), [](auto &&x) { x = x * x * x; });",
            "std::for_each(bb.begin(), bb.end(), [](auto &&x) { x = x * x * x; });",
            "std::vector<double> f = FFT::conv(aa, b), g = FFT::conv(a, bb);",
            "std::for_each(a.begin(), a.end(), [](auto &&x) { x = x * x; });",
            "std::for_each(b.begin(), b.end(), [](auto &&x) { x = x * x; });",
            "std::vector<double> h = FFT::conv(a, b);",
            "std::vector<size_t> res;",
            "for (size_t i = m - 1; i < n; ++i)",
            "if (abs(f[i] + g[i] - 2 * h[i]) < EPS) res.push_back(i - m + 1);",
            "return res;",
            "}",
            "}  // namespace FFT_KMP"
        ]
    },
    "manacher": {
        "scope": "cpp",
        "prefix": [
            "manacher"
        ],
        "body": [
            "uint32_t manacher(std::string_view s) {",
            "std::string _ = \"\\001\\002\";",
            "_.reserve(2 * s.size() + 2);",
            "for (auto &&ch : s) { _.push_back(ch); _.push_back('\\002'); }",
            "std::vector<uint32_t> r(_.size());",
            "uint32_t r_max = 0, mid = 0;",
            "for (uint32_t i = 1; i < _.size(); ++i) {",
            "r[i] = (i < r_max) ? std::min(r[(mid << 1) - i], r_max - i) : 1;",
            "while (1 + r[i] <= i && i + r[i] <= _.size() && _[i - r[i]] == _[i + r[i]]) ++r[i];",
            "if (i + r[i] > r_max) r_max = i + r[mid = i];",
            "}",
            "uint32_t l_max = 1; for (uint32_t i = 1; i < r.size(); ++i) l_max = std::max(l_max, r[i]); return l_max - 1;",
            "}"
        ]
    },
    "suffix-array": {
        "scope": "cpp",
        "prefix": [
            "sa",
            "suffix-array"
        ],
        "body": [
            "namespace SA {",
            "std::vector<int> sa_naive(const std::vector<int> &s) {",
            "int n = int(s.size());",
            "std::vector<int> sa(n);",
            "std::iota(sa.begin(), sa.end(), 0);",
            "std::sort(sa.begin(), sa.end(), [&](int l, int r) {",
            "if (l == r) return false;",
            "while (l < n && r < n) {",
            "if (s[l] != s[r]) return s[l] < s[r];",
            "l++;",
            "r++;",
            "}",
            "return l == n;",
            "});",
            "return sa;",
            "}",
            "std::vector<int> sa_doubling(const std::vector<int> &s) {",
            "int n = int(s.size());",
            "std::vector<int> sa(n), rnk = s, tmp(n);",
            "std::iota(sa.begin(), sa.end(), 0);",
            "for (int k = 1; k < n; k *= 2) {",
            "auto cmp = [&](int x, int y) {",
            "if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];",
            "int rx = x + k < n ? rnk[x + k] : -1;",
            "int ry = y + k < n ? rnk[y + k] : -1;",
            "return rx < ry;",
            "};",
            "std::sort(sa.begin(), sa.end(), cmp);",
            "tmp[sa[0]] = 0;",
            "for (int i = 1; i < n; ++i) tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);",
            "std::swap(tmp, rnk);",
            "}",
            "return sa;",
            "}",
            "template <int THRN = 10, int THRD = 40>",
            "std::vector<int> sa_is(const std::vector<int> &s, int upper) {",
            "int n = int(s.size());",
            "if (n == 0) return std::vector<int>{};",
            "if (n == 1) return std::vector<int>{0};",
            "if (n == 2) return s[0] < s[1] ? std::vector<int>{0, 1} : std::vector<int>{1, 0};",
            "if (n < THRN) return sa_naive(s);",
            "if (n < THRD) return sa_doubling(s);",
            "std::vector<int> sa(n);",
            "std::vector<bool> ls(n);",
            "for (int i = n - 2; i >= 0; --i) ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);",
            "std::vector<int> sum_l(upper + 1), sum_s(upper + 1);",
            "for (int i = 0; i < n; ++i) (ls[i] ? sum_l[s[i] + 1] : sum_s[s[i]])++;",
            "for (int i = 0; i <= upper; ++i) {",
            "sum_s[i] += sum_l[i];",
            "if (i < upper) sum_l[i + 1] += sum_s[i];",
            "}",
            "auto induce = [&](const std::vector<int> &lms) {",
            "std::fill(sa.begin(), sa.end(), -1);",
            "std::vector<int> buf(upper + 1);",
            "std::copy(sum_s.begin(), sum_s.end(), buf.begin());",
            "for (auto d : lms) {",
            "if (d == n) continue;",
            "sa[buf[s[d]]++] = d;",
            "}",
            "std::copy(sum_l.begin(), sum_l.end(), buf.begin());",
            "sa[buf[s[n - 1]]++] = n - 1;",
            "for (int i = 0, v; i < n; ++i)",
            "if ((v = sa[i]) >= 1 && !ls[v - 1]) sa[buf[s[v - 1]]++] = v - 1;",
            "std::copy(sum_l.begin(), sum_l.end(), buf.begin());",
            "for (int i = n - 1, v; i >= 0; --i)",
            "if ((v = sa[i]) >= 1 && ls[v - 1]) sa[--buf[s[v - 1] + 1]] = v - 1;",
            "};",
            "std::vector<int> lms_map(n + 1, -1);",
            "int m = 0;",
            "for (int i = 1; i < n; ++i)",
            "if (!ls[i - 1] && ls[i]) lms_map[i] = m++;",
            "std::vector<int> lms;",
            "lms.reserve(m);",
            "for (int i = 1; i < n; ++i)",
            "if (!ls[i - 1] && ls[i]) lms.push_back(i);",
            "induce(lms);",
            "if (m) {",
            "std::vector<int> sorted_lms;",
            "sorted_lms.reserve(m);",
            "for (int v : sa)",
            "if (lms_map[v] != -1) sorted_lms.push_back(v);",
            "std::vector<int> rec_s(m);",
            "int rec_upper = 0;",
            "rec_s[lms_map[sorted_lms[0]]] = 0;",
            "for (int i = 1; i < m; ++i) {",
            "int l = sorted_lms[i - 1], r = sorted_lms[i];",
            "int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;",
            "int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;",
            "bool same = true;",
            "if (end_l - l != end_r - r) {",
            "same = false;",
            "} else {",
            "while (l < end_l) {",
            "if (s[l] != s[r]) break;",
            "++l;",
            "++r;",
            "}",
            "if (l == n || s[l] != s[r]) same = false;",
            "}",
            "if (!same) ++rec_upper;",
            "rec_s[lms_map[sorted_lms[i]]] = rec_upper;",
            "}",
            "auto rec_sa = sa_is<THRN, THRD>(rec_s, rec_upper);",
            "for (int i = 0; i < m; ++i) sorted_lms[i] = lms[rec_sa[i]];",
            "induce(sorted_lms);",
            "}",
            "return sa;",
            "}",
            "std::vector<int> suffix_array(std::string_view s) {",
            "int n = int(s.size());",
            "std::vector<int> s2(n);",
            "for (int i = 0; i < n; ++i) s2[i] = s[i];",
            "return sa_is(s2, 255);",
            "}",
            "// Longest-Common-Prefix Computation in Suffix Arrays and Its Applications",
            "template <class T>",
            "std::vector<int> lcp_array(const std::vector<T> &s, const std::vector<int> &sa) {",
            "int n = int(s.size());",
            "assert(n >= 1);",
            "std::vector<int> rnk(n);",
            "for (int i = 0; i < n; ++i) rnk[sa[i]] = i;",
            "std::vector<int> lcp(n - 1);",
            "for (int i = 0, h = 0; i < n; ++i) {",
            "if (h > 0) --h;",
            "if (rnk[i] == 0) continue;",
            "for (int j = sa[rnk[i] - 1]; j + h < n && i + h < n; ++h)",
            "if (s[j + h] != s[i + h]) break;",
            "lcp[rnk[i] - 1] = h;",
            "}",
            "return lcp;",
            "}",
            "// Longest-Common-Prefix Computation in Suffix Arrays and Its Applications",
            "std::vector<int> lcp_array(std::string_view s, const std::vector<int> &sa) {",
            "int n = int(s.size());",
            "std::vector<int> s2(n);",
            "for (int i = 0; i < n; ++i) s2[i] = s[i];",
            "return lcp_array(s2, sa);",
            "}",
            "}  // namespace SA",
            "using SA::lcp_array, SA::suffix_array;"
        ]
    },
    "Trie": {
        "scope": "cpp",
        "prefix": "trie",
        "body": [
            "template <char BGNCH = 'a', char ENDCH = 'z' + 1>",
            "class Trie {",
            "using self = Trie<BGNCH, ENDCH>;",
            "struct trie_t {",
            "size_t next[ENDCH - BGNCH];",
            "bool end;",
            "trie_t(): end(false) { memset(next, 0, sizeof(next)); }",
            "};",
            "protected:",
            "std::vector<trie_t> data;",
            "size_t sz;",
            "public:",
            "Trie(): data(1), sz(0) {}",
            "void clear() {",
            "data.clear();",
            "data.resize(1);",
            "sz = 0;",
            "}",
            "self &insert(std::string_view str) {",
            "size_t p = 0;",
            "for (size_t i = 0, c; i < str.size(); ++i) {",
            "if (!data[p].next[c = str[i] - BGNCH]) {",
            "data[p].next[c] = data.size();",
            "data.emplace_back();",
            "}",
            "p = data[p].next[c];",
            "}",
            "sz += !data[p].end;",
            "data[p].end = true;",
            "return *this;",
            "}",
            "constexpr size_t size() const { return sz; }",
            "size_t node_size() const { return data.size(); }",
            "bool query(std::string_view str) const {",
            "size_t p = 0;",
            "for (size_t i = 0, c; i < str.size(); ++i) {",
            "if (!data[p].next[c = str[i] - BGNCH]) return false;",
            "p = data[p].next[c];",
            "}",
            "return data[p].end;",
            "}",
            "};"
        ]
    }
}